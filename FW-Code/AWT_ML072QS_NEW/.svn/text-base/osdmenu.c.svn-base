// osdmenu.c

#include "Config.h"
#include "typedefs.h"
#include "Reg.h"
#include "main.h"
#include "i2c.h"
#include "Tw88.h"
#include "measure.h"
#include "dispinfo.h"
#include "osdbasic.h"
#include "osdmenu.h"
#include "adc.h"
#include "debug.h"
#include "etc_eep.h"
#include "pc_eep.h"
#include "audio.h"
#include "printf.h"
#include "udfont.h"
#include "panel.h"
#include "rgbmix.h"		// for TW8801
#include "cpu.h"

#include "HS_keyremo.h"
#include "HS_DVRProtocol.h"
#include "HS_DisplayOSD.h"
#include "HS_IOdef.h"

static  WORD	OSDItemValue;
//static  BYTE	OSDDuration;

static  BYTE	title_item, cursor_item, /*cursor_y,*/  cur_osdwin, /*cur_osdaddr,*/ val_osdwin=0xff, 
						val_index=0;

static	BYTE	OSDMenuX, OSDMenuY;/*ljy100303..., OSDZoom*/
static  BYTE	OSDLang=0;

static  BYTE    OSDMenuLevel;
	    bit     OnChangingValue = 0;
	   		bit   					displayOnValueWindow = 0;
//static  BYTE    OSDNumberString[5];

//extern  IDATA struct BarInfo BarInfo;
extern BYTE	year1,year2,month,day,hour,minute,second;

BYTE	PW_FirstNumber=0			;
BYTE	PW_SecondNumber=0			;
BYTE	PW_ThridNumber=0			;
BYTE	PW_FourthNumber=0			;
BYTE	DVR_DataChange=0;
#ifdef E_Wintek
bit	FactoryMenu;
#endif
extern BYTE  CAMNumber;
extern BYTE  PelcoChoiceFLAG;
extern BYTE  Baud_rate;
extern BYTE	DVR_daylightsaving;
extern BYTE	DVR_timebeginesmonth;
extern BYTE	DVR_timebeginesweek;
extern BYTE	DVR_timebeginesTime;
extern BYTE	DVR_sandardtimebeginesMonth;
extern BYTE	DVR_standardtimebeginesWeek;
extern BYTE	DVR_standardtimebeginesTime;
extern BYTE	DVR_Resolution			;
extern BYTE	DVR_FPS					;
extern BYTE	DVR_Quality				;
extern BYTE	DVR_RecordMode			;
extern BYTE	DVR_RecordLength		;
extern BYTE	DVR_PreAlarmLength		;
extern BYTE	DVR_PostAlarmLength		;
extern BYTE	FormatStatus			;
extern bit		FormatStart				;
extern BYTE	FormatWait				;
extern BYTE	DVR_TimeZone			;
extern BYTE	DVR_AudioRecord			;
extern BYTE	DVR_OverWrite;
extern bit	 	SpeedDomeMode;
extern BYTE	DVR_SDCardAvailable		;
extern DATA BYTE	RS2_in;	
extern  CODE  struct struct_IdName struct_VInputStd[];
extern  CODE  struct struct_IdName struct_InputSelection[];
//extern  IDATA BYTE InputSelectionInx;
//extern	bit	  PowerMode ;
extern	bit   I2CAutoIncFlagOn ;
extern	BYTE  VInputStdDetectMode;
extern CODE BYTE Init_Osd_MainMenu[];
#ifdef ADD_ANALOGPANEL
extern CODE BYTE Init_Osd_MainMenu_A[];
#endif
//extern  bit		DisplayInputHold;		//william-981029

struct MenuType   	CODE *MenuFormat;
struct RegisterInfo CODE *BarRange;
struct DefineMenu 	CODE *MenuTitle;
struct DefineMenu 	CODE *MenuChild;
struct DefineMenu	CODE *MenuStack[4];
static IDATA  BYTE MenuSP=0, MenuIndexStack[4];


#include "OSDString.h"
#include "menu.h"
#include "OSDOper.c"

#ifdef SUPPORT_LINE_OSDDEMO
 #include "OsdInitTable_Line.c"
#endif
//---------------------------------------------------------------------
// Push MenuTile, title_item in stack 
//      MenuTile[title_item][]...  
//
BYTE pushMenu(void)
{
	#ifdef DEBUG_OSD
	dPrintf("\r\n(pushMenu)-MenuSP:%d", (WORD)MenuSP);
	#endif
	if( MenuSP < sizeof( MenuIndexStack ) ) {
		#ifdef DEBUG_OSD
		{
			BYTE  **Desc;
			BYTE i;

			Desc = MenuTitle[title_item].Desc;
			for(i=0; i<OSDLang; i++)
				Desc += ( strlen(*Desc) + 1 );

			dPrintf("...MenuStack[%d]:Desc(%s)",(WORD)MenuSP, Desc);
		}
		#endif
		MenuStack[MenuSP] = MenuTitle;
		MenuIndexStack[MenuSP++] = title_item;
		return 1;
	}
	return 0;
}

BYTE popMenu(void)
{
	#ifdef DEBUG_OSD
	dPrintf("\r\n(popMenu)-MenuSP:%d", (WORD)MenuSP);
	#endif
	if( MenuSP ) {
		MenuTitle = MenuStack[--MenuSP];
		title_item = MenuIndexStack[MenuSP];
		#ifdef DEBUG_OSD
		{
			BYTE  **Desc;
			BYTE i;

			Desc = MenuTitle[title_item].Desc;
			for(i=0; i<OSDLang; i++)
				Desc += ( strlen(*Desc) + 1 );


			dPrintf("...MenuStack[%d]:Desc(%s)",(WORD)MenuSP, Desc);
		}
		#endif
		return 1;
	}
	return 0;
}		

BYTE GetLowerMenuItem( CODE_P struct DefineMenu *DMp, BYTE itemno )
{
	if( itemno==NIL )
		return NIL;
	itemno++;
	if( (DMp[itemno].IconColor==NIL) && (DMp[itemno].DescColor==NIL) )		// end
		return NIL;
	return itemno;

}

BYTE GetUpperMenuItem(  BYTE itemno )
{
	//if( itemno==0 || 
	if(	itemno==NIL )
		return NIL;
	itemno--;
	return itemno;
}

BYTE GetTargetChild( BYTE tid)
{
	BYTE i;


	if( MenuChild )		i = 0;
	else				i = NIL;

	
	#ifdef DEBUG_OSD
	dPrintf("\r\nTarget id:0x%x", (WORD)tid);
	#endif

	while( i != NIL ) {
		
		#ifdef DEBUG_OSD
		dPrintf("__ForActionId[%d]:0x%x", (WORD)i, (WORD)MenuChild[i].Id);
		#endif
		
		if ( ( MenuChild[i].Id & 0x0f ) == tid )
			return i;//break;
		i = GetLowerMenuItem(MenuChild, i );
	}

	return i;
}
/*
BYTE GetTargetChild1( BYTE tid)
{
	BYTE i;


	if( MenuChild )		i = 0;
	else				i = NIL;

	
	#ifdef DEBUG_OSD
	dPrintf("\r\nTarget id:0x%x", (WORD)tid);
	#endif

	while( i != NIL ) {
		
		#ifdef DEBUG_OSD
		dPrintf("__ForActionId[%d]:0x%x", (WORD)i, (WORD)MenuChild[i]. PreFnId);
		#endif
		
		if ( ( MenuChild[i]. PreFnId & 0x0f ) == tid )
			return i;//break;
		i = GetLowerMenuItem( MenuChild, i );
	}
	return i;
}
*/
//===============================================================================
//
//  Display Information of the menu
//
//===============================================================================
CODE BYTE OSDInfoStr[][26]={
	{ "   Input  :              " },
	{ "   System :              " },
	{ "   H Freq :      kHz     " },	
	{ "   V Freq :       Hz     " },
	{ "   F/W Rev:              " }, 	
	{ "" }	
};
#define OSD_INFO_SUB_X	12//9

// Display the information on the screen.
// Input, System and F/W version
//----------------------------------------------------------------
void DisplayInfo_OSD(void)
{
	BYTE i, title=1, len, inputs;
	BYTE mstr[5];

	pushMenu();   //Jason Chen, the important subroutine.
	MenuTitle = MenuChild;
	title_item = cursor_item;

	OSDMenuLevel++; 
	
	MenuChild = 0;
	cursor_item = NIL;

	DrawMenulist(1); // Display Title

	DrawAttrCnt(OSDMENU_SUBADDR+MENU_WIDTH, OSD_INFO_COLOR, 5*MENU_WIDTH );	 // Line 1 ~ Line 5
	for(i=0; OSDInfoStr[i][0]; i++) 
		WriteStringToAddr(OSDMENU_SUBADDR+MENU_WIDTH*(i+title), OSDInfoStr[i], MENU_WIDTH ); 

	// Display Input
	inputs = GetInputSelection();
	for (i=1; ;i++)
		if( struct_InputSelection[i].Id==inputs )  break;
	len=strlen(struct_InputSelection[i].Name);
	WriteStringToAddr(OSDMENU_SUBADDR+MENU_WIDTH*(0+title)+OSD_INFO_SUB_X, struct_InputSelection[i].Name, len ); 

	// Display ColorSystem
	#if defined( SUPPORT_PC ) || defined( SUPPORT_DTV )
	i = GetInputSelection();
	if( i==PC || i==DTV ){
		len=strlen(GetPCInputSourceName());
		WriteStringToAddr(OSDMENU_SUBADDR+MENU_WIDTH*(1+title)+OSD_INFO_SUB_X, GetPCInputSourceName(), len ); 
	}
	else
	#endif
	{
		len=strlen(struct_VInputStd[GetVInputStdInx()].Name);
		WriteStringToAddr(OSDMENU_SUBADDR+MENU_WIDTH*(1+title)+OSD_INFO_SUB_X, struct_VInputStd[GetVInputStdInx()].Name, len ); 
	}
#ifdef REFERENCE
	//IHF
	MeasureAndWait(3);

	ltoa_K(GetIHF(), mstr, 1);
	len=strlen(mstr);
	WriteStringToAddr(OSDMENU_SUBADDR+MENU_WIDTH*(2+title)+OSD_INFO_SUB_X, mstr, len ); 

	utoa(GetIVF(),mstr,10);
	len=strlen(mstr);
	WriteStringToAddr(OSDMENU_SUBADDR+MENU_WIDTH*(3+title)+OSD_INFO_SUB_X, mstr, len ); 
#endif
	//FWRev
	i = ReadEEP(EEP_FWREV_MAJOR);
	mstr[0] = i + '0';
	mstr[1] = '.';
	i = ReadEEP(EEP_FWREV_MINOR);
	mstr[2] = (i/0x10) + '0';
	mstr[3] = (i%0x10) + '0';
	mstr[4] = '\0';
#ifdef REFERENCE	
	WriteStringToAddr(OSDMENU_SUBADDR+MENU_WIDTH*(4+title)+OSD_INFO_SUB_X, mstr, 4 ); 
#else
	WriteStringToAddr(OSDMENU_SUBADDR+MENU_WIDTH*(2+title)+OSD_INFO_SUB_X, mstr, 4 ); 
#endif
}

//********************************************************************
//
//	Functions for BAR.
//
//********************************************************************
#define VOLBAR_LENGTH 21+3
void DisplayVolumebar(BYTE val)
{
	CODE BYTE BAR_ROM_TABLE[] = {
		0x01, // ...
		0x02,0x02, // |..
		0x05,0x05, // ||.
		0x03, // |
		0x04, // |||
	};

	BYTE i;
	BYTE Bar_str[VOLBAR_LENGTH]={ 0x04, 0x04, 0x04, 0x04, 0x04,
							   0x04, 0x04, 0x04, 0x04, 0x04,
							   0x04, 0x04, 0x04, 0x04, 0x04,
							   0x04, 0x04, 0x04, 0x04, 0x04, 0x03,' ',' ',' ' };
	WORD addr;
	
	if(val < 100)
	{
		Bar_str[val/5] = BAR_ROM_TABLE[val%5];
		for(i = val/5 + 1; i < 20; i++)
			Bar_str[i] = BAR_ROM_TABLE[0];
	}

	if( Bar_str[0] == 0x01 ) Bar_str[0] = 0x02;	// |..

	// Number
    Bar_str[23] = val % 10 + '0';    val /= 10;
    Bar_str[22] =  val % 10 + '0';    val /= 10;
    Bar_str[21] = val + '0';
	if( Bar_str[21] == '0' ) Bar_str[21] = ' ';

	addr = OSDMENU_BARADDR + 1 + VOLBAR_LENGTH;	// 

	WriteStringToAddr(addr, Bar_str, VOLBAR_LENGTH ); 

}

BYTE Get_cursor_item(BYTE id)
{
	BYTE i=NIL, tid;

	#ifdef DEBUG_OSD
	dPrintf("\r\n++(Get_cursor_item) id:%d", (WORD)id);
	#endif

	
	switch ( id ) {
	case INPUTSELECTION:	tid = GetInputSelection(); 
							break;

	default:				return 0;// The first one
	}

	i = GetTargetChild( tid );

	if( i==NIL ) {	//couldn't find
		dPuts("___Couldn't find cursor!!");
		i=0;
	}

	#ifdef DEBUG_OSD
	dPrintf("___Cursor:%d\r\n__(GetDefaultForChoiceMenu)", (WORD)i);
	#endif

	return i;
}

//==================================================================================================
// Func: DisplayOSDMenuOneItem
//
//
void DisplayOSDMenuOneItem( winno, CODE_P struct DefineMenu *DMp, BYTE x, BYTE y, BYTE NOTViewflag )
{
	BYTE i,j,k,IconColor;
	WORD addr;
	CODE_P BYTE *Str;
	CODE BYTE RightSign_str[]=	{ 0x1c,' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',0 };// RIGHT mark
	CODE BYTE SpaceStr[]=  { ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',0 }; // V1.1 02/28/07 simonsung

	#ifdef DEBUG_OSD
	dPrintf("\r\n++(DisplayOSDMenuOneItem) ");
	#endif

	if( cur_osdwin == OSDMENU_TOPWIN) addr = OSDMENU_MAINADDR;
	else addr = OSDMENU_SUBADDR;

	addr = addr + x + y*MenuFormat->width;

	#ifdef DEBUG_OSD
	dPrintf("\r\nStartaddr:%d", addr);
	#endif

	if( DMp->IconColor !=NIL ) {		// Draw Icon
		//if(OnChangingValue) IconColor = BG_COLOR_BLACK|CH_COLOR_WHITE|EXTENDED_COLOR; 
		//else
			IconColor =  DMp->IconColor;

		Str = DMp->Icon;
		j=strlen(Str);
		WriteStringToAddr(addr, Str, j);

		x += ICON_CH_SZ;
	}

	if( DMp->DescColor !=NIL ) {		// Draw Desc.

		Str = DMp->Desc[OSDLang];
		j=strlen(Str);

		for( i=0,k=0; i<j; i++ )
			if( *(Str+i) == ROMFONT || *(Str+i) == RAMFONT ) k++;

		#ifdef DEBUG_OSD
		dPrintf("\r\naddr:%d x:%d y:%d MenuFormat->width:%d", addr, (WORD)x, (WORD)y, (WORD)MenuFormat->width );
		#endif

		WriteStringToAddr(addr, Str, j);

		if( (j-k ) < MAX_DESC ) 
			ClearDataCnt(addr+j-k, MAX_DESC-j+k);
	
		addr+=MAX_DESC;

	}

	if( OSDMenuLevel < 3) // Main Menu Item.
	 if ( NOTViewflag==1 )	return;	// In case of not need diplay contents. ex, BAR windows, top menu display.
	
	// Menu contents view
	/*if( x < (MenuFormat->width) )
		if( x <  (MAX_DESC + ICON_CH_SZ) ){
		//x+=2;
		ClearDataCnt(addr, 2);
		addr+=2;
	}*/

	switch (DMp->Type ) {
	case BAR:	// Draw Bar and Number value
		DisplayViewBar( addr, GetItemValue(DMp->Id));
		break;

	case NUMBER: // Draw Number value
		{
			CODE_P BYTE *ptr;
			ptr = DMp->TypeData;
			switch ( DMp->Id ) {
			#if defined( PAL_TV )
			case MANUAL_TUNE_CHANNEL:
				WriteStringToAddr(addr, RightSign_str, BARNUM_LENGTH); 
				break;
			#endif
			default:
				DrawNum( addr, (CODE_P struct NumType *)ptr, GetItemValue(DMp->Id) );
				break;
			}
		}
		break;
	case ENUM_STRING:		
		{
			CODE_P BYTE *ptr;

			ptr = DMp->TypeData;
			DrawStringByLang( addr, (CODE_P struct EnumType *)ptr, GetItemValue(DMp->Id) );

		}
		break;

	case NUMBER_STRING:
	case CHOICEMENU:
	case OSDMENU:
	case ACTION:
			WriteStringToAddr(addr, RightSign_str, BARNUM_LENGTH); 
			break;
	case TEXT_STR:  // V1.1 02/28/07 simonsung
	        WriteStringToAddr(addr, SpaceStr, BARNUM_LENGTH); 
		 break;		

	}
  
}

void ClearCursor(void)
{
	//BYTE cursor_x;
	BYTE cursor_y;
	WORD addr;

	if( cursor_item==NIL )
		return;

	//cursor_x = MenuFormat->CursorStart;
	cursor_y = cursor_item + ( MenuFormat->TitleColor ==NIL ? 0 : 1 );
	if( cur_osdwin == 4 ) addr = 0;
	else addr = 10;
	addr += cursor_y*MenuFormat->width;
	DrawAttrCnt(addr, DEFAULT_COLOR, MenuFormat->width );	

}

void DisplayCursor(void)
{
	BYTE cursor_y=0,i ;
	WORD addr;

	if( cursor_item==NIL )
		return;

    for(i=0;i<8;i++)  //william-20091026
    {
      cursor_y = i ;
      addr = OSDMENU_SUBADDR;  
      addr += cursor_y*MenuFormat->width; 
      DrawAttrCnt(addr, DEFAULT_COLOR, MenuFormat->width );  // 清除殘留小方格 
    }

	
	cursor_y = cursor_item + ( MenuFormat->TitleColor ==NIL ? 0 : 1 );

	if( OSDMenuLevel == 1 ) addr = OSDMENU_MAINADDR;
	else addr = OSDMENU_SUBADDR;

	addr += cursor_y*MenuFormat->width;

	if( OSDMenuLevel == 1)
		DrawAttrCnt(addr, MenuFormat->CursorColor, MenuFormat->width );	
	else
	{
		if(OnChangingValue)
		{
			GetItemValue(GetItemValue(MenuChild[cursor_item].Id));
			DrawAttrCnt(addr, MenuFormat->CursorColor, MenuFormat->width );	
		}
		else
		{
			DrawAttrCnt(addr, MenuFormat->CursorColor, MenuFormat->width-BARNUM_LENGTH );	
			DrawAttrCnt(addr+MAX_DESC, DEFAULT_COLOR, BARNUM_LENGTH );	
		}
	}	

}


//===============================================================================
//  OSD Menu Operation funtion moved to "OSDoper.c" by RYU.
// 
//===============================================================================

WORD GetItemValue( BYTE id)
{
	WORD val=0;

	#ifdef DEBUG_OSD
	dPrintf("\r\n++(GetItemValue) id:0x%x __", (WORD)id);
	#endif

	switch( id ) {
	//case SYSTEM_CLOCK:	val = GetSystemClock_HM();			break;
	//case WAKEUP_TIME:		val = OSDItemValue = GetWakeupTime();	break;
	//case OFF_TIME:		val = OSDItemValue = GetOffTime();		break;
	//case SLEEP_TIMER:		val = OSDItemValue = GetSleepTimer();	break;

#ifdef SUPPORT_OSDPOSITIONMOVE
	case OSDPOSITIONMODE:   val = GetOSDPositionMode();				break;
	//case OSD_VPOS:			val = GetOSDMenuYValue();				break;
	//case OSD_HPOS:			val = GetOSDMenuXValue();				break;
#endif
//	case OSD_DURATION:		val = GetOSDDurationValue();			break;
	case OSDLANG:			val = OSDLang & 0x0f;					break;

	#ifdef SUPPORT_PC
	case PANEL_CONTRAST:	val = OSDItemValue = GetPanelContrastEE();				break;
	case PANEL_BRIGHTNESS:	val = OSDItemValue = GetPanelBrightnessEE();			break;

	case PC_VPOS:			val = GetVPosition();					break;
	case PC_HPOS:			val = GetHPosition();					break;
	case PC_CLOCK:			val = GetCoarseValue();					break;
	case PC_PHASE:			val = GetPhaseCurrent();				break;

	case PC_COLOR_TEMP:		val = GetPCColorTempModeEE();			break;
	case PC_COLOR_R:		val = GetPCColorTemp(RED);				break;	
	case PC_COLOR_G:		val = GetPCColorTemp(GREEN);			break;	
	case PC_COLOR_B:		val = GetPCColorTemp(BLUE);				break;	
	#endif


	case VIDEO_MODE:		val = GetVideoModeEE();					break;

	case VIDEO_CONTRAST:	
	case VIDEO_BRIGHTNESS:	
	case VIDEO_SATURATION:	
	case VIDEO_HUE:			
	case VIDEO_SHARPNESS:	
	case VIDEO_BACKLIGHT:	
							val = GetVideoDatawithOffset(id-VIDEO_CONTRAST);	break;
	case AUDIO_VOLUME:		
//if((NowModeState==SelectMode&&SelectModeType==VGAMode)||(NowModeState==JumpMode&&((ReadEEP(EEP_JUMPMode)==14)||SelectModeType==VGAMode)))		//william-v1.1-20110114
		if(VGAAudio)
			val=PCAudioVol;
		else
			val = AudioVol;
		break;

	#if 0
	
	case AUDIO_BALANCE:		val = GetAudioBalance();				break;
	case AUDIO_BASS:		val = GetAudioBass();					break;
	case AUDIO_TREBLE:		val = GetAudioTreble();					break;
    #endif
	//case AUDIO_EFFECT:		val = GetAudioEffect();					break;
	//case AUDIO_MUTE:		val = IsAudioMuteOn();					break;

	case INPUTSTD:			val = OSDItemValue = VInputStdDetectMode;			
							break;

	#ifdef WIDE_SCREEN		//.................................................
	case WIDESCREEN:
							val = WideScreenMode;					break;
	#endif					//.................................................
    case DayChoice:           
         val = ReadEEP(EEP_AutoMode);
	     break;
	case CAMOSDONOFF:         
         val = ReadEEP(EEP_COSDMode);
	     break;
	case DVRDisplay:         
         val = ReadEEP(EEP_DVRDisplay);
	     break;	 
	case GAUGEChoice:        
         val = ReadEEP(EEP_GAUGEMode);
	     break; 
	case OsdLockChoice:        
         val = ReadEEP(EEP_ONOFFChoice);
	     break;	
	case PRIORITYChoice:
         val = ReadEEP(EEP_PRIORITY);
		break;
    case CAMAONOFF:
        val = ReadEEP(EEP_CAMAMode);
	    break;
	case CAMBONOFF:
        val = ReadEEP(EEP_CAMBMode);
	    break;
	case CAMCONOFF:
        val = ReadEEP(EEP_CAMCMode);
	    break;
	case CAMRONOFF:
        val = ReadEEP(EEP_CAMRMode);
	    break;
	case IMAGEChoice:
        val = ReadEEP(EEP_IMAGEMode);
	    break;
	case IMAGE_A_Choice: 				   //左右轉顯示畫面
	 val = ReadEEP(EEP_IMAGE_A_Mode);  //andy A1.4 20100113
		   break;
   	case IMAGE_B_Choice: 				   //左右轉顯示畫面
	 val = ReadEEP(EEP_IMAGE_B_Mode);  //andy A1.4 20100113
		   break;
   	case IMAGE_C_Choice: 				   //左右轉顯示畫面
	 val = ReadEEP(EEP_IMAGE_C_Mode);  //andy A1.4 20100113
		   break;		
	case REARChoice:
        val = ReadEEP(EEP_RearMode);
	    break;
	case TriggerVGA:
        val = ReadEEP(EEP_TriggerVGA);
	    break;	
	case JUMPChoice:
        val = ReadEEP(EEP_JUMPMode);
	    break;
	case CAMOUTChoice:
        val = ReadEEP(EEP_CAMOutMode);
	    break;
	case STIME_STEP:
        val = ReadEEP(EEP_TimeStep);
		//TimeStep=val; 
	    break;
		
//#ifdef SUPPORT_SDCARD		
	case Resolution:
		val = DVR_Resolution;
		break;
	case FPS:
		val = DVR_FPS;
		break;
	case Quality:
		val = DVR_Quality;
		break;
	case RecordMode:
		val = DVR_RecordMode;
		break;
	case RecordLength:
		val = DVR_RecordLength;
		break;
	case PreAlarmLength:
		val = DVR_PreAlarmLength;
		break;
	case PostAlarmLength:
		val = DVR_PostAlarmLength;
		break;

	case AudioRecord:
		val = DVR_AudioRecord;
		break;
		
	case Year:
		val = year2;
		break;
	case Month:
		val = month;
		break;
	case Day:
		val = day;
		break;	
	case Hour:
		val = hour;
		break;
	case Minute:
		val = minute;
		break;

	case DaylightSaving:
		val = DVR_daylightsaving;
		break;
	case TimeBeginesMonth:
		val = DVR_timebeginesmonth;
		break;
	case TimeBeginesWeek:
		val = DVR_timebeginesweek;
		break;
	case TimeBeginesTime:
		val = DVR_timebeginesTime;
		break;
	case StandardTimeBeginesMonth:
		val = DVR_sandardtimebeginesMonth;
		break;			
	case StandardTimeBeginesWeek:
		val = DVR_standardtimebeginesWeek;
		break;
	case StandardTimeBeginesTime:
		val = DVR_standardtimebeginesTime;
		break;

	case TimeZone:
		val = DVR_TimeZone;
		break;

	case OverWrite:
		val = DVR_OverWrite;
		break;

	case FirstNumber:
		val = PW_FirstNumber;
		break;

	case SecondNumber:
		val = PW_SecondNumber;
		break;

	case ThridNumber:
		val = PW_ThridNumber;
		break;
	
	case FourthNumber:
		val = PW_FourthNumber;
		break;
//#endif	//#ifdef SUPPORT_SDCARD	

       case CAMNumberChoice:      		//TM0350-980227 
               val = ReadEEP(EEP_CAMNUMBER);
               break;
       case PelcoChoice:        		//TM0350-980227
               val = ReadEEP(EEP_PELCO);
               break;
    
       case Baud_rateChoice:        		//TM0350-980227
               val = ReadEEP(EEP_Baud_rate);


	}

	return val;
}

#define MAX_VIDEOMODE	4
#define MAXVCHIPMOVIE	7 

WORD SetItemValue( BYTE id, BYTE flag )
{
	WORD val=0;
//	BYTE	i;

	Printf("\r\nSET Item Value: id-%X", (WORD)id);
	switch( id ) {
	//case SYSTEM_CLOCK_H:	
	//case WAKEUP_TIME_H:		
	//case OFF_TIME_H:
	//						val = SetClock_hour(flag);				break;

	//case SYSTEM_CLOCK:
	//case WAKEUP_TIME:
	//case OFF_TIME:
	//						val = SetClock_min(flag);				break;
	//case SLEEP_TIMER:		val = ChangeSleepTimer( flag );			break;

#ifdef SUPPORT_OSDPOSITIONMOVE
	case OSDPOSITIONMODE:    val = SetOSDPositionMode( flag );		break;
	//case OSD_VPOS:			val = SetOSDMenuYValue(flag);			break;
	//case OSD_HPOS:			val = SetOSDMenuXValue(flag);			break;
#endif

//	case OSD_DURATION:		val = SetOSDDurationValue(flag);		break;
	case OSDLANG:			val = SetLanguage (flag);				break;

	#if defined(SUPPORT_PC) || defined(SUPPORT_DTV)
	case PANEL_CONTRAST:	val = SetPanelContrast(flag);			break;
	case PANEL_BRIGHTNESS:	val = SetPanelBrightness(flag);			break;
	#endif

	#ifdef SUPPORT_PC
	case PC_VPOS:			val = SetVPosition(flag);				break;
	case PC_HPOS:			val = SetHPosition(flag);				break;
	case PC_CLOCK:			val = SetPCCoarseValue(flag);			break;
	case PC_PHASE:			val = SetPhaseValue(flag);				break;
	#endif

	case PC_COLOR_TEMP:		val = SetPCColorTemp(flag);			break;

	case PC_COLOR_R:		val = SetPCColor(RED, flag);			break;	
	case PC_COLOR_G:		val = SetPCColor(GREEN, flag);			break;	
	case PC_COLOR_B:		val = SetPCColor(BLUE, flag);			break;	

	case VIDEO_MODE:		val = GetVideoModeEE();
							if(flag==UP) val ++;
							else val = val + MAX_VIDEOMODE -1;
							val %= MAX_VIDEOMODE ; 
							SetVideoMode(val);		
							
							if( GetVideoModeEE() != 3 )  // if not user mode, mask the control.
								DrawAttrCnt(OSDMENU_SUBADDR+MENU_WIDTH*2, BACK_COLOR, (MENU_HEIGHT-1)*MENU_WIDTH );	
							else
								DrawAttrCnt(OSDMENU_SUBADDR+MENU_WIDTH*2, DEFAULT_COLOR, (MENU_HEIGHT-1)*MENU_WIDTH );	
																	break;

	case VIDEO_CONTRAST:	
	case VIDEO_BRIGHTNESS:	
	case VIDEO_HUE:			
							val= ChangeVideoData(id-VIDEO_CONTRAST,flag);					break;
	case VIDEO_SATURATION:	val = ChangeVideoData(id-VIDEO_CONTRAST,flag);	
							ChangeVideoData(id+1-VIDEO_CONTRAST,flag);
																	break;
							//val = SetVideoSaturation(V_SAT, flag);	break;
	case VIDEO_SHARPNESS:	val = SetVideoSharpness(flag);			break;
	case VIDEO_BACKLIGHT:
		val = ChangeVideoData(id-VIDEO_CONTRAST,flag);			break;

	case AUDIO_VOLUME:		val = ChangeVol( (flag==UP ? 1 : -1) ); break;

    #if 0
	
	case AUDIO_BALANCE:		val = ChangeBalance( (flag==UP ? 1 : -1) );	break;
	case AUDIO_BASS:		val = ChangeBass( (flag==UP ? 1 : -1) );	break;
	case AUDIO_TREBLE:		val = ChangeTreble( (flag==UP ? 1 : -1) );	break;
    #endif

	#ifdef WIDE_SCREEN
	case WIDESCREEN:			val = WideScreenMode;
								if(flag==UP) val++;
								else val = ( val+MAXWIDESCREEN -1 );	
								val %= MAXWIDESCREEN;
								Set4WideScreen( val );
								break;
	#endif	//WIDE_SCREEN
    case DayChoice:           
         val = ReadEEP(EEP_AutoMode);
          if(flag==UP)
               val = (!val ? 1 : 0);
          else 
               val = (val ? 0 : 1);     
         WriteEEP( EEP_AutoMode,val);
		 AutoDayNight=val;
		 if(val==1)
		 	AdjustAutoDayNight(0xff);
         //DaySelect( val );              //設定Auto Day & Night動作(No=0,OFF=1)
	     break;
	case CAMOSDONOFF:         
             val = ReadEEP(EEP_COSDMode);                                                     
             if(flag==UP)                                                        
               val = (!val ? 1 : 0);                                             
             else                                              
               val = (val ? 0 : 1);                                              
             WriteEEP(EEP_COSDMode,val);   
             if(val==0)                     //CAM OSD ON //william-980428
             {
                Attr_A|=0x02;
                Attr_B|=0x02;
                Attr_C|=0x02;
                Attr_R|=0x02;
				//displayhold_flag=0;
             }			 
             else                           //CAM OSD OFF 
             {
                Attr_A&=0x0d;
                Attr_B&=0x0d;
                Attr_C&=0x0d;
                Attr_R&=0x0d;
             }  
		if(TriggerFlag!=0x08)  		//william-v1.1-20100204	 
           SetNowMode();
		//CheckNowMode(SourceMode); 
	     break;

	case DVRDisplay:        
         val = ReadEEP(EEP_DVRDisplay);                                                    
         if(flag==UP)                                  
           val = (!val ? 1 : 0);                                             
         else                                                                
           val = (val ? 0 : 1);                                              
        WriteEEP(EEP_DVRDisplay,val);  
	     break; 
		 
	case GAUGEChoice:        
         val = ReadEEP(EEP_GAUGEMode);                                                    
         if(flag==UP)                                  
           val = (!val ? 1 : 0);                                             
         else                                                                
           val = (val ? 0 : 1);                                              
        WriteEEP(EEP_GAUGEMode,val);  
	     break; 
	case OsdLockChoice:        
         val = ReadEEP(EEP_ONOFFChoice);                                                    
         if(flag==UP)                                  
            val = (!val ? 1 : 0);                                             
         else                                                                
            val = (val ? 0 : 1);                                              
         WriteEEP(EEP_ONOFFChoice,val);   
	     break;	
	case PRIORITYChoice:
		val = ReadEEP(EEP_PRIORITY);												   
		if(flag==UP)								  
			val = (!val ? 1 : 0); 											
		else																
			val = (val ? 0 : 1);	
		
			Priority= val;
		if(Priority==0)
			{		
			 WriteEEP( EEP_JUMPMode,0);
			 WriteEEP(EEP_ONOFFChoice,0x01);     // OSD  lock....... off    		        
			}
		else
			{	
			WriteEEP(EEP_JUMPMode,13); 
			WriteEEP(EEP_ONOFFChoice,0x00);     // OSD  lock....... on   
			
			if(SelectModeType>CAM_R)
				{
				SelectModeType=CAM_A;
				SetNowMode();
				WriteEEP(EEP_SelectMode,SelectModeType);
				}
			}

		  WriteEEP(EEP_PRIORITY,val);																					  
		  break; 
		break;
										 //CAMA Mirror開關設定										
	case CAMAONOFF: 										   
		  val = ReadEEP(EEP_CAMAMode);													   
		  if(flag==UP)														  
			val = (!val ? 1 : 0);											  
		  else											 
			val = (val ? 0 : 1);						 
		  WriteEEP(EEP_CAMAMode,val);	
	
		  if(val==0)					 //ON			   
			Attr_A|=0x01;				 
		  else							 //OFF			  
			Attr_A&=0x0E;			

		if(TriggerFlag!=0x08)  		//william-v1.1-20100204
		  SetNowMode();
		  //CheckNowMode(SourceMode);
		  break;										 
														 
	case CAMBONOFF: 					 //CAMB Mirror開關設定				   
		  val = ReadEEP(EEP_CAMBMode);								  
		  if(flag==UP)									 
		   val = (!val ? 1 : 0);						 
		  else											 
		   val = (val ? 0 : 1); 						 
		  WriteEEP(EEP_CAMBMode,val);	
	
		  if(val==0)					//ON			  
			 Attr_B|=0x01;				 
		  else							//OFF							 
			 Attr_B&=0x0E;	
		if(TriggerFlag!=0x08)  		//william-v1.1-20100204  
		  SetNowMode();
		  //CheckNowMode(SourceMode); 			   
		  break;										 
			 
	case CAMCONOFF: 					 //CAMC Mirror開關設定		 
		   val = ReadEEP(EEP_CAMCMode); 										   
		   if(flag==UP) 									  
			 val = (!val ? 1 : 0);							  
		   else 								
			 val = (val ? 0 : 1);							  
		   WriteEEP(EEP_CAMCMode,val);	 
		   
		   if(val==0)					 //ON						   
			 Attr_C|=0x01;						  
		   else 						 //OFF							 
			 Attr_C&=0x0E;	
		if(TriggerFlag!=0x08)  		//william-v1.1-20100204  
		   SetNowMode();
		   //CheckNowMode(SourceMode);
		   break;									  
										  
	case CAMRONOFF: 					 //CAMR Mirror開關設定					   
		   val = ReadEEP(EEP_CAMRMode); 									 
		   if(flag==UP) 									  
			 val = (!val ? 1 : 0);			
		   else 
			 val = (val ? 0 : 1);		 
		   WriteEEP( EEP_CAMRMode,val);   
		 
		   if(val==0)					 //CAM OSD ON							
			 Attr_R|=0x01;			  
		   else 						 //CAM OSD OFF							
			 Attr_R&=0x0E;
		 if(TriggerFlag!=0x08)  		//william-v1.1-20100204  
		   SetNowMode();
		   //CheckNowMode(SourceMode);			 
		   break;


	case IMAGEChoice:
        val = ReadEEP(EEP_IMAGEMode);
        if(flag==UP)
          {
           if(val<3) val+=1;
             else val=0;
          }            
          else 
          {
             if(val>0) val-=1;
             else val=3;
          }                                                     
          WriteEEP(EEP_IMAGEMode,val);   
	    break;
		
	  case IMAGE_A_Choice: 				   //左右轉顯示畫面設定(0=SINGLE , 1=DUAL , 2=TRIPLE)
			val = ReadEEP(EEP_IMAGE_A_Mode);  //andy A1.4 20100113
			if(flag==UP)
			{
			   if(val<6) val+=1;
			   else val=0;
			}			 
			else 
			{
			   if(val>0) val-=1;
			   else val=6;
			}													  
			WriteEEP(EEP_IMAGE_A_Mode,val);   
			break;
       
       case IMAGE_B_Choice:                    //左右轉顯示畫面設定(0=SINGLE , 1=DUAL , 2=TRIPLE)
             val = ReadEEP(EEP_IMAGE_B_Mode);//andy A1.4 20100113
             if(flag==UP)
             {
                if(val<6) val+=1;
                else val=0;
             }            
             else 
             {
                if(val>0) val-=1;
                else val=6;
             }                                                     
             WriteEEP(EEP_IMAGE_B_Mode,val);   
             break;
			
	case IMAGE_C_Choice:					 //左右轉顯示畫面設定(0=SINGLE , 1=DUAL , 2=TRIPLE)
		  val = ReadEEP(EEP_IMAGE_C_Mode);//andy A1.4 20100113
		  if(flag==UP)
		  {
			 if(val<6) val+=1;
			 else val=0;
		  } 		   
		  else 
		  {
			 if(val>0) val-=1;
			 else val=6;
		  } 													
		  WriteEEP(EEP_IMAGE_C_Mode,val);	 
		break;
		
	case REARChoice:
         val = ReadEEP(EEP_RearMode);
         if(flag==UP)
           {
                if(val<4) val+=1;
                else val=0;
           }            
           else 
           {
                if(val>0) val-=1;
                else val=4;
           }   
	    WriteEEP(EEP_RearMode,val);  
	    break;   	
	case TriggerVGA: 					 //CAMR Mirror開關設定					   
		   val = ReadEEP(EEP_TriggerVGA); 									 
		   if(flag==UP) 									  
			 val = (!val ? 1 : 0);			
		   else 
			 val = (val ? 0 : 1);		 
		   WriteEEP(EEP_TriggerVGA,val);   
		 			 
		   break;
		
	case JUMPChoice:
		val=ReadEEP(EEP_JUMPMode);
		if(flag==UP)
		{
		   if(val<14) val+=1;
		   else val=0;
		}			
		else 
		{
		   if(val>0) val-=1;
		   else val=14;  
		}	
		
		WriteEEP( EEP_JUMPMode,val);  
		if(val==SEQ && NowModeState==JumpMode)
		{
			SEQIndex=0;
			SEQMode();
			SEQFlag=1;
			SEQTime=0;
		}

		break;
	case CAMOUTChoice:
        val = ReadEEP(EEP_CAMOutMode);  
		CAMOutDSel( val );             //設定CAMOut動作  	    
        if(flag==UP)
          {
           if(val<4) val+=1;
             else val=0;
          }           
          else 
          {
           if(val>0) val-=1;
             else val=4;
          }                                                    
          WriteEEP(EEP_CAMOutMode,val);      
          CAMOutDSel( val );             //設定CAMOut動作   
	    break;
	case STIME_STEP:
        val=ReadEEP(EEP_TimeStep);
        if(flag==UP)
          {
                   if(val<100) val+=1;
          }           
          else 
          {
                 if(val>2) val-=1;
          }          
          WriteEEP(EEP_TimeStep,val); 
		  TimeStep=val;  
	    break;

	case Resolution:
        val=DVR_Resolution;
        if(flag==UP)									  
		  {
		   if(val<2) val+=1;
			 else val=1;
		  } 		  
		  else 
		  {
		   if(val>1) val-=1;
			 else val=2;
		  }  	 
		 DVR_Resolution=val; 
		 DVR_DataChange=1;
	    break;
		
	case FPS:
		val = DVR_FPS;			
		if(flag==UP)
		  {
		   if(val<6) val+=1;
			 else val=1;
		  } 		  
		  else 
		  {
		   if(val>1) val-=1;
			 else val=6;
		  } 												   
		  DVR_FPS=val; 	  
		  DVR_DataChange=1;
	  break;
	  
   case Quality:
 	  	val = DVR_Quality;			
 		if(flag==UP)
 		  {
 		   if(val<5) val+=1;
 			 else val=1;
 		  } 		  
 		  else 
 		  {
 		   if(val>1) val-=1;
 			 else val=5;
 		  } 												   
 		  DVR_Quality=val;
		  DVR_DataChange=1;
 	  break;
	  
  case RecordMode:
	  val =DVR_RecordMode;		  
	  if(flag==UP)
		{
		 if(val<3) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=3;
		}													 
		DVR_RecordMode=val;
		DVR_DataChange=1;
	  break;
	  
  case RecordLength:
	  val = DVR_RecordLength;		  
	  if(flag==UP)
		{
		 if(val<6) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=6;
		}													 
		DVR_RecordLength=val;
		DVR_DataChange=1;
	  break;
	  
  case PreAlarmLength:
	  val = DVR_PreAlarmLength;		  
	  if(flag==UP)
		{
		 if(val<5) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=5;
		}													 
		DVR_PreAlarmLength=val;
		DVR_DataChange=1;
	  break;
	  
  case PostAlarmLength:
	  val = DVR_PostAlarmLength;		  
	  if(flag==UP)
		{
		 if(val<8) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=8;
		}													 
		DVR_PostAlarmLength=val;
		DVR_DataChange=1;
	  break;

  case AudioRecord:
	  val = DVR_AudioRecord;		  
	  if(flag==UP)
		{
		 if(val<3) val+=1;
		   else val=0;
		}			
		else 
		{
		 if(val>0) val-=1;
		   else val=3;
		}	
		
	DVR_AudioRecord=val;
	DVRAodioSel(DVR_AudioRecord);
	WriteEEP(EEP_AudioRecord,val); 	
	
	  break;


	  
  case Year:
	  val =year2;		  
	  if(flag==UP)
		{
		 if(val<99) val+=1;
		   else val=0;
		}			
		else 
		{
		 if(val>0) val-=1;
		   else val=99;
		}	
		year2=val;
		DVR_DataChange=1;
	  break;
	  
  case Month:
	  val =month;		  
	  if(flag==UP)
		{
		 if(val<12) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=12;
		}	
		month=val;
		DVR_DataChange=1;
	  break;
	  
  case Day:
	  val =day;		  
	  if(flag==UP)
		{
		 if(val<31) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=31;
		}	
		day=val;
		DVR_DataChange=1;
	  break; 
	  
  case Hour:
	  val =hour;		  
	  if(flag==UP)
		{
		 if(val<23) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=23;
		}	
		hour=val;
		DVR_DataChange=1;
	  break;
	  
  case Minute:
	  val = minute;
	  if(flag==UP)
		{
		 if(val<59) val+=1;
		   else val=0;
		}			
		else 
		{
		 if(val>0) val-=1;
		   else val=59;
		}	
		minute=val;
		DVR_DataChange=1;
	  break;
	  
  case TimeZone:
	  val = DVR_TimeZone;
	  if(flag==UP)
		{
		 if(val<25) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=25;
		}	
		DVR_TimeZone=val;
		DVR_DataChange=1;
	  break;
  
  case DaylightSaving:
	  val = DVR_daylightsaving; 									  
        if(flag==UP)									  
		  {
		   if(val<2) val+=1;
			 else val=1;
		  } 		  
		  else 
		  {
		   if(val>1) val-=1;
			 else val=2;
		  }  
	 DVR_daylightsaving = val; 
	 DVR_DataChange=1;
	  break;
	  
  case TimeBeginesMonth:
	  val = DVR_timebeginesmonth;
	  if(flag==UP)
		{
		 if(val<12) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=12;
		}
	  DVR_timebeginesmonth=val;
	  DVR_DataChange=1;
	  break;
	  
  case TimeBeginesWeek:
	  val = DVR_timebeginesweek;
	  if(flag==UP)
		{
		 if(val<4) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=4;
		}
	  DVR_timebeginesweek = val;
	  DVR_DataChange=1;
	  break;
  case TimeBeginesTime:
	  val = DVR_timebeginesTime;
	  if(flag==UP)
		{
		 if(val<23) val+=1;
		   else val=0;
		}			
		else 
		{
		 if(val>0) val-=1;
		   else val=23;
		}
	  DVR_timebeginesTime = val;
	  DVR_DataChange=1;
	  break;
  case StandardTimeBeginesMonth:
	  val = DVR_sandardtimebeginesMonth;
	  if(flag==UP)
		{
		 if(val<12) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=12;
		}
	  DVR_sandardtimebeginesMonth=val;	
	  DVR_DataChange=1;
	  break;		  
  case StandardTimeBeginesWeek:
	  val = DVR_standardtimebeginesWeek;
	  if(flag==UP)
		{
		 if(val<4) val+=1;
		   else val=1;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=4;
		}
	  DVR_standardtimebeginesWeek = val;
	  DVR_DataChange=1;
	  break;
  case StandardTimeBeginesTime:
	  val = DVR_standardtimebeginesTime;
	  if(flag==UP)
		{
		 if(val<23) val+=1;
		   else val=0;
		}			
		else 
		{
		 if(val>1) val-=1;
		   else val=23;
		}
	  DVR_standardtimebeginesTime = val;
	  DVR_DataChange=1;
	  break;
	  
	  case FirstNumber:
		  val = PW_FirstNumber;
		  if(flag==UP)
			{
			 if(val<9) val+=1;
			   else val=0;
			}			
			else 
			{
			 if(val>0) val-=1;
			   else val=9;
			}
		  PW_FirstNumber = val;
		  break;

	case SecondNumber:
		val = PW_SecondNumber;
		if(flag==UP)
		  {
		   if(val<9) val+=1;
			 else val=0;
		  } 		  
		  else 
		  {
		   if(val>0) val-=1;
			 else val=9;
		  }
		PW_SecondNumber = val;
		break;

	case ThridNumber:
	  val = PW_ThridNumber;
	  if(flag==UP)
		{
		 if(val<9) val+=1;
		   else val=0;
		}			
		else 
		{
		 if(val>0) val-=1;
		   else val=9;
		}
	  PW_ThridNumber = val;
	  break;
	  
  case FourthNumber:
	  val = PW_FourthNumber;
	  if(flag==UP)
		{
		 if(val<9) val+=1;
		   else val=0;
		}			
		else 
		{
		 if(val>0) val-=1;
		   else val=9;
		}
	  PW_FourthNumber = val;
	  break;

    case CAMNumberChoice:                    //TM0350-980227          
              val=ReadEEP(EEP_CAMNUMBER);
              if(flag==UP)
              {
                 if(val<255) val+=1;  
                 else val=0;
              }           
              else 
              {
                 if(val>0) val-=1;
                 else val=255;
              }    
			  CAMNumber=val;
              WriteEEP(EEP_CAMNUMBER,val);      
              break;  
	
       case PelcoChoice:                   		//TM0350-980227              
             val = ReadEEP(EEP_PELCO);                                                     
             if(flag==UP)                                                        
               val = (!val ? 1 : 0);                                             
             else                                              
               val = (val ? 0 : 1);
			 PelcoChoiceFLAG=val;
             WriteEEP(EEP_PELCO,val);  		 
             break;  	

       case Baud_rateChoice:                    //TM0350-980227          
              val=ReadEEP(EEP_Baud_rate);
              if(flag==UP)
              {
                 if(val<2) val+=1;  
                 else val=0;
              }           
              else 
              {
                 if(val>0) val-=1;
                 else val=2;
              }    
			  Baud_rate=val;
              WriteEEP(EEP_Baud_rate,val);      
              break; 

  case OverWrite:
	  val = DVR_OverWrite; 									  
        if(flag==UP)									  
		  {
		   if(val<2) val+=1;
			 else val=1;
		  } 		  
		  else 
		  {
		   if(val>1) val-=1;
			 else val=2;
		  }  
	 DVR_OverWrite = val; 
	 DVR_DataChange=1;
	  break;	

		
	}

	return val;
}


void DisplayViewBar(WORD addr, BYTE val)
{
	CODE BYTE BAR_ROM_TABLE[] = {
		0x01,0x01,0x01,0x01, // ...
		0x02,0x02,0x02,0x02,0x02, // |..
		0x05,0x05,0x05,0x05,0x05,// ||.
		0x03, // |
		0x04, // |||
	};

	BYTE i=0;
	BYTE Bar_str[]={ 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, ' ', ' ', ' ',0 };

	// Bar
	if( BAR_LENGTH != 0 ) {
		if(val < 98)
		{
			Bar_str[val/14] = BAR_ROM_TABLE[val%14];
			for(i = val/14 + 1; i < 7; i++)
				Bar_str[i] = BAR_ROM_TABLE[0];
		}

		if( Bar_str[0] == 0x01 ) Bar_str[0] = 0x02;	// |..
	}

	// Number
    Bar_str[i+2] = val % 10 + '0';    val /= 10;
    Bar_str[i+1] =  val % 10 + '0';    val /= 10;
    Bar_str[i] = val + '0';
	if( Bar_str[i] == '0' ) Bar_str[i] = ' ';

	for(;i<7;i++)
		Bar_str[i+3] = ' ';

	WriteStringToAddr(addr, Bar_str, BARNUM_LENGTH); 

}

void DrawNum(WORD addr,CODE_P struct NumType *nptr, WORD val)
{
	BYTE x,i, j,k, len, mstr[5];//,color;
	BYTE Num_str[]={ ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',0 };
	CODE_P BYTE *str;
	
	x=  MAX_DESC;//+ICON_CH_SZ;
	i =  nptr->PrePostCharLen >> 4 ;
	j =  nptr->PrePostCharLen & 0x0f ;
	str = nptr->PrePostChar;

	// Draw char on front of number. 
	if( i ) 
		for(k=0; k<i; k++)
			Num_str[k] = *str++;
	// Draw number.
	utoa(val,mstr,BAR_NUM_RADIX);
	len = strlen(mstr);
	str=mstr;
	for(k=0; k<len; k++)
		Num_str[k+i] = *str++;

	// Draw char on back of number
	if( j ) 
		for(k=0; k<j; k++)
			Num_str[k+i+len] = *str++;
	WriteStringToAddr(addr, Num_str, BARNUM_LENGTH); 
	
}

void DrawStringByLang( WORD addr, CODE_P struct EnumType *yptr, WORD val )
{

	BYTE j,l,Size_val;
	BYTE Buf[]={' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',0 };
	CODE_P BYTE *Str;

	Size_val = yptr->Sz;
	Str = yptr->Str;

	if ( yptr->ByLang)
	{
		for(j=0; j<OSDLang*Size_val; j++)			
		Str += ( strlen(Str) + 1 );
	}

	if( val ){ 
		for(j=0; j<val; j++)			
		Str += ( strlen(Str) + 1 );	
	}

	WriteStringToAddr(addr, Buf, BARNUM_LENGTH); 

	l = CStrlen(Str);

	WriteStringToAddr(addr, Str, l); 

}
/*
#ifdef PAL_TV
void DrawFraction( CODE_P struct NumType *nptr, DWORD val, BYTE fp )
{
	BYTE mstr[6], len;

	ltoa_K( val, mstr, fp );
	len = strlen(mstr);
	CopyStrToOSDWindow(cur_osdwin, 0, 0, len, nptr->NumColor, mstr);
	ClearOSDLine(cur_osdwin, len, 0, nptr->width-len, nptr->NumColor);
}
#endif

BYTE OnChangingValue(void)
{
	return ( (val_osdwin==0xff  ) ? 0 : 1 );	//OSDItemValue==0xffff: password error
}
// Not used yet *******************************************
BYTE OnChangingTime(void)
{
	if ( val_osdwin==0xff )						return 0 ;
	if ( MenuChild[cursor_item].Type==TIME )	return 1;
	else										return 0;

}
*/

void DrawMenulist(BYTE NOTViewflag)
{
	BYTE  i,j,k, x=0, y=0;
	CODE_P struct DefineMenu *DMp;
	CODE_P BYTE *Desc;
	BYTE  Max_y;
	WORD addr;


	// Draw Title line
	if( MenuFormat->TitleColor!=NIL ) {

		#ifdef DEBUG_OSD
		dPrintf("\r\nTitle color:0x%x", (WORD)MenuFormat->TitleColor);
		#endif
 
		DMp = &MenuTitle[title_item];
		Desc = DMp->Desc[OSDLang];
		j=strlen(Desc);

		for( i=0,k=0; i<j; i++ )
			if( *(Desc+i) == ROMFONT || *(Desc+i) == RAMFONT ) k++;

		//ClearDataCnt(OSDMENU_SUBADDR, MenuFormat->width);	// Clear the counter of OSD RAM Data from addr with space(' ').
		DrawAttrCnt(OSDMENU_SUBADDR, MenuFormat->TitleColor, MenuFormat->width );	 
		WriteStringToAddr(OSDMENU_SUBADDR, Desc, j);

		if( (j-k ) < TITLE_MAX_DESC ) 
			ClearDataCnt(OSDMENU_SUBADDR+j-k, TITLE_MAX_DESC-j+k);

		y++;
	}
	
	if( MenuChild )	i = 0;
	else			i = NIL;

	// Draw 
	 Max_y = (cur_osdwin == OSDMENU_TOPWIN ? TOTAL_TOP_HEIGHT: MENU_HEIGHT+1);
	 addr = (cur_osdwin == OSDMENU_TOPWIN ? OSDMENU_MAINADDR: OSDMENU_SUBADDR);
	 addr += y*MenuFormat->width;

	 if( NOTViewflag==0 ) {
		 I2CAutoIncFlagOn = 1;	// speedy submenu drawing 
		 WriteDecoder(TW88_ENABLERAM, 0x04); // OSD RAM Auto Access Enable
	 }

	 for(  ; y < Max_y; y++)	{

		if(i != NIL) {
			DisplayOSDMenuOneItem( cur_osdwin, &MenuChild[i], x, y, NOTViewflag);
			i = GetLowerMenuItem( MenuChild, i );
		}
		else {
		ClearDataCnt(addr, MenuFormat->width);	// Clear the counter of OSD RAM Data from addr with space(' ').
		}
		addr += MenuFormat->width;

	 }

 	 if( NOTViewflag==0 ) {
		 I2CAutoIncFlagOn = 0;	// Recover  
		 WriteDecoder(TW88_ENABLERAM, 0x00); // OSD RAM Auto Access Enable
	 }

}
//
// Here, Main Menu will display Only Icon at leftside.
//
#define ALLDATA  175 //25*7  MENU_WIDTH*MENU_HEIGT
void DisplayOSDMenu(void)
{
	//CODE_P BYTE *Str;
	#ifdef DEBUG_OSD
	dPrintf("\r\n++(DisplayOSDMenu)");
	#endif


	// Clear all MENU Window Ram data
	DrawAttrCnt(OSDMENU_MAINADDR, DEFAULT_COLOR, 5*2 );	 // All Line Attr clear by default color.
	DrawAttrCnt(OSDMENU_SUBADDR, TITLE_COLOR, TITLE_MAX_DESC );	 // All Line Attr clear by default color.
	if( MenuChild[ cursor_item ].Id == TVINSTALL && GetInputSelection()!= TV )
		DrawAttrCnt(OSDMENU_SUBADDR+TITLE_MAX_DESC, CH_COLOR_MAGENTA|BACK_COLOR, MENU_HEIGHT*MENU_WIDTH );	
	else
	{
		if( (MenuChild[ cursor_item ].Id == PC_COLOR_MODE && GetPCColorTempModeEE() != 3 )  // User
		||( MenuChild[ cursor_item ].Id == VIDEOPICTURE && GetVideoModeEE() != 3 ) ) // User
		{
			DrawAttrCnt(OSDMENU_SUBADDR+MENU_WIDTH, DEFAULT_COLOR, MENU_WIDTH );	
			DrawAttrCnt(OSDMENU_SUBADDR+MENU_WIDTH*2, BACK_COLOR, (MENU_HEIGHT-1)*MENU_WIDTH );	
		}
		else
		DrawAttrCnt(OSDMENU_SUBADDR+TITLE_MAX_DESC, DEFAULT_COLOR, MENU_HEIGHT*MENU_WIDTH );	

	}

	DrawAttrCnt(OSDMENU_SUBADDR+TITLE_MAX_DESC*8, COMMENT_COLOR, TITLE_MAX_DESC );	 // All Line Attr clear by default color.

	DrawMenulist(1);

	// Draw Child
	if( OSDMenuLevel == 1 ) // 
	{
		pushMenu();	// Store ManuTile, tile_item.
		MenuTitle = MenuChild;
		title_item = cursor_item;
		
		MenuFormat = ( CODE_P struct MenuType *) MenuTitle[title_item].TypeData;
		MenuChild = MenuTitle[title_item].Child;
		cur_osdwin--; 

		DrawMenulist(0);	// draw total Submemu.
		
		popMenu(); // Restore ManuTile, tile_item.
		MenuFormat = ( CODE_P struct MenuType *) MenuTitle[title_item].TypeData;
		MenuChild = MenuTitle[title_item].Child;
		cur_osdwin++;
	}
#if 0			//william-AWT-ML082Q-v1.2-20100315
	Str = Str_Comments[OSDLang];
	i=strlen(Str);
	WriteStringToAddr(OSDMENU_SUBADDR+TITLE_MAX_DESC*8, Str, i);
#endif
	DisplayCursor();
}

void OSDHighMenu_sub(void)
{
	BYTE temp_cursor;

	#ifdef DEBUG_OSD
	dPuts("\r\n(OSDHighMenu_sub)");
	#endif
	temp_cursor = cursor_item ;
	MenuChild = MenuTitle;
	cursor_item = title_item;

	if( !popMenu() ) {
		CloseOSDMenu();

		MenuTitle = MenuChild;	//  Restore the Menu status.
		title_item = cursor_item;
		MenuChild = MenuTitle[title_item].Child;
		cursor_item = temp_cursor;
	
		//DoAction(EXITMENU);
		#if 0		//william-981029
		if( DisplayInputHold ) DisplayInput();
		else if( IsAudioMuteOn() ) DisplayMuteInfo();
		return;
		#endif
	}

	#ifdef DEBUG_OSD
	dPrintf("\r\n++(OSDHighMenu_sub) OSDMenuLevel:%d", (WORD)OSDMenuLevel );
	#endif
	
	MenuFormat = ( CODE_P struct MenuType *) MenuTitle[title_item].TypeData;

	OSDMenuLevel--; // Up Menu tree

	if(OSDMenuLevel == 1){	// Top Menu Level
		cur_osdwin = OSDMENU_TOPWIN;//Window #4
		DisplayOSDMenu();
	}
	else
	{
		DrawMenulist(0); // Redraw List and contents.
		DisplayCursor();
	}
	
	// 3D Effect Cursor Top
	if(OSDMenuLevel == 1) {
		WriteDecoder(TW88_WINNUM, OSDCURSORWINDOW-1);
		WriteDecoder(TW88_WINATTR, OSD_Window_Attr(WINDOW_3D_TOP,BG_COLOR_BLACK|EXTENDED_COLOR,0,WINDOW_3D_ENABLE,WINDOW_ENABLE));	
	}

	return;
}


BYTE DoAction(BYTE id)
{
	BYTE ret = 1;

	#ifdef DEBUG_OSD
	dPrintf("\r\n++(DoAction) id:0x%x", (WORD)id );
	#endif
	switch( id ) {

	case CHANGE_TO_COMPOSITE:
	case CHANGE_TO_SVIDEO:
	case CHANGE_TO_COMPONENT:

	#ifdef SUPPORT_PC
	case CHANGE_TO_PC:
	case CHANGE_TO_DIGITALVGA:
	#endif

	#ifdef SUPPORT_DTV
	case CHANGE_TO_DTV:
	#endif

								ChangeInput( id & 0x0f );			
								break;
							
	#ifdef SUPPORT_PC
	case AUTOADJUST:			
								AutoAdjust();
								/*ClearOSDInfo();
								DisplayAutoAdjust();
								ret = DetectAndSetForVGAInput(0);	
								ClearAutoAdjust();
								LCDPowerON(0);	//HHY 1.63*/
								break;
	/*case AUTOADJUST2:			ret = DetectAndSetForVGAInput(2);
								LCDPowerON(0);	//HHY 1.63
								SetOSDLastKeyInTime();
								ClearCursor();
								cursor_item = 0;
								DisplayCursor();		
								break;*/
	case RESET_PCVALUE:			ClearOSDInfo();
								ResetPanelAttributeValue();
								//ResetPCValue();		william-v1.1-20100204
								ResetOSDValue();
								//ResetAudioValue();
								SetNowMode();
								Hs_DvrTxCmdPaser(SetDVRDefault);
								DisplayInput();
								break;

	case PCCOLORADJUST:			
								AutoColorAdjust();
								break;
	#endif
	
	
	case RESET_VIDEOVALUE:		ClearOSDInfo();
								ResetPanelAttributeValue();
								ResetVideoValue();
								ResetOSDValue();
								//ResetAudioValue();
								SetNowMode();
								Hs_DvrTxCmdPaser(SetDVRDefault);
								DisplayInput();
								break;
#ifdef E_Wintek
	case RESET_USERVALUE:		ClearOSDInfo();
								ResetPanelAttributeValue();
								ResetVideoValue();
								ResetUESROSDValue();
								SetNowMode();
								DisplayInput();
								break;
#endif
//----
	case TOHIGHMENU:			OSDHighMenu_sub();						
								break;

	case DVRParamApply:			if(DVR_DataChange==1)
								{
									Hs_DvrTxCmdPaser(SetDVRParam);
									DVR_DataChange=0;
								}	
								OSDHighMenu_sub();	
								break;							

	case DATETIMEApply:			if(DVR_DataChange==1)
								{
									Hs_DvrTxCmdPaser(SetDATETIME);
									DVR_DataChange=0;
								}
								OSDHighMenu_sub();								
								break;		

	case DISP_INFO:				
								DisplayInfo_OSD();	
								displayOnValueWindow = 1;
								break;
	case EXITMENU:				CloseOSDMenu();	
								DisplayInput();
								PW_FirstNumber=0;
								PW_SecondNumber=0;
								PW_ThridNumber=0;
								PW_FourthNumber=0;
								#if 0	//william-981029
								if( DisplayInputHold ) DisplayInput();
								else if( IsAudioMuteOn() ) DisplayMuteInfo();
								#endif
								break;
    //==========================>>>>HS andy AWT 9801001

 //#ifdef SUPPORT_SDCARD
	case ManualRecordStart:
							if(DVR_Ready==0)
								{
								DisplayDVRnotReady();
								Wait_ms(3000);
				  				ClearGAUGEINFO();
								DisplayInput();
								}
							else
								{
								//Hs_DvrTxCmdPaser(GetDATETIME);
								Hs_DvrTxCmdPaser(MANUALRECSTART);
								CloseOSDMenu();	
								DisplayInput();
								}
								break;
	case ManualRecordStop:
							if(DVR_Ready==0)
								{
								DisplayDVRnotReady();
								Wait_ms(3000);
				  				ClearGAUGEINFO();
								DisplayInput();
								}
							else
								{
								Hs_DvrTxCmdPaser(MANUALRECSTOP);
								CloseOSDMenu();	
								DisplayInput();
								}
								break;
	case Snapshot:
							if(DVR_Ready==0)
								{
								DisplayDVRnotReady();
								Wait_ms(3000);
				  				ClearGAUGEINFO();
								DisplayInput();
								}
							else
								{
								Hs_DvrTxCmdPaser(SNAPSHOT);
								CloseOSDMenu();	
								DisplayInput();
								}
								break;							

   	case FormatSD:				
						if(DVR_SDCardAvailable!=0xff)
							{
								#if 0
								Printf("\r\nPW_FirstNumber=%02x",(WORD)PW_FirstNumber);
								Printf("\r\nPW_SecondNumber=%02x",(WORD)PW_SecondNumber);
								Printf("\r\nPW_ThridNumber=%02x",(WORD)PW_ThridNumber);
								Printf("\r\nPW_FourthNumber=%02x",(WORD)PW_FourthNumber);

								Printf("\r\nReadEEP(EEP_FirstNumber)=%02x",(WORD)ReadEEP(EEP_FirstNumber));
								Printf("\r\nReadEEP(EEP_FirstNumber)=%02x",(WORD)ReadEEP(EEP_SecondNumber));
								Printf("\r\nReadEEP(EEP_ThridNumber)=%02x",(WORD)ReadEEP(EEP_ThridNumber));
								Printf("\r\nReadEEP(EEP_FourthNumber)=%02x",(WORD)ReadEEP(EEP_FourthNumber));

								
								if((ReadEEP(EEP_FirstNumber)==PW_FirstNumber
									&&ReadEEP(EEP_SecondNumber)==PW_SecondNumber
									&&ReadEEP(EEP_ThridNumber)==PW_ThridNumber
									&&ReadEEP(EEP_FourthNumber)==PW_FourthNumber))
									{
									Printf("\r\n PASSWORD OK",0);
									}
								else		
									break;
								#endif
								
								Hs_DvrTxCmdPaser(SetFormatSD);
								CloseOSDMenu();	
								

								DisplayFormatOSD();
								
								while(FormatWait<=120)
									{
									if(RS2_in!=0)
										DvrReceivePaser();	
									RS2_in=0;
									
									if(FormatStatus==1)	
										{
										DisplayFormatOkOSD();
										Wait_ms(3000);
				  						ClearGAUGEINFO();
										break;
										}			
									}
								
								if(FormatStatus==0)
									{
									DisplayFormatFailOSD();
									Wait_ms(3000);
									ClearGAUGEINFO();
									}
								FormatStart=0;
								FormatWait=0;
								FormatStatus=0;
								DisplayInput();
							}	
								break;	

	case FirmwareUpdate:		
						if(DVR_SDCardAvailable!=0xff)
							{
								Hs_DvrTxCmdPaser(FW_Update_Start);
								CloseOSDMenu(); 
								
	
								DisplayFWUpDate();
								
								while(FormatWait<=120)
									{
									if(RS2_in!=0)
										DvrReceivePaser();	
									RS2_in=0;
									
									if(FormatStatus==1) 
										{
										DisplayFWUpDateOK();
										Wait_ms(3000);
										ClearGAUGEINFO();
										break;
										}			
									}
								
								if(FormatStatus==0)
									{
									DisplayFWUpDateFail();
									Wait_ms(3000);
									ClearGAUGEINFO();
									}
								FormatStart=0;
								FormatWait=0;
								FormatStatus=0;
								DisplayInput();
							}	
								break;	

	case ChangePassword:		
								#if 0
								Printf("\r\nPW_FirstNumber=%02x",(WORD)PW_FirstNumber);
								Printf("\r\nPW_SecondNumber=%02x",(WORD)PW_SecondNumber);
								Printf("\r\nPW_ThridNumber=%02x",(WORD)PW_ThridNumber);
								Printf("\r\nPW_FourthNumber=%02x",(WORD)PW_FourthNumber);
								Printf("\r\nReadEEP(EEP_FirstNumber)=%02x",(WORD)ReadEEP(EEP_FirstNumber));
								Printf("\r\nReadEEP(EEP_FirstNumber)=%02x",(WORD)ReadEEP(EEP_SecondNumber));
								Printf("\r\nReadEEP(EEP_ThridNumber)=%02x",(WORD)ReadEEP(EEP_ThridNumber));
								Printf("\r\nReadEEP(EEP_FourthNumber)=%02x",(WORD)ReadEEP(EEP_FourthNumber));



								if(  PW_FirstNumber!= 0) break;
								if(  PW_SecondNumber!= 6) break;
								if(  PW_ThridNumber!= 3)break;
								if(  PW_FourthNumber!= 0)break;

								if((ReadEEP(EEP_FirstNumber)==PW_FirstNumber
								&&ReadEEP(EEP_SecondNumber)==PW_SecondNumber
								&&ReadEEP(EEP_ThridNumber)==PW_ThridNumber
								&&ReadEEP(EEP_FourthNumber)==PW_FourthNumber)
								||(PW_FirstNumber==0
								&&PW_SecondNumber==6
								&&PW_ThridNumber==3
								&&PW_FourthNumber==0))
								{
								Printf("\r\n PASSWORD OK",0);
								}
								else	
									break;
								#endif

								WriteEEP(EEP_FirstNumber,PW_FirstNumber);
								WriteEEP(EEP_SecondNumber,PW_SecondNumber);
								WriteEEP(EEP_ThridNumber,PW_ThridNumber);
								WriteEEP(EEP_FourthNumber,PW_FourthNumber);
								PW_FirstNumber=0;
								PW_SecondNumber=0;
								PW_ThridNumber=0;
								PW_FourthNumber=0;
								
								OSDHighMenu_sub();	

								break;
								
		

	case CameraOSD:
								CloseOSDMenu();
								SpeedDomeMode=1;
								RS232Select=1;
								Wait_ms(200);
								CAM_TxCommand_toRS485(CAM_MENU_ENTER);
								DisplayInput();

								break;
//#endif		//#ifdef SUPPORT_SDCARD								
	}
	return ret;
}


BYTE GetNextCursorMenuItem( CODE_P struct DefineMenu *DMp, BYTE itemno, BYTE flag)
{
	BYTE new_cursor;

	switch( flag ) {
	case UP:	new_cursor = GetUpperMenuItem( /*DMp,*/ itemno );		break;
	case DN:	new_cursor = GetLowerMenuItem( DMp, itemno );		break;
	}
	return new_cursor;
}

//============== Public functions =================================================
//CODE BYTE TryAgainMsg[]={ "Try again."};

BYTE SaveValue1(void)
{
//	BYTE          /*ret=0,*/ addroff;

	switch( MenuChild[cursor_item].Type )	{
	
	case NUMBER:
	       	switch ( MenuChild[cursor_item].Id ) {

			//case SLEEP_TIMER:		SetSleepTimer( OSDItemValue );	
			//						return 1;	//break;
			}
			//ret = 1;
			break;
	
	default:	break;
	}

	return 0;	
}

void ClearValueWin(void)
{
	SaveValue1();
	//ShowOSDWindow(OSDBARWINDOW, FALSE);
	val_osdwin = 0xff;
	OnChangingValue = 0;
}

void OSDCursorMove(BYTE flag )
{
	BYTE new_cursor, old_cursor;
	WORD dat;

	#ifdef DEBUG_OSD
	dPrintf("\r\n++(OSDCursorMove)cursor_item:%d __", (WORD)cursor_item);
	#endif

		if(displayOnValueWindow == 1) 
			return; 
		if( MenuChild[ cursor_item ].Id == PC_COLOR_TEMP && 
			GetPCColorTempModeEE() != 3 ) 
			return; // User
		if( MenuChild[ cursor_item ].Id == VIDEO_MODE && GetVideoModeEE() != 3 ) return; // User

		new_cursor = GetNextCursorMenuItem( MenuChild, cursor_item, flag );	// Get item to move
		
		if( new_cursor ==NIL ) {		
			BYTE i;
			if( flag == UP )
				for(i=0; i<8; ){
					new_cursor=i;
					if( (i=GetLowerMenuItem(MenuChild, i) ) == NIL) break;
					
				}
				//new_cursor = MenuFormat->height - 1;
			else
				new_cursor = 0;
		}

		if( OnChangingValue )	{
			ClearValueWin();
		}
		if( OSDMenuLevel != 1) 
			ClearCursor();

#if 0
		Printf("\r\ntitle_item=%02x",(WORD)title_item);
		Printf("\r\ncur_osdwin=%02x",(WORD)cur_osdwin);
		Printf("\r\nOSDMenuLevel=%02x",(WORD)OSDMenuLevel);
		Printf("\r\ncursor_item=%02x",(WORD)cursor_item);
		Printf("\r\nnew_cursor=%02x",(WORD)new_cursor);
#endif
		if((ReadEEP(EEP_FirstNumber)==PW_FirstNumber
		&&ReadEEP(EEP_SecondNumber)==PW_SecondNumber
		&&ReadEEP(EEP_ThridNumber)==PW_ThridNumber
		&&ReadEEP(EEP_FourthNumber)==PW_FourthNumber)
		||(PW_FirstNumber==0
		&&PW_SecondNumber==6
		&&PW_ThridNumber==3
		&&PW_FourthNumber==0))
			{
			Printf("\r\n PASSWORD OK",0);
			}
		else
			{
			if( title_item==3 && cur_osdwin==2 && OSDMenuLevel==3 
			  && flag==UP && cursor_item==6 && new_cursor==5 )	 
			   {
			   cursor_item=6;
			   new_cursor=3;			  					//william-v1.43-970331
				}
			
			if( title_item==3 && cur_osdwin==2 && OSDMenuLevel==3 
			  && flag==DN&& cursor_item==3 && new_cursor==4 ) //william-v1.43-970331
			   {
			   cursor_item=3;
			   new_cursor=6;
				}
			}

	#ifdef SUPPORT_SDCARD	
		//DVR NOT READY		//WILLIAM-v1.1-990921		
			if(DVR_Ready==0)
			{
				if(/* title_item==4 && */OSDMenuLevel==1 
				  && flag==UP && cursor_item==4 )	 
				   {
				   cursor_item=4;
				   new_cursor=2;			  					//william-v1.43-970331
					}
				
				if( /*title_item==2 && */OSDMenuLevel==1 
				  && flag==DN&& cursor_item==2  ) //william-v1.43-970331
				   {
				   cursor_item=2;
				   new_cursor=4;
					}
			}
	#endif	//	#ifdef SUPPORT_SDCARD		
		old_cursor = cursor_item;
		cursor_item = new_cursor;
		if(OSDMenuLevel == 1)
		{ 
			WaitEndofDisplayArea();	
			dat = GetOSDWindowY(OSDCURSORWINDOW);
			dat += (cursor_item-old_cursor)*ICON_HIGH;
			SetOSDWindowY_TW88(OSDCURSORWINDOW,dat);
			WriteDecoder(TW88_WINNUM, OSDCURSORWINDOW-1);
			WriteDecoder(TW88_WINSADDRLO, cursor_item*2);	

			DisplayOSDMenu();

		}
		else 	{
	
		if( MenuChild[ old_cursor ].Id == OSDLANG)
				DrawMenulist(0); //		Recover Attr. and menu Data list
			DisplayCursor();
		}
}

void OSDValueUpDn(BYTE flag)
{
	CODE_P BYTE *ptr;
	WORD val;
	WORD addr;
//	BYTE len1;

	addr = OSDMENU_SUBADDR;
	addr = addr + MAX_DESC + (cursor_item+1)*MenuFormat->width;

	switch ( MenuChild[cursor_item].Type ) {
	
	case BAR:	
				val = SetItemValue(MenuChild[cursor_item].Id, flag );
				DisplayViewBar( addr, val);
				break;
	
	case NUMBER:
				ptr = MenuChild[cursor_item].TypeData;
				switch ( MenuChild[cursor_item].Id ) {

				#ifdef PAL_TV	//-----------------------------------------------
				case MANUAL_TUNE_CHANNEL:
						ManualTune(flag);
						break;
				#endif					//-----------------------------------------------
				default:
						val = SetItemValue(MenuChild[cursor_item].Id, flag);
						DrawNum( addr, (CODE_P struct NumType *)ptr, val );
						break;
				}
				
				break;
	/*case TIME:
				//tptr = (CODE_P struct TimeType *)MenuChild[cursor_item].TypeData;
				//val = SetItemValue( (val_index==HOUR ? MenuChild[cursor_item].Id + 1 : MenuChild[cursor_item].Id ) , flag);
				//if( val_index == HOUR )
				//	DrawTime( val, tptr->CursorColor, tptr->TimeColor);
				//else
				//	DrawTime( val, tptr->TimeColor,   tptr->CursorColor);

				
				ptr = MenuChild[cursor_item].TypeData;
				val = SetItemValue( (val_index==HOUR ? MenuChild[cursor_item].Id + 1 : MenuChild[cursor_item].Id ) , flag);
				if( val_index == HOUR )
					DrawTime( val, 
					((CODE_P struct TimeType *)ptr)->CursorColor, 
					((CODE_P struct TimeType *)ptr)->TimeColor);
				else
					DrawTime( val, 
					((CODE_P struct TimeType *)ptr)->TimeColor,   
					((CODE_P struct TimeType *)ptr)->CursorColor);
				break;
	*/
	case ENUM_STRING:
				ptr = MenuChild[cursor_item].TypeData;
				val = SetItemValue( MenuChild[cursor_item].Id , flag);
				DrawStringByLang( addr, (CODE_P struct EnumType *)ptr, val );
				break;
	
	default:	break;
	}
}

BYTE CloseOSDMenu(void)
{
	BYTE i;
	extern BYTE PcMode;

	ShowOSDWindowAll(0);  // TW8806B

	//ClearOSD();
	WaitEndofDisplayArea();	
	for (i=OSDCURSORWINDOW; i<=OSDMENU_TITLEWIN ;i++ )
	{
		SetOSDWindowNum(i);
		WriteDecoder(TW88_WINATTR, 0x00);
	}

	ClearDisplayedOSD (MENU);
	#ifdef E_Wintek
	FactoryMenu=0;
	#endif
/*
#ifdef SUPPORT_PC
	// If PC mode is unknown, display outof range	// HHY 7/25/05
	if( GetInputSelection()==PC || GetInputSelection()==DTV ) {
		if( PcMode==EE_PC_UNKNOWN ) {
			//DisplayPCInfo(OutOfRangeStr[GetOSDLang()]);
			ShowOSDWindow(PCINFO_OSDWIN,TRUE);
			ShowOSDWindowAll(1);
			SetDisplayedOSD(PCINFO);
		}
	}
#endif //
*/
	return 1;
}
#ifdef SUPPORT_OSDPOSITIONMOVE
void InitOSDMenuXY(void)
{
	int val, addx, addy;
	BYTE winno;

	addx = OSDMenuX - OSDMenuXRange.Default;
	addy = OSDMenuY - OSDMenuYRange.Default;

	#ifdef DEBUG_OSD
	dPrintf("\r\nOSDMenuX:%d, OSDMenuY:%d", (WORD)OSDMenuX, (WORD)OSDMenuY);
	dPrintf("\r\nOSDMenuYRange.Min=%d", (WORD)OSDMenuXRange.Min);
	dPrintf("\r\nOSDMenuYRange.Max=%d", (WORD)OSDMenuXRange.Max);
	dPrintf("\r\nOSDMenuYRange.Default=%d", (WORD)OSDMenuXRange.Default);
	dPrintf("\r\nOSDMenuX - OSDMenuXRange.Default=%d", (WORD)addx);
	#endif

	for( winno=OSDCURSORWINDOW; winno<=OSDMENU_TITLEWIN; winno++) {

		val = GetOSDWindowX( winno );
		SetOSDWindowX(winno,val+addx);

		val = GetOSDWindowY( winno );
		SetOSDWindowY(winno,val+addy);
	}
}
#endif
void OpenOSDMenu(void)
{
	BYTE i;

	ClearOSDInfo();
	{ // TW8806 
		InitOSDMenu();		// reset OSD window and prepare menu
#ifdef REFERENCE
		Change_OSDColorLookup();
#endif	
	}

	for(i=OSDCURSORWINDOW; i<=OSDMENU_TOPWIN; i++) {
		ShowOSDWindow_TW88(i,TRUE);
	}


	ShowOSDWindow_TW88(DVRStatus_OSDWIN,FALSE);	
	ShowOSDWindowAll(1);
	SetDisplayedOSD( MENU );

}

void InitOSDMenu()
{
	extern CODE BYTE OSDPOSITIONMODE_TABLE[][2] ;
	BYTE i=0;

	//DownloadUDFont();			//WILLIAM-981029
	OSDLang = GetOSDLangEE();

	switch( GetInputSelection() ) {

	#ifdef SUPPORT_PC
	case PC:
#ifdef E_Wintek
		if(FactoryMenu==0)
		MenuTitle = ChinesePCMenu;
		else
	#endif		
		MenuTitle = PCMenu;			
		break;
	#endif

	//#ifdef SUPPORT_DTV
	//case DTV:	MenuTitle = DTVMenu;		break;
	//#endif 


	default:
	#ifdef E_Wintek
		if(FactoryMenu==0)
		MenuTitle = ChineseMenu;
		else
	#endif		
		MenuTitle = DefaultMenu;	
		break;
	}

	MenuSP = 0;								// Clear stack of menu.
	title_item = 0;
	MenuFormat = ( CODE_P struct MenuType *) MenuTitle[title_item].TypeData;

	OSDMenuLevel = 1; // OSD menu tree level
	cur_osdwin = OSDMENU_TOPWIN;

	MenuChild = MenuTitle[title_item].Child;
	cursor_item = 0;
	
	val_osdwin = 0xff;
	val_index = 0;
	OnChangingValue = 0;

	//--- OSD Window Initialization
	#ifdef ADD_ANALOGPANEL
	if(IsAnalogOn())
		InitOSDWindow(Init_Osd_MainMenu_A);
	else	
	#endif
	InitOSDWindow(Init_Osd_MainMenu);  // Define Window Top(4), Sub(3), Bar(2), Cursor(1) 


	//--- Positioning 
	#ifdef SUPPORT_OSDPOSITIONMOVE
	i = GetOSDPositionModeEE();

	OSDMenuX = OSDPOSITIONMODE_TABLE[i][0];
	OSDMenuY = OSDPOSITIONMODE_TABLE[i][1];

	InitOSDMenuXY();	 // Default + Saved OSD Position
	#endif

	//--- Display OSD Menu
	DisplayOSDMenu(); 
}


void OSDHighMenu(void)
{
	if( OnChangingValue )
	{
		//OnChangingValue = 0;
		ClearValueWin();
//		DisplayCursor();
		DrawMenulist(0); //		Recover Attr. and menu Data list
		DisplayCursor();

		return;
	}

	displayOnValueWindow = 0;
	DoAction(MenuChild[cursor_item].PostFnId); // When exiting from the previous menu, Use to need some of action.

	if( OSDMenuLevel != 1) ClearCursor();
	OSDHighMenu_sub();
	
}


void OSDSelect(void)
{
	BYTE ret;
	WORD addr;

	if( cursor_item==NIL )			return;
	if( MenuChild[ cursor_item ].Id == TVINSTALL && GetInputSelection()!= TV )return;

	if( MenuChild[ cursor_item ].Id == VIDEO_HUE && ReadVInputSTD()!= NTSC && ReadVInputSTD()!= NTSC4 )  		return;
	//if( MenuChild[ cursor_item ].Id == VIDEO_SHARPNESS && GetInputSelection()== SCART )  		return;

	//do  {
		ret = DoAction(MenuChild[cursor_item].PreFnId);
		if(!ret) return;

		switch ( MenuChild[ cursor_item ].Type ) {
		case ACTION:
						DoAction(MenuChild[cursor_item].Id); // Action.
						return;

		case ENUM_STRING:		
		case BAR:
						OnChangingValue = 1; // Value changable label on 				
						DisplayCursor();	//Display Setect Item cursor
						GetItemValue(MenuChild[cursor_item].Id);
						return;
						
		case NUMBER:	
						OnChangingValue = 1;

						switch ( MenuChild[cursor_item].Id ) {
						default:
								DisplayCursor();

						//		DrawNum( (CODE_P struct NumType *)ptr, GetItemValue(MenuChild[cursor_item].Id) );
								break;
						}
						return;

		case OSDMENU:
		case CHOICEMENU:
						if(OSDMenuLevel == 1) {
							addr = OSDMENU_MAINADDR + cursor_item*MenuFormat->width + 0;
							//DrawAttrCnt(addr, CURSOR_COLOR, 2);	// TOP Menu Icon Selected by color
							// 3D Effect Cursor Bottom
							WriteDecoder(TW88_WINNUM, OSDCURSORWINDOW-1);
							WriteDecoder(TW88_WINATTR, OSD_Window_Attr(WINDOW_3D_BOTTOM,BG_COLOR_BLACK|EXTENDED_COLOR,0,WINDOW_3D_ENABLE,WINDOW_ENABLE));	
						}

						OSDMenuLevel++;	// Down Menu tree.

						pushMenu();	// Push MenuTitle, title_item in stack.
						MenuTitle = MenuChild;
						title_item = cursor_item;

						MenuFormat = ( CODE_P struct MenuType *) MenuTitle[title_item].TypeData;				
						MenuChild = MenuTitle[title_item].Child;
						cursor_item = Get_cursor_item( MenuTitle[title_item].Id );

						if( cur_osdwin == OSDMENU_TOPWIN ) // Window #4
							cur_osdwin = OSDMENUWINDOW; // Window #3
						else
							DisplayOSDMenu();

						DisplayCursor();
						break;
		}
	//} while( cursor_item!=NIL && MenuChild[cursor_item].ActiveWithCursor==YES );

}
#if 0
//-------------------------------------------
//         設定Auto Day & Night動作
//-------------------------------------------
//0->ON ; 1->0FF
void DaySelect(BYTE val)
{     
   if(val)      //Auto OFF
     CDS_CTRL=0;
   else         //Auto ON
     CDS_CTRL=1;
}
#endif
//-------------------------------------------
//         設定CAM Out動作
//-------------------------------------------
//0->QUAL ; 1->CAMA ;2->CAMB ; 3->CAMC
void CAMOutDSel(BYTE  val)
{
    if(val==0)
      TW2835Cmd("\n\ryvmix 4\n\r"); 
    else if(val==1)
      TW2835Cmd("\n\ryvmix 0\n\r");
    else if(val==2)
      TW2835Cmd("\n\ryvmix 1\n\r");
    else if(val==3)
      TW2835Cmd("\n\ryvmix 2\n\r");
    else if(val==4)
      TW2835Cmd("\n\ryvmix 3\n\r");
}

//-------------------------------------------
//         設定DVR AUDIO RECORD CH動作
//-------------------------------------------
//0->A ; 2->B ;1->C ; 3->R
void DVRAodioSel(BYTE  val)
{
    if(val==0)
      TW2835Cmd("\n\raudio 0\n\r"); 
    else if(val==1)
      TW2835Cmd("\n\raudio 2\n\r");
    else if(val==2)
      TW2835Cmd("\n\raudio 1\n\r");
    else if(val==3)
      TW2835Cmd("\n\raudio 3\n\r");

}


