C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 1   


C51 COMPILER V8.16, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Output\I2c.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE I2c.c COMPACT OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include\) DEBUG OBJECTEXTEND
                    - CODE LISTINCLUDE SYMBOLS PRINT(.\Source\I2c.lst) OBJECT(.\Output\I2c.obj)

line level    source

   1          //-------------------------------------------------------------
   2          //      This is changed for sdcc compiler 2.2.0a        LJY000721
   3          //  ver0.11 2/20/2001   Support Z86129 Line 21 decoder.
   4          //-------------------------------------------------------------
   5          /*#include <io51.h>*/
   6          //#include <pk-51.h>    LJY000721
   7          
   8          #include "Config.h"
   1      =1  /*****************************************************************************/
   2      =1  /*                           System Configurations                           */
   3      =1  /*                                                      rev 0.10 include auto test                                               */
   4      =1  // 0.11 change DTV, PC input initial download data correct for Charge Pump
   5      =1  // 0.12 correct phase measurement routine '>>3'
   6      =1  // 0.13 enable function for SPI control... only EXT MCU case
   7      =1  // 0.14 corrected PC measurement......
   8      =1  // 0.0a test function only for CVBS, SVIDEO
   9      =1  // 0.15 corrected DTV scaler setting for panel resolutions
  10      =1  // 0.0b panel for AND 640x480 TICON panel
  11      =1  // 0.16 corrected COMPONENT scaler setting for panel resolutions        11/21/2007
  12      =1  // 0.0c automatic chip test
  13      =1  // 0.17 add monitor function, osd grid for writing grid
  14      =1  // 0.18 add component, dtv pc for analogpanel, 12/06/2007
  15      =1  // 0.19 correct pal input for CES, 12/20/2007
  16      =1  // 0.1a CCFL control, 12/28/2007
  17      =1  // 0.19 Multi Grid for Banking on Internal MCU  01/17/2008
  18      =1  // 0.20 CCFL contol for backlight brightness    01/21/2008
  19      =1  // 0.21 CCFL contol for backlight brightness    01/25/2008
  20      =1  // 0.22 phase setting 02/07/2008
  21      =1  // 0.221 display input correction 04/03/2008
  22      =1  // 0.23 PC, DTV mode, no signal display
  23      =1  // 0.24 PC Auto Color adjustment
  24      =1  // 0.25 revised PC Auto Clock adjustment - find divide number and phase
  25      =1  // 0.26 Digital RGB for TW8826
  26      =1  // 0.27 Correct LVDS control                                    08/22/2008
  27      =1  // 0.28 Add WSVGA resolution                                    10/23/2008
  28      =1  // 0.29 Add NEW GRID                                                    11/14/2008
  29      =1  // 0.30 Fix DTV input                                                   12/10/2008
  30      =1  // 0.31 Add 1080i23, 24, 25A, 25B                               01/20/2009
  31      =1  // 0.32 TCON setting FIX all mode                               01/22/2009
  32      =1  // 0.33 autodetect is auto on/off by dip sw1    02/02/2009
  33      =1  // 0.34 Fix autocolor function and clamp position 02/08/2009
  34      =1  /*****************************************************************************/
  35      =1  #ifndef __CONFIG_H__
  36      =1  #define __CONFIG_H__
  37      =1  
  38      =1  //#define INTERNAL_MCU -- defined by Project Compiler session
  39      =1  
  40      =1  
  41      =1  //-----------------------------------------------------------------------------
  42      =1  //              Firmware Version
  43      =1  //-----------------------------------------------------------------------------
  44      =1  #define FWVER                   0x140                   // Rev 0.14
  45      =1  //-----------------------------------------------------------------------------
  46      =1  //              Compiler
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 2   

  47      =1  //-----------------------------------------------------------------------------
  48      =1  #define KEILC                                           // Keil C 5.0
  49      =1  //-----------------------------------------------------------------------------
  50      =1  //              MPU Clock
  51      =1  //-----------------------------------------------------------------------------
  52      =1  #ifndef INTERNAL_MCU
  53      =1  //#define CLOCK_11M                                     // 11.0592MHz
  54      =1  #define CLOCK_22M                                       // 22.1184MHz
  55      =1  #else                                                           // INTERNAL_MCU
           =1 #define CLOCK_27M                                       // 27MHz
           =1 #define REG_START_ADDRESS       0xc000          // register start 0xc000, for page0, 0xc100-page1 
           =1 #endif
  59      =1  //-----------------------------------------------------------------------------
  60      =1  //              TW88 Version
  61      =1  //-----------------------------------------------------------------------------
  62      =1  #define TW8816
  63      =1  //-----------------------------------------------------------------------------
  64      =1  //              Options for Backlight control
  65      =1  //-----------------------------------------------------------------------------
  66      =1  //#define       BACKLIGHT_CCFL
  67      =1  //#define       BACKLIGHT_LED
  68      =1  #define BACKLIGHT_PWM
  69      =1  
  70      =1  //-----------------------------------------------------------------------------
  71      =1  //              Panel Resolution
  72      =1  //-----------------------------------------------------------------------------
  73      =1  // ---- Select Default Panel
  74      =1  //
  75      =1  //#define UXGA                                          // 1600 x 1200
  76      =1  //#define SXGA                                          // 1280 x 1024
  77      =1  //#define XGA  // 1024 x 768
  78      =1  #ifdef XGA
           =1         #define LVDS                                    
           =1         #define PWIDTH  1024
           =1         #define PHEIGHT 768
           =1 #endif
  83      =1  //#define SVGA                                          //  800 x 600
  84      =1  //#define VGA                                           //  640 x 480
  85      =1  #ifdef VGA
           =1         #define PWIDTH  640
           =1         #define PHEIGHT 480
           =1         //#define       HITACHI_640_B_160               //--> 640 x 160
           =1         #define AND_640_480
           =1 #endif
  91      =1  //#define WXGA                                          // 1280 x 768 (15:9) // 1366 x 768 (16:9)
  92      =1  #ifdef WXGA
           =1     //#define WX_SHARP_LQ106K1LA
           =1         #define PWIDTH  1280
           =1         #define PHEIGHT 768
           =1 #endif
  97      =1  //#define WSVGA                                         // 1024 x 600   *** only video mode
  98      =1  #ifdef WSVGA
           =1         #define PWIDTH  1024
           =1         #define PHEIGHT 600
           =1         #define UNIDEN_1024_600
           =1 #endif
 103      =1  #define WVGA                                            //  800 x 480
 104      =1  #ifdef WVGA
 105      =1          #define PWIDTH  800
 106      =1          #define PHEIGHT 600//480
 107      =1          // If WVGA, you have to select panel.
 108      =1          //#define AU_10INCH
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 3   

 109      =1          //#define WVGA_TPO
 110      =1          //#define SAMSUNG_10INCH
 111      =1          //#define SAMSUNG_TICONLESS_10INCH
 112      =1          //#define SHARP_TICONLESS_7INCH
 113      =1          #define AU_TICONLESS_7INCH
 114      =1          //#define INNOLUX_AT080TN03
 115      =1          //#define AU_TICONLESS_7INCH_CCFL
 116      =1          //#define CMO                   // CHIMEI panel
 117      =1          //#define AU_TICONLESS_10INCH
 118      =1          //#define HITACHI_T01
 119      =1          //#define HITACHI_TX23D12
 120      =1          //#define HITACHI_TX18D24
 121      =1          //#define HITACHI_TX18D16
 122      =1          //#define TMD_LTA070A320F
 123      =1          //#define TMD_LTA080B
 124      =1  #endif  //WVGA
 125      =1  //#define HVGA                                          //  480 x 320
 126      =1  //#define QVGA                                          //  320 x 240   *** only video mode
 127      =1  #ifdef QVGA
           =1         #define PWIDTH  320
           =1         #define PHEIGHT 240
           =1         //#define HITACHI_TX09D73
           =1         //#define AU_DELTARGB
           =1         //#define SHARP_LQ050Q5DR01
           =1         //#define SHARP_LQ035
           =1         //#define       TMD
           =1 #endif
 136      =1  
 137      =1  //#define WQVGA                                         //  480 x 234   *** only video mode
 138      =1  #ifdef WQVGA
           =1         #define PWIDTH  480
           =1         #define PHEIGHT 240
           =1         // If WQVGA, you have to select panel   
           =1     #define ANALOG_7INCH
           =1         //#define       PWIDTH  400
           =1         //#define PHEIGHT       240
           =1         //#define SHARP_LQ043T3DX02             //  400 x 237
           =1         //#define LG_ANALOG
           =1         //#define TMD_ANALOG                            //TMD_LTA05B352A
           =1         //#define       T_51945GD                               // Optorex Panel
           =1 #endif  // WQVGA
 150      =1  
 151      =1  //if LVDS pannel disable TICONLESS
 152      =1  
 153      =1  //-----------------------------------------------------------------------------
 154      =1  //---- Add Support One more panel with DIPSW#1
 155      =1  //---- Ex. Add Analog AU 7" Panel with Default Panel for evalution
 156      =1  //#define ADD_ANALOGPANEL               // Added Analog panel(AU7") from default set panel(expect WQVGA) with DIP #1 sw
             -itch.(DIP#1=L:ANALOG, H:DEFAULT)
 157      =1                                                          // It can't support WQVGA and ADD_ANALOGPANEL same time!!
 158      =1          //#define ADD_ANALOG_7INCH
 159      =1          //#define ADD_TMD_LTA05B352A
 160      =1                                                                          
 161      =1  //---- Support Wide panel function
 162      =1  #if (defined WXGA) || (defined WSVGA) || (defined WVGA) || (defined WQVGA)
 163      =1  #define WIDE_SCREEN                             // Can support 4 display mode, i.e. Normal, Wide, Full, Zoom
 164      =1  #endif                                                          // Tested panasonic WVGA panel.
 165      =1  
 166      =1  //-----------------------------------------------------------------------------
 167      =1  //              Panel Vendor Specific
 168      =1  //-----------------------------------------------------------------------------
 169      =1  
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 4   

 170      =1  //-----------------------------------------------------------------------------
 171      =1  //              TV Tuner
 172      =1  //-----------------------------------------------------------------------------
 173      =1  #define PHILIPS                         0
 174      =1  #define ALPS                            1               // ALPS, LG
 175      =1  #define TEMIC                           2
 176      =1  #define TVAVA                           3
 177      =1  #define LGTUNER                         4
 178      =1  #define SAMSUNGMUTITUNER        5
 179      =1  
 180      =1  #define TVTunerDevice           4
 181      =1  //-----------------------------------------------------------------------------
 182      =1  //              IR Remote Controller Type
 183      =1  //-----------------------------------------------------------------------------
 184      =1  //#define REMO_RC5                                      // RC5 style
 185      =1  #define TECHWELL_REMOCON
 186      =1  //#define REMO_NEC                                      // NEC style
 187      =1  //#define PHILIPS_REMOCON // New remocon 
 188      =1  
 189      =1  
 190      =1  //-----------------------------------------------------------------------------
 191      =1  //              I2C Device Access Address Mapping
 192      =1  //-----------------------------------------------------------------------------
 193      =1  
 194      =1  #define EEPROMI2CAddress        0xa0    // EEPROM (24C16)
 195      =1  #define TW88I2CAddress          0x8a    // TW880x
 196      =1  
 197      =1  #define MSPI2CAddress           0x80    // MSP
 198      =1  
 199      =1  //-----------------------------------------------------------------------------
 200      =1  //              Options for Possible Inputs
 201      =1  //-----------------------------------------------------------------------------
 202      =1  #define         AWT
 203      =1  //#define       E_Wintek 
 204      =1  //#define SUPPORT_SVIDEO                     //andy Awt 20090914
 205      =1  //#define SUPPORT_COMPONENT                     // support component analog to decoder//andy Awt 20090914
 206      =1  
 207      =1  //#define SUPPORT_DTV                           // support DTV input through component( to ADC ).//andy Awt 20090914
 208      =1  #define SUPPORT_PC                              // support PC function
 209      =1  //#define SUPPORT_DVI                           // support DVI input
 210      =1  #define SUPPORT_SDCARD
 211      =1  
 212      =1  //#define SUPPORT_RS485
 213      =1  
 214      =1  //-----------------------------------------------------------------------------
 215      =1  //              Options for Possible Standards
 216      =1  //              Default:NTSC
 217      =1  //-----------------------------------------------------------------------------
 218      =1  #define SUPPORT_PAL                     
 219      =1  #define SUPPORT_SECAM
 220      =1  #define SUPPORT_NTSC4           
 221      =1  #define SUPPORT_PALM    
 222      =1  #define SUPPORT_PALN            
 223      =1  #define SUPPORT_PAL60           
 224      =1  
 225      =1  
 226      =1  //#define ID_CHECK_BY_FW                        // in Video mode, check input system ID by firmware
 227      =1  
 228      =1  //-----------------------------------------------------------------------------
 229      =1  //              Options for Debugging/Release
 230      =1  //-----------------------------------------------------------------------------
 231      =1  //#define SUPPORT_PATTERN                       // support LCD test pattern
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 5   

 232      =1  
 233      =1  
 234      =1  #ifndef WQVGA
 235      =1          #ifndef QVGA
 236      =1  #define SUPPORT_OSDPOSITIONMOVE
 237      =1          #endif
 238      =1  #endif
 239      =1  
 240      =1  #define SERIAL                                  // include serial communication routines
 241      =1  
 242      =1  //#define SUPPORT_DEBUG                         // Support to use Read & Write in debug OSD Window by remocon.
 243      =1  
 244      =1  //#define DEBUG                                         // include debug information
 245      =1  #ifdef DEBUG
           =1         //#define DEBUG_MAIN
           =1         //#define DEBUG_TIME
           =1         //#define DEBUG_KEYREMO
           =1         //#define DEBUG_TW88
           =1         //#define DEBUG_DECODER
           =1         //#define DEBUG_I2C
           =1         //#define DEBUG_EEP
           =1         //#define DEBUG_OSD
           =1         //#define DEBUG_AUDIO
           =1         //#define DEBUG_SETPANEL
           =1         //#define DEBUG_DTV
           =1         #define DEBUG_PC
           =1         //#define DEBUG_PC_MEAS
           =1         #define DEBUG_PC_COLOR
           =1         //#define DEBUG_COMPONENT
           =1         //#define DEBUG_BANK
           =1         //#define DEBUG_PAUSE
           =1         //#define DEBUG_MCU
           =1 #endif
 265      =1  
 266      =1  #define AUTOCALC_PC                                     // in PC mode, Enable Auto Calcuration
 267      =1  //#define SUPPORT_USERCOLORFROMTXT      // Use color setting of text file in Color mode=USER MODE which is as B
             -rightness(Reg10), Contast(Reg11),
 268      =1                                                                          //    Sat_U(Reg13),Sat_V(Reg14),Sharpness(Reg12,Reg78)                                                                  
 269      =1  //#define SUPPORT_GAMMA
 270      =1  
 271      =1  //#define CHIP_MANUAL_TEST                      // DIPSW#1
 272      =1  
 273      =1  #ifndef INTERNAL_MCU
 274      =1  //#define NO_INITIALIZE                         // After Power switch turn on with DIP SW4 Enable(Low), or pressed MENU button 
             -for internal MCU
 275      =1                                      //     micom works to access only I2C bus by serial command.
 276      =1  #endif
 277      =1  
 278      =1  //#define SUPPORT_KRS_OSDDEMO           // For KRS Company Demo 
 279      =1  //#define SUPPORT_LINE_OSDDEMO
 280      =1  
 281      =1  //-----------------------------------------------------------------------------
 282      =1  //              Special Features
 283      =1  //-----------------------------------------------------------------------------
 284      =1  
 285      =1  #ifndef INTERNAL_MCU
 286      =1  //#define       SUPPORT_DELTA_RGB
 287      =1  #endif
 288      =1  #define SUPPORT_SELECTKEY                       // choose the keymap of using select key or left,right key.
 289      =1  //-----------------------------------------------------------------------------
 290      =1  #endif  //__CONFIG_H__
   9          
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 6   

  10          #include "reg.h"
   1      =1  //
   2      =1  //Registers.h   : Register declaration
   3      =1  //
   4      =1  
   5      =1  #ifndef __REGISTERS__
   6      =1  #define __REGISTERS__
   7      =1  
   8      =1  #ifdef INTERNAL_MCU
           =1 /*  BYTE Registers  */
           =1 sfr P0    = 0x80;
           =1 sfr P1    = 0x90;
           =1 sfr P2    = 0xA0;
           =1 sfr P3    = 0xB0;
           =1 sfr PSW   = 0xD0;
           =1 sfr ACC   = 0xE0;
           =1 sfr B     = 0xF0;
           =1 sfr SP    = 0x81;
           =1 sfr DPL   = 0x82;
           =1 sfr DPH   = 0x83;
           =1 sfr PCON  = 0x87;
           =1 sfr TCON  = 0x88;
           =1 sfr TMOD  = 0x89;
           =1 sfr TL0   = 0x8A;
           =1 sfr TL1   = 0x8B;
           =1 sfr TH0   = 0x8C;
           =1 sfr TH1   = 0x8D;
           =1 sfr IE    = 0xA8;
           =1 sfr IP    = 0xB8;
           =1 sfr SCON  = 0x98;
           =1 sfr SBUF  = 0x99;
           =1 
           =1 //sfr P4    = 0xd8;
           =1 
           =1 /*  8052 Extensions  */
           =1 sfr EXIF  = 0x91;               // external interrupt 2,3,4,5 flags should be cleared by software
           =1 sfr T2CON = 0xC8;
           =1 sfr RCAP2L = 0xCA;
           =1 sfr RCAP2H = 0xCB;
           =1 sfr TL2   = 0xCC;
           =1 sfr TH2   = 0xCD;
           =1 sfr EICON = 0xD8;
           =1 sfr EIE   = 0xE8;
           =1 sfr EIP   = 0xF8;
           =1 
           =1 /*      TW88 Core Extension */
           =1 sfr     BANKREG         = 0x9A;
           =1 sfr     SPICONTROL      = 0x9B;
           =1 sfr     T0HIGH          = 0x9C;
           =1 sfr     T0LOW           = 0x9D;
           =1 sfr     T1HIGH          = 0x9E;
           =1 sfr     T1LOW           = 0x9F;
           =1 sfr     T2HIGH          = 0x93;
           =1 sfr     T2LOW           = 0x94;
           =1 
           =1 /*  BIT Registers  */
           =1 /*  PSW  */
           =1 sbit CY    = 0xD7;
           =1 sbit AC    = 0xD6;
           =1 sbit F0    = 0xD5;
           =1 sbit RS1   = 0xD4;
           =1 sbit RS0   = 0xD3;
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 7   

           =1 sbit OV    = 0xD2;
           =1 sbit P     = 0xD0;
           =1 
           =1 /*  TCON  */
           =1 sbit TF1   = 0x8F;
           =1 sbit TR1   = 0x8E;
           =1 sbit TF0   = 0x8D;
           =1 sbit TR0   = 0x8C;
           =1 sbit IE1   = 0x8B;
           =1 sbit IT1   = 0x8A;
           =1 sbit IE0   = 0x89;
           =1 sbit IT0   = 0x88;
           =1 
           =1 /*  IE  */
           =1 sbit EA    = 0xAF;
           =1 sbit ES    = 0xAC;
           =1 sbit ET1   = 0xAB;
           =1 sbit EX1   = 0xAA;
           =1 sbit ET0   = 0xA9;
           =1 sbit EX0   = 0xA8;
           =1 
           =1 /*  EIE  */
           =1 sbit EWDI  = 0xEC;              // Watch dog timer interrupt enable
           =1 sbit EX5   = 0xEB;              // external interrupt 5 enable
           =1 sbit EX4   = 0xEA;              // external interrupt 4 enable
           =1 sbit EX3   = 0xE9;              // external interrupt 3 enable
           =1 sbit EX2   = 0xE8;              // external interrupt 2 enable
           =1 
           =1 /*  IP  */
           =1 sbit PS    = 0xBC;
           =1 sbit PT1   = 0xBB;
           =1 sbit PX1   = 0xBA;
           =1 sbit PT0   = 0xB9;
           =1 sbit PX0   = 0xB8;
           =1 
           =1 /*  EIP  */
           =1 sbit PWDI  = 0xFC;              // Watch dog timer interrupt priority
           =1 sbit PX5   = 0xFB;              // external interrupt5 priority
           =1 sbit PX4   = 0xFA;              // external interrupt4 priority
           =1 sbit PX3   = 0xF9;              // external interrupt3 priority
           =1 sbit PX2   = 0xF8;              // external interrupt2 priority
           =1 
           =1 /*  P3  */
           =1 sbit RD    = 0xB7;
           =1 sbit WR    = 0xB6;
           =1 sbit T1    = 0xB5;
           =1 sbit T0    = 0xB4;
           =1 sbit INT1  = 0xB3;
           =1 sbit INT0  = 0xB2;
           =1 sbit TXD   = 0xB1;
           =1 sbit RXD   = 0xB0;
           =1 
           =1 /*  SCON  */
           =1 sbit SM0   = 0x9F;
           =1 sbit SM1   = 0x9E;
           =1 sbit SM2   = 0x9D;
           =1 sbit REN   = 0x9C;
           =1 sbit TB8   = 0x9B;
           =1 sbit RB8   = 0x9A;
           =1 sbit TI    = 0x99;
           =1 sbit RI    = 0x98;
           =1 
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 8   

           =1 /*  8052 Extensions  */
           =1 /*  IE  */
           =1 sbit ET2   = 0xAD;
           =1 
           =1 /*  IP  */
           =1 sbit PT2   = 0xBD;
           =1 
           =1 /*  P1  */
           =1 sbit T2EX  = 0x91;
           =1 sbit T2    = 0x90;
           =1              
           =1 /*  T2CON  */
           =1 sbit TF2   = 0xCF;
           =1 sbit EXF2  = 0xCE;
           =1 sbit RCLK  = 0xCD;
           =1 sbit TCLK  = 0xCC;
           =1 sbit EXEN2 = 0xCB;
           =1 sbit TR2   = 0xCA;
           =1 sbit C_T2  = 0xC9;
           =1 sbit CP_RL2= 0xC8;
           =1 
           =1 sfr     CHPENR = 0xF6;
           =1 sfr     CHPCON = 0xBF;
           =1 sfr     SFRAL  = 0xC4;
           =1 sfr     SFRAH  = 0xC5;
           =1 sfr     SFRFD  = 0xC6;
           =1 sfr     SFRCN  = 0xC7;
           =1 
           =1 sbit P0_0  = 0x80;
           =1 sbit P0_1  = 0x81;
           =1 sbit P0_2  = 0x82;
           =1 sbit P0_3  = 0x83;
           =1 sbit P0_4  = 0x84;
           =1 sbit P0_5  = 0x85;
           =1 sbit P0_6  = 0x86;
           =1 sbit P0_7  = 0x87;
           =1 
           =1 sbit P1_0  = 0x90;
           =1 sbit P1_1  = 0x91;
           =1 sbit P1_2  = 0x92;
           =1 sbit P1_3  = 0x93;
           =1 sbit P1_4  = 0x94;
           =1 sbit P1_5  = 0x95;
           =1 sbit P1_6  = 0x96;
           =1 sbit P1_7  = 0x97;
           =1 
           =1 sbit P2_0  = 0xa0;
           =1 sbit P2_1  = 0xa1;
           =1 sbit P2_2  = 0xa2;
           =1 sbit P2_3  = 0xa3;
           =1 sbit P2_4  = 0xa4;
           =1 sbit P2_5  = 0xa5;
           =1 sbit P2_6  = 0xa6;
           =1 sbit P2_7  = 0xa7;
           =1 
           =1 sbit P3_0  = 0xb0;
           =1 sbit P3_1  = 0xb1;
           =1 sbit P3_2  = 0xb2;
           =1 sbit P3_3  = 0xb3;
           =1 sbit P3_4  = 0xb4;
           =1 sbit P3_5  = 0xb5;
           =1 sbit P3_6  = 0xb6;
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 9   

           =1 sbit P3_7  = 0xb7;
           =1 
           =1 #else   // external MCU=WINBOND
 189      =1  /*  BYTE Registers  */
 190      =1  sfr P0    = 0x80;
 191      =1  sfr P1    = 0x90;
 192      =1  sfr P2    = 0xA0;
 193      =1  sfr P3    = 0xB0;
 194      =1  sfr PSW   = 0xD0;
 195      =1  sfr ACC   = 0xE0;
 196      =1  sfr B     = 0xF0;
 197      =1  sfr SP    = 0x81;
 198      =1  sfr DPL   = 0x82;
 199      =1  sfr DPH   = 0x83;
 200      =1  sfr PCON  = 0x87;
 201      =1  sfr TCON  = 0x88;
 202      =1  sfr TMOD  = 0x89;
 203      =1  sfr TL0   = 0x8A;
 204      =1  sfr TL1   = 0x8B;
 205      =1  sfr TH0   = 0x8C;
 206      =1  sfr TH1   = 0x8D;
 207      =1  sfr CKCON = 0x8E;               //clock control register, default =0x01
 208      =1  sfr IE    = 0xA8;
 209      =1  sfr IP    = 0xB8;
 210      =1  sfr SCON  = 0x98;
 211      =1  sfr SBUF  = 0x99;
 212      =1  sfr P4 = 0xE8; //Megawin Ryan@970716
 213      =1  //sfr P4    = 0xa5;      //SST MCU
 214      =1  //sfr P4    = 0xd8;             //winbond<960820>
 215      =1  
 216      =1  
 217      =1  /*  8052 Extensions  */
 218      =1  sfr T2CON = 0xC8;
 219      =1  sfr RCAP2L = 0xCA;
 220      =1  sfr RCAP2H = 0xCB;
 221      =1  sfr TL2   = 0xCC;
 222      =1  sfr TH2   = 0xCD;
 223      =1  
 224      =1  // for UART2
 225      =1  sfr S2CON  = 0xAA;
 226      =1  sfr S2BRT  = 0xBA;
 227      =1  sfr S2BUF  = 0x9A;
 228      =1  sfr AUXR2  = 0xA6;
 229      =1  sfr AUXIE  = 0xAD;
 230      =1  
 231      =1  
 232      =1  sfr P1M0  = 0x91;
 233      =1  sfr P1M1  = 0x92;
 234      =1  sfr P0M0  = 0x93;
 235      =1  sfr P0M1  = 0x94;
 236      =1  
 237      =1  
 238      =1  
 239      =1  // for PCA
 240      =1  sfr CCON   = 0xD8;
 241      =1  sfr CMOD   = 0xD9;
 242      =1  sfr CCAPM0 = 0xDA;
 243      =1  sfr CCAPM1 = 0xDB;
 244      =1  sfr CCAPM2 = 0xDC;
 245      =1  sfr CCAPM3 = 0xDD;
 246      =1  sfr CCAPM4 = 0xDE;
 247      =1  sfr CCAPM5 = 0xDF;
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 10  

 248      =1  sfr CL     = 0xE9;
 249      =1  sfr CH     = 0xF9;
 250      =1  sfr CCAP0L = 0xEA;
 251      =1  sfr CCAP0H = 0xFA;
 252      =1  sfr CCAP1L = 0xEB;
 253      =1  sfr CCAP1H = 0xFB;
 254      =1  sfr CCAP2L = 0xEC;
 255      =1  sfr CCAP2H = 0xFC;
 256      =1  sfr CCAP3L = 0xED;
 257      =1  sfr CCAP3H = 0xFD;
 258      =1  sfr CCAP4L = 0xEE;
 259      =1  sfr CCAP4H = 0xFE;
 260      =1  sfr CCAP5L = 0xEF;
 261      =1  sfr CCAP5H = 0xFF;
 262      =1  sfr PCAPWM0= 0xF2;
 263      =1  sfr PCAPWM1= 0xF3;
 264      =1  sfr PCAPWM2= 0xF4;
 265      =1  sfr PCAPWM3= 0xF5;
 266      =1  sfr PCAPWM4= 0xF6;
 267      =1  sfr PCAPWM5= 0xF7;
 268      =1  
 269      =1  /*  BIT Registers  */
 270      =1  /*  PSW  */
 271      =1  sbit CY    = 0xD7;
 272      =1  sbit AC    = 0xD6;
 273      =1  sbit F0    = 0xD5;
 274      =1  sbit RS1   = 0xD4;
 275      =1  sbit RS0   = 0xD3;
 276      =1  sbit OV    = 0xD2;
 277      =1  sbit P     = 0xD0;
 278      =1  
 279      =1  /*  TCON  */
 280      =1  sbit TF1   = 0x8F;
 281      =1  sbit TR1   = 0x8E;
 282      =1  sbit TF0   = 0x8D;
 283      =1  sbit TR0   = 0x8C;
 284      =1  sbit IE1   = 0x8B;
 285      =1  sbit IT1   = 0x8A;
 286      =1  sbit IE0   = 0x89;
 287      =1  sbit IT0   = 0x88;
 288      =1  
 289      =1  /*  IE  */
 290      =1  sbit EA    = 0xAF;
 291      =1  sbit ES    = 0xAC;
 292      =1  sbit ET1   = 0xAB;
 293      =1  sbit EX1   = 0xAA;
 294      =1  sbit ET0   = 0xA9;
 295      =1  sbit EX0   = 0xA8;
 296      =1  
 297      =1  /*  IP  */
 298      =1  sbit PS    = 0xBC;
 299      =1  sbit PT1   = 0xBB;
 300      =1  sbit PX1   = 0xBA;
 301      =1  sbit PT0   = 0xB9;
 302      =1  sbit PX0   = 0xB8;
 303      =1  
 304      =1  /*  P3  */
 305      =1  sbit RD    = 0xB7;
 306      =1  sbit WR    = 0xB6;
 307      =1  sbit T1    = 0xB5;
 308      =1  sbit T0    = 0xB4;
 309      =1  sbit INT1  = 0xB3;
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 11  

 310      =1  sbit INT0  = 0xB2;
 311      =1  sbit TXD   = 0xB1;
 312      =1  sbit RXD   = 0xB0;
 313      =1  
 314      =1  /*  SCON  */
 315      =1  sbit SM0   = 0x9F;
 316      =1  sbit SM1   = 0x9E;
 317      =1  sbit SM2   = 0x9D;
 318      =1  sbit REN   = 0x9C;
 319      =1  sbit TB8   = 0x9B;
 320      =1  sbit RB8   = 0x9A;
 321      =1  sbit TI    = 0x99;
 322      =1  sbit RI    = 0x98;
 323      =1  
 324      =1  /*  8052 Extensions  */
 325      =1  /*  IE  */
 326      =1  sbit ET2   = 0xAD;
 327      =1  
 328      =1  /*  IP  */
 329      =1  sbit PT2   = 0xBD;
 330      =1  
 331      =1  /*  P1  */
 332      =1  sbit T2EX  = 0x91;
 333      =1  sbit T2    = 0x90;
 334      =1               
 335      =1  /*  T2CON  */
 336      =1  sbit TF2   = 0xCF;
 337      =1  sbit EXF2  = 0xCE;
 338      =1  sbit RCLK  = 0xCD;
 339      =1  sbit TCLK  = 0xCC;
 340      =1  sbit EXEN2 = 0xCB;
 341      =1  sbit TR2   = 0xCA;
 342      =1  sbit C_T2  = 0xC9;
 343      =1  sbit CP_RL2= 0xC8;
 344      =1  
 345      =1  sfr     CHPENR = 0xF6;
 346      =1  sfr     CHPCON = 0xBF;
 347      =1  sfr     SFRAL  = 0xC4;
 348      =1  sfr     SFRAH  = 0xC5;
 349      =1  sfr     SFRFD  = 0xC6;
 350      =1  sfr     SFRCN  = 0xC7;
 351      =1  
 352      =1  sbit P0_0  = 0x80;
 353      =1  sbit P0_1  = 0x81;
 354      =1  sbit P0_2  = 0x82;
 355      =1  sbit P0_3  = 0x83;
 356      =1  sbit P0_4  = 0x84;
 357      =1  sbit P0_5  = 0x85;
 358      =1  sbit P0_6  = 0x86;
 359      =1  sbit P0_7  = 0x87;
 360      =1  
 361      =1  sbit P1_0  = 0x90;
 362      =1  sbit P1_1  = 0x91;
 363      =1  sbit P1_2  = 0x92;
 364      =1  sbit P1_3  = 0x93;
 365      =1  sbit P1_4  = 0x94;
 366      =1  sbit P1_5  = 0x95;
 367      =1  sbit P1_6  = 0x96;
 368      =1  sbit P1_7  = 0x97;
 369      =1  
 370      =1  sbit P2_0  = 0xa0;
 371      =1  sbit P2_1  = 0xa1;
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 12  

 372      =1  sbit P2_2  = 0xa2;
 373      =1  sbit P2_3  = 0xa3;
 374      =1  sbit P2_4  = 0xa4;
 375      =1  sbit P2_5  = 0xa5;
 376      =1  sbit P2_6  = 0xa6;
 377      =1  sbit P2_7  = 0xa7;
 378      =1  
 379      =1  sbit P3_0  = 0xb0;
 380      =1  sbit P3_1  = 0xb1;
 381      =1  sbit P3_2  = 0xb2;
 382      =1  sbit P3_3  = 0xb3;
 383      =1  sbit P3_4  = 0xb4;
 384      =1  sbit P3_5  = 0xb5;
 385      =1  sbit P3_6  = 0xb6;
 386      =1  sbit P3_7  = 0xb7;
 387      =1  
 388      =1  sbit P4_0  = P4^0;
 389      =1  sbit P4_1  = P4^1;
 390      =1  sbit INT3  = P4^2;
 391      =1  sbit INT2  = P4^3;
 392      =1  #endif  // INTERNAL_MCU
 393      =1  
 394      =1  #endif  //__REGISTERS__
  11          #include "typedefs.h"
   1      =1  #ifndef __TYPEDEFS__
   2      =1  #define __TYPEDEFS__
   3      =1  
   4      =1  
   5      =1  #define DATA            data
   6      =1  #define PDATA           pdata
   7      =1  #define IDATA           data
   8      =1  #define CODE            code
   9      =1  #define CODE_P
  10      =1  #define PDATA_P
  11      =1  #define IDATA_P
  12      =1  #define DATA_P
  13      =1  
  14      =1  #define INTERRUPT( num, name ) name() interrupt num
  15      =1  
  16      =1  #define _between(x, a, b)       (a<=x && x<=b)
  17      =1  #define _swap(a, b)                     { a^=b; b^=a; a^=b; }
  18      =1  
  19      =1  typedef unsigned char   Register;
  20      =1  typedef unsigned char   BYTE;
  21      =1  typedef unsigned short  WORD;
  22      =1  typedef unsigned long   DWORD;
  23      =1  
  24      =1  #define TRUE    1
  25      =1  #define FALSE   0
  26      =1  
  27      =1  //VInputStdDetectMode
  28      =1  #define AUTO    0
  29      =1  
  30      =1  //VInputStd
  31      =1  #define NTSC    1                       
  32      =1  #define PAL             2
  33      =1  #define SECAM   3
  34      =1  #define NTSC4   4
  35      =1  #define PALM    5
  36      =1  #define PALN    6
  37      =1  #define PAL60   7
  38      =1  
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 13  

  39      =1  #define MAXINPUTSTD     PAL60+1 // 
  40      =1  
  41      =1  #define UNKNOWN 0xfe
  42      =1  #define NOINPUT 0       //0xff
  43      =1  
  44      =1  
  45      =1  
  46      =1  
  47      =1  #define NIL                     0xff
  48      =1  
  49      =1  enum SourceModeTypeEnum
  50      =1  {       
  51      =1          AVMode,            // 0
  52      =1          VGAMode,       // 1
  53      =1          CAM_D,         // 2
  54      =1          CAM_A,         // 3
  55      =1          CAM_B,         // 4
  56      =1          CAM_C,         // 5
  57      =1          CAM_R,         // 6
  58      =1          CAM_AB,        // 7
  59      =1          CAM_CR,        // 8
  60      =1          CAM_AR,        // 9
  61      =1          CAM_RB,        // 10
  62      =1          CAM_AC,        // 11
  63      =1          CAM_CB,        // 12
  64      =1          CAM_RAB_T,     // 13
  65      =1          CAM_RAB_H,     // 14
  66      =1  
  67      =1          CAM_QUAD,      // 15
  68      =1          CAM_ABR_T3,    // 16
  69      =1          CAM_ABR_T4,    // 17
  70      =1          SEQ,           // 18
  71      =1          CAM_BA,                 //19
  72      =1          
  73      =1          CAM_BC,
  74      =1          CAM_BR,
  75      =1          CAM_CA,
  76      =1          CAM_ABC,
  77      =1          CAM_ABR,
  78      =1          CAM_ACR,
  79      =1          CAM_BAC,
  80      =1          CAM_BAR,
  81      =1          CAM_BCR,
  82      =1          CAM_CAB,
  83      =1          CAM_CAR,
  84      =1          CAM_CBR,        
  85      =1          CAM_NUM
  86      =1  };
  87      =1  
  88      =1  typedef unsigned char SourceModeType;
  89      =1  
  90      =1  #endif  /* __TYPEDEFS__ */
  12          #include "cpu.h"
   1      =1  #ifndef __CPU__
   2      =1  #define __CPU__
   3      =1  
   4      =1  /*
   5      =1  #ifdef INTERNAL_MCU
   6      =1  #define I2C_SCL         P2_0
   7      =1  #else
   8      =1  #define I2C_SCL         P1_0
   9      =1  #endif
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 14  

  10      =1  #define I2C_SDA         P1_1
  11      =1  */
  12      =1  #define I2C_SCL         P1_0
  13      =1  #define I2C_SDA         P1_1
  14      =1  #define BUF_MAX         8
  15      =1  #define DVR_BUF_MAX     30
  16      =1  
  17      =1  #ifdef REMO_RC5
           =1 #define EnableRemoconInt()      { RemoDataReady = 0;    EX0 = 1;}
           =1 #endif
  20      =1  void    InitCPU(void);
  21      =1  void    InitVars(void);
  22      =1  void    InitTechwell(void);
  23      =1  void    main_init (void);
  24      =1  void    PowerDown( void );
  25      =1  #if 0
           =1 BYTE    OKSleepTime(void);
           =1 #endif
  28      =1  #ifdef REMO_RC5
           =1 void    InitForRemo(void);
           =1 #endif
  31      =1  void    PowerLED(BYTE flag);
  32      =1  void    Wait_ms(WORD Tms);
  33      =1  BYTE    TW2835Command(char,char,char,char,char);
  34      =1  
  35      =1  #endif
  13          #include "I2C.h"
   1      =1  #ifndef __I2C_H__
   2      =1  #define __I2C_H__
   3      =1  
   4      =1  
   5      =1  void I2CReadByte3(BYTE *);
   6      =1  void I2CRead8Byte(BYTE *);
   7      =1  #if 0
           =1 void I2CReadByteMSP(BYTE addr, BYTE index, BYTE *pd, BYTE cnt);
           =1 #endif
  10      =1  BYTE I2CWriteByte2(BYTE);
  11      =1  BYTE I2CWriteByte3(BYTE*);
  12      =1  BYTE I2CWrite8Byte(BYTE *);
  13      =1  
  14      =1  void I2CStart(void);
  15      =1  void I2CWriteData(BYTE value);
  16      =1  BYTE I2CReadData(void);
  17      =1  #if 0
           =1 BYTE I2CReadDataWithACK(void);
           =1 #endif
  20      =1  void I2CStop(void);
  21      =1  void I2Cdelay(void);
  22      =1  
  23      =1  
  24      =1  #define WriteTW88(a,b)          WriteI2C(TW88I2CAddress, a, b)
  25      =1  #define ReadTW88(a)                     ReadI2C(TW88I2CAddress, a)
  26      =1  
  27      =1  BYTE WriteTW88_Wait     (BYTE, BYTE);
  28      =1  void WriteADC           (BYTE, BYTE);
  29      =1  BYTE ReadADC            (BYTE);
  30      =1  BYTE ReadADC_TW88(BYTE index);
  31      =1  void WriteADC_TW88(BYTE index, BYTE dat);
  32      =1  
  33      =1  void WriteEEP           (WORD, BYTE);
  34      =1  BYTE ReadEEP            (WORD);
  35      =1  
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 15  

  36      =1  
  37      =1  BYTE ReadI2C            (BYTE addr, BYTE index);
  38      =1  void WriteI2C           (BYTE addr, BYTE index, BYTE val);
  39      =1  
  40      =1  void WriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt);
  41      =1  void WriteI2Cn (BYTE addr, BYTE index, BYTE *val, BYTE cnt);
  42      =1  void WriteI2CnD(BYTE addr, BYTE index, BYTE val, BYTE cnt);
  43      =1  
  44      =1  void ReadI2Cmn(BYTE addr, BYTE wcnt, BYTE rcnt, BYTE *rwdata);
  45      =1  
  46      =1  #define         WriteADC(a,b)   WriteADC_TW88(a,b)
  47      =1  #define         ReadADC(a)              ReadADC_TW88(a)
  48      =1  
  49      =1  #endif  /* __I2C_H__ */
  14          #include "main.h"
   1      =1  #ifndef __MAIN__
   2      =1  #define __MAIN__
   3      =1  
   4      =1  #define ON                                      1
   5      =1  #define OFF                                     0
   6      =1  //#define Hs_debug
   7      =1  //#define       DVR
   8      =1  
   9      =1  //================= DIP SW Definition =========================================
  10      =1  ///#define PIXEL_SINGLE         P0_0
  11      =1  #define DIP_PANEL_SWITCH        P0_0    // Samsung(0) // Sharp-Noticon(1)
  12      =1  #define DIP_AUTO_DETECT         P0_1
  13      =1  #define DIP_EDGE_ENHANCE        P0_2
  14      =1  #define DIP_BW_STRETCH          P0_3
  15      =1  
  16      =1  #define Panel_Enable()          P4=P4|0x08 //andy 980908
  17      =1  #define Panel_Disable()                 P4=P4&0xf7
  18      =1  
  19      =1  #define SetBacklight()      P4=P4|0x04
  20      =1  #define clrBacklight()      P4=P4&0xfb
  21      =1  
  22      =1  
  23      =1  //InputSelection
  24      =1  struct struct_IdName {
  25      =1          BYTE    Id;
  26      =1          BYTE    Name[16];
  27      =1  };
  28      =1  
  29      =1  #define CH_TW2835              1
  30      =1  #define CH_CAMD                2
  31      =1  #define CH_AV                  3
  32      =1  #define PC                                         7
  33      =1  #define ChineseDefaultMenu   8
  34      =1  
  35      =1  #define SVIDEO                          2
  36      =1  #define COMPONENT                       3
  37      =1  //#define ANALOGDTV                     4
  38      =1  #define DTV                                     4
  39      =1  #define TV                                      5
  40      =1  #define SCART                           6
  41      =1  
  42      =1  #define DIGITALVGA                      8
  43      =1  
  44      =1  #define AIRTV                           0 //9
  45      =1  #define CABLETV                         1 //0xa
  46      =1  
  47      =1  
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 16  

  48      =1  #define TVTUNER                         0xd             //10
  49      =1  #define MUTE                            1       
  50      =1  #define MENU                            2       
  51      =1  #define TVVOL                           4       
  52      =1  #define CC                                      8       
  53      =1  #define INPUTINFO                       0x10
  54      =1  #define PCINFO                          0x20
  55      =1  #define GAUGEINFO           0x40
  56      =1  //#define RATINGINFO                    0x40
  57      =1  #define TVCHN                           0x80
  58      =1  //#define MUTE                          0x40
  59      =1  
  60      =1  #define YPBPR_480i                      0
  61      =1  #define YPBPR_576i                      1
  62      =1  #define YPBPR_480p                      2
  63      =1  #define YPBPR_576p                      3
  64      =1  #define YPBPR_1080i                     4
  65      =1  #define YPBPR_720p                      5
  66      =1  #define YPBPR_720p50            6
  67      =1  
  68      =1  
  69      =1  //--------------------------- P0 Define -----------------------------
  70      =1  #define SEL_MIX                 P0_6    // 
  71      =1  //--------------------------- P1 Define -----------------------------
  72      =1  #define SEL_DVI                 P3_5    //LJY062001             
  73      =1  
  74      =1  #define TW88HWReset                     P3_4    //LJY001010 //LJY000721
  75      =1  #define PowerUp             P1_4
  76      =1  //======================= CDS Control ================================= 
  77      =1  #define CDS_CTRL           P1_5
  78      =1  extern BYTE     SelectModeType;
  79      =1  extern BYTE InputSelection;
  80      =1  extern BYTE SEQTime;
  81      =1  extern BYTE     Priority;
  82      =1  extern BYTE AutoDayNight;
  83      =1  extern BYTE PowerFlag;
  84      =1  
  85      =1  BYTE keyIn(void);
  86      =1  void TimerForRemocon(void);
  87      =1  void TimerForTick(void);
  88      =1  void DisableRemoconInt(void);
  89      =1  BYTE SetSupport_remocon(BYTE newd);
  90      =1  
  91      =1  void delay(BYTE cnt);
  92      =1  
  93      =1  BYTE RS_ready(void);
  94      =1  BYTE RS_rx(void);
  95      =1  void RS_tx(BYTE tx_buf);
  96      =1  
  97      =1  BYTE RS2_rx(void);
  98      =1  void RS2_tx(BYTE tx_buf);
  99      =1  
 100      =1  void NewLine(void);
 101      =1  void PutsP(PDATA_P BYTE *ptr);
 102      =1  #ifdef Hs_debug
           =1 void MonWriteI2C(BYTE addr, BYTE index, BYTE val);
           =1 BYTE MonReadI2C(BYTE addr, BYTE index);
           =1 #endif
 106      =1  BYTE Asc1Bin(BYTE asc);
 107      =1  BYTE Asc2Bin(PDATA_P BYTE *s);
 108      =1  
 109      =1  void I2CDeviceInitialize( CODE_P BYTE *RegSet);
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 17  

 110      =1  
 111      =1  //void RestartSystemClock(WORD clock_hm);
 112      =1  WORD GetTime_ms(void);
 113      =1  BYTE GetTime_H(void);
 114      =1  BYTE GetTime_M(void);
 115      =1  void ChangeTime_H( char add );
 116      =1  void ChangeTime_M( char add );
 117      =1  //WORD GetWakeupTime(void);
 118      =1  //void SetWakeupTime(WORD wtime);
 119      =1  
 120      =1  
 121      =1  //WORD GetOffTime(void);
 122      =1  //void SetOffTime(WORD wtime);
 123      =1  //BYTE GetSleepTimer(void);
 124      =1  //void SetSleepTimer(BYTE stime);
 125      =1  WORD DiffTime_ms( WORD stime, WORD etime );
 126      =1  //void SetLastBlockedTime(void);
 127      =1  void SetLastCCTime(void);                               //ljy010904...CC_FIX_CLEAR_ON_TIME
 128      =1  
 129      =1  void SetOSDLastKeyInTime(void);
 130      =1  WORD GetOSDLastKeyInTime(void);
 131      =1  WORD GetIVF(void);
 132      =1  DWORD GetIHF(void);
 133      =1  BYTE ReadVInputSTD(void);
 134      =1  void SetVInputStd(BYTE newd);
 135      =1  BYTE GetVInputStd(void);
 136      =1  BYTE GetInputSelection(void);
 137      =1  #ifdef ADD_ANALOGPANEL
           =1 BYTE IsAnalogOn(void);
           =1 #endif
 140      =1  void InitVideoData(BYTE src);
 141      =1  void ChangeVInputStdDetectMode(BYTE val);
 142      =1  BYTE GetVInputStdInx(void);
 143      =1  
 144      =1  void MonWriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt) ;
 145      =1  
 146      =1  ///void Usage(void);
 147      =1  #ifdef Hs_debug
           =1         void Prompt(void);
           =1 #endif
 150      =1  void DebugKeyIn(BYTE ikey);
 151      =1  void DVIPowerDown(bit flag);
 152      =1  void PowerDown_XTAL(bit flag);
 153      =1  
 154      =1  void ChangeInput(BYTE newsel);
 155      =1  
 156      =1  
 157      =1  void WaitPowerOn(void);
 158      =1  void PowerOff(void);
 159      =1  BYTE GetNextInputSelection(void);
 160      =1  
 161      =1  BYTE WantToStopTVScan(void);
 162      =1  
 163      =1  //BYTE IsTW8801(void);
 164      =1  //BYTE IsTW8803(void);
 165      =1  //BYTE ConvertVideoVSAT(BYTE reg);
 166      =1  
 167      =1  BYTE IsNoInput(void);
 168      =1  void LoadEEPROM (void);
 169      =1  void Hs_InitVars(void);
 170      =1  void AdjustAutoDayNight(BYTE val);
 171      =1  void ACCPowerControl(void);
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 18  

 172      =1  struct RegisterInfo
 173      =1  {
 174      =1     int  Min;
 175      =1     int  Max;
 176      =1     int  Default;
 177      =1  };
 178      =1  struct LongRegisterInfo
 179      =1  {
 180      =1     WORD Min;
 181      =1     WORD Max;
 182      =1     WORD Default;
 183      =1  };
 184      =1  
 185      =1  #endif  // __MAIN__
  15          #include "debug.h"
   1      =1  #ifndef __DEBUG__
   2      =1  #define __DEBUG__
   3      =1  
   4      =1  #define DEBUG_ERR       1
   5      =1  #define DEBUG_WARN      2
   6      =1  #define DEBUG_INFO      3
   7      =1  #define DEBUG_BREAK     4
   8      =1  
   9      =1  #define Pause(a)        { Printf("\r\n"); Printf(a); while(!RS_ready()); RS_rx(); }
  10      =1  
  11      =1  //#define BURSTLOCK     7
  12      =1  
  13      =1  void DebugWindowControl (void) ;
  14      =1  void Draw_Debug_Char(void);
  15      =1  void DebugWindowCursor( BYTE flag ) ;
  16      =1  void DebugWindowData( BYTE flag ) ;
  17      =1  void Debug_Write(void);
  18      =1  void Debug_Read(void);
  19      =1  
  20      =1  
  21      =1  
  22      =1  #endif  // __DEBUG__
  23      =1  
  24      =1  #ifdef CHIP_MANUAL_TEST
           =1 BYTE DelaynCheck(void);
           =1 void ChipManualTest(void);
           =1 
           =1 #endif
  16          #include "printf.h"
   1      =1  #ifndef __PRINTF__
   2      =1  #define __PRINTF__
   3      =1  
   4      =1  #define _outchar(c) while(1) { if( !RS_Xbusy ) { SBUF = c; RS_Xbusy=1; break; } }
   5      =1  #define Putch(c) _outchar(c)
   6      =1  
   7      =1  #ifdef SERIAL
   8      =1  
   9      =1   void Printf ( const char CODE_P *fmt, ... );
  10      =1   void Puts ( CODE_P char *ptr );
  11      =1  
  12      =1  #define TW2835Cmd(a)   Puts ( a )
  13      =1  
  14      =1  #else
           =1 
           =1  #undef  DEBUG
           =1  #define Printf(a,b)    //
           =1  #define Puts(a)                //
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 19  

           =1 
           =1 #endif
  21      =1  
  22      =1  
  23      =1  #ifndef DEBUG
  24      =1  
  25      =1   #define dPuts(a)               //
  26      =1   #define wPuts(a)               //
  27      =1   #define ePuts(a)               //
  28      =1  
  29      =1  #else
           =1 
           =1  void dPrintf( const char CODE_P *fmt, ... );
           =1  void wPrintf( const char CODE_P *fmt, ... );
           =1  void ePrintf( const char CODE_P *fmt, ... );
           =1 
           =1  void dPuts( CODE_P char *ptr );
           =1  void wPuts( CODE_P char *ptr );
           =1  void ePuts( CODE_P char *ptr );
           =1 
           =1 #endif  // DEBUG
  40      =1  
  41      =1  BYTE Getch(void);
  42      =1  BYTE Getche(void);
  43      =1  
  44      =1  
  45      =1  #endif  //__PRINTF__
  17          #include "osdbasic.h"
   1      =1  //osd_basic.h
   2      =1  //LJY11012001
   3      =1  #ifndef __OSD_BASIC__
   4      =1  #define __OSD_BASIC__
   5      =1  
   6      =1  // osd_basic.h
   7      =1  // char code
   8      =1  //#include "apilib.h"
   9      =1  
  10      =1  //ljy052903
  11      =1  //definition for internal OSD
  12      =1  #define FONT_WIDTH_TW88                 12
  13      =1  #define FONT_HEIGHT_TW88                18
  14      =1  #define PIXS_PER_XSTEP_TW88             8
  15      =1  #define LINES_PER_YSTEP_TW88    4
  16      =1  #define MAX_OSDWINDOW_TW88              8
  17      =1  
  18      =1  // Using TW88 OSD for Menu
  19      =1  #define FONT_WIDTH                      12
  20      =1  #define FONT_HEIGHT                     18
  21      =1  #define PIXS_PER_XSTEP          8
  22      =1  #define LINES_PER_YSTEP         4
  23      =1  #define MAX_OSDWINDOW           4
  24      =1  
  25      =1  #define MAX_FONT_BYTES          27
  26      =1  #define RAMFONT         0xFE
  27      =1  #define ROMFONT         0xFF
  28      =1  #define NO_UDFONT                       226 
  29      =1  
  30      =1  #define FONT_ROM        1
  31      =1  #define FONT_RAM        2
  32      =1  
  33      =1  
  34      =1  /////////////////////////////////
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 20  

  35      =1  // Old Registers...
  36      =1  /*
  37      =1          #define TW88_WIN1ATTR           0x76
  38      =1          #define TW88_WIN1XSTART         0x77
  39      =1          #define TW88_WIN1YSTART         0x78
  40      =1          #define TW88_WIN1WIDTH          0x79
  41      =1          #define TW88_WIN1HEIGHT         0x7a
  42      =1          #define TW88_WIN1BRDATTR        0x7b
  43      =1          #define TW88_WIN1BRDWIDTH       0x7c
  44      =1          #define TW88_WIN1BRDHEIGHT      0x7d
  45      =1          #define TW88_WIN1XSPACE         0x7e            // between characters.
  46      =1          #define TW88_WIN1YSPACE         0x7f
  47      =1          #define TW88_WIN1SADDR          0x80            // starting address of OSD ram for Windows 1
  48      =1  */
  49      =1  /////////////////////////////////
  50      =1  
  51      =1  // OSD
  52      =1  #define TW88_ENABLERAM          0x94    // TW8804C
  53      =1  #define TW88_FONTRAMADDR        0x99    // TW8804C
  54      =1  #define TW88_FONTRAMDATA        0x9a    // TW8804C
  55      =1  #define TW88_OSDRAMADDRHI       0x95    // TW8804C
  56      =1  #define TW88_OSDRAMADDRLO       0x96    // TW8804C
  57      =1  #define TW88_OSDRAMDATAHI       0x97    // TW8804C
  58      =1  #define TW88_OSDRAMDATALO       0x98    // TW8804C
  59      =1  #define TW88_MULTISTART         0x9b    // TW8804C
  60      =1  #define TW88_OSDLOCKUPSEL       0x9c
  61      =1  #define TW88_WINNUM                     0x9e    // TW8804C
  62      =1  #define TW88_WINATTR            0x9f    //
  63      =1  #define TW88_WINXSTART          0xa1    //
  64      =1  #define TW88_WINYSTART          0xa2    //
  65      =1  #define TW88_WINSTART_HI        0xa0    //
  66      =1  #define TW88_WINWIDTH           0xa3    //
  67      =1  #define TW88_WINHEIGHT          0xa4    //
  68      =1  #define TW88_WINBRDATTR         0xa5    //
  69      =1  #define TW88_WINBRDWIDTH        0xa6    //
  70      =1  #define TW88_WINBRDHEIGHT       0xa7    //
  71      =1  #define TW88_WINSPACE           0xa8    // between characters.
  72      =1  #define TW88_WINZOOM            0xa9    //
  73      =1  #define TW88_WINSADDRHI         0xa9    // starting address of OSD ram for Windows 1
  74      =1  #define TW88_WINSADDRLO         0xaa    // starting address of OSD ram for Windows 1
  75      =1  
  76      =1  #define TW88_WINSHADOW          0xab    //
  77      =1  #define TW88_WINBLENDING        0xac    //
  78      =1  #define TW88_WINCHEFFECT        0xad    //
  79      =1  
  80      =1  
  81      =1  //Attributes for OSD
  82      =1  #define WINZOOMx1                       0x01
  83      =1  #define WINZOOMx2                       0x02
  84      =1  #define WINZOOMx3                       0x03
  85      =1  #define WINZOOMx4                       0x04
  86      =1  #define SHOW                            0x08    
  87      =1  
  88      =1  #define EXTENDED_COLOR          0x80
  89      =1  #define BG_COLOR_BLACK          0x00    //For background color of window, border, and char. 
  90      =1  #define BG_COLOR_RED            0x40    
  91      =1  #define BG_COLOR_GREEN          0x20
  92      =1  #define BG_COLOR_YELLOW         0x60
  93      =1  #define BG_COLOR_BLUE           0x10
  94      =1  #define BG_COLOR_MAGENTA        0x50
  95      =1  #define BG_COLOR_CYAN           0x30
  96      =1  #define BG_COLOR_WHITE          0x70
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 21  

  97      =1  #define BG_COLOR_TRANS          0x80    
  98      =1  #define BG_COLOR_MASK           0xf0    
  99      =1  
 100      =1  #define CH_COLOR_BLACK          0x00    //For color of char.
 101      =1  #define CH_COLOR_RED            0x04    
 102      =1  #define CH_COLOR_GREEN          0x02
 103      =1  #define CH_COLOR_YELLOW         0x06
 104      =1  #define CH_COLOR_BLUE           0x01
 105      =1  #define CH_COLOR_MAGENTA        0x05
 106      =1  #define CH_COLOR_CYAN           0x03
 107      =1  #define CH_COLOR_WHITE          0x07
 108      =1  #define CH_BLINK                        0x08    
 109      =1  #define CH_COLOR_MASK           0x0f    
 110      =1  
 111      =1  #define CL_BLACK                        0x00    //For color of char.
 112      =1  #define CL_BLUE                         0x01
 113      =1  #define CL_GREEN                        0x02
 114      =1  #define CL_CYAN                         0x03
 115      =1  #define CL_RED                          0x04    
 116      =1  #define CL_MAGENTA                      0x05
 117      =1  #define CL_YELLOW                       0x06
 118      =1  #define CL_WHITE                        0x07
 119      =1  #define CL_BLINK                        0x08    
 120      =1  
 121      =1  // 0x76*(WindowNo*0x0b)
 122      =1  #define WINDOW_DISABLE          0x00
 123      =1  #define WINDOW_ENABLE           0x01
 124      =1  #define WINDOW_3D_ENABLE    0x04
 125      =1  #define WINDOW_3D_BOTTOM    0x08
 126      =1  #define WINDOW_3D_TOP       0x00
 127      =1  #define WINDOW_TRANS_ENABLE 0x80
 128      =1  
 129      =1  #define WINBDCOLOR_ENABLE       0x80
 130      =1  #define WINBDCOLOR_EXTENT       0x80
 131      =1  
 132      =1  
 133      =1  #define WINBLENDING_DISABLE 0x00
 134      =1  #define WINBLENDING_BACK    0x10
 135      =1  #define WINBLENDING_FORE    0x20
 136      =1  #define WINBLENDING_ALL     0x30
 137      =1  
 138      =1  #define WINSHADOW_ENABLE        0x80
 139      =1  // 0xc8*WindowNo
 140      =1  #define WIN_MULTICOLOR_ENABLE 0x20
 141      =1  #define WIN_CH_EFFECT_ENABLE  0x10
 142      =1  #define WIN_CH_EFFECT_SHADOW  0x08
 143      =1  
 144      =1  
 145      =1  
 146      =1  ///////// TW8804C /////////////
 147      =1  // Window Number
 148      =1  #define WINNUM1                         1
 149      =1  #define WINNUM2                         2
 150      =1  #define WINNUM3                         3
 151      =1  #define WINNUM4                         4
 152      =1  
 153      =1  // Index 0x9f Defination
 154      =1  #define WIN_BG_COLOR_EX         0x80
 155      =1  #define WIN_BG_COLOR_EX0        0x00
 156      =1  #define WIN_3D_TYPE                     0x08
 157      =1  #define WIN_3D_TYPE0            0x00
 158      =1  #define WIN_3D_EN                       0x04
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 22  

 159      =1  #define WIN_3D_EN0                      0x00
 160      =1  #define WIN_3D_LEVEL            0x02
 161      =1  #define WIN_EN                          0x01
 162      =1  #define WIN_EN0                         0x00
 163      =1  
 164      =1  // Index 0xa5 Defination
 165      =1  #define WIN_BD_EN                       0x80
 166      =1  #define WIN_BD_EN0                      0x00
 167      =1  #define WIN_BD_WIDTH(a)         a
 168      =1  
 169      =1  // Index 0xa6 Defination
 170      =1  #define WIN_BD_COLOR_EX         0x80
 171      =1  #define WIN_BD_COLOR_EX0        0x00
 172      =1  #define WIN_H_BD_W(a)           a
 173      =1  
 174      =1  // Index 0xa7 Defination
 175      =1  #define WIN_V_BD_W(a)           a
 176      =1  
 177      =1  // Index 0xa8
 178      =1  #define WIN_CH_VSPACE(a)        (a<<4)
 179      =1  #define WIN_CH_HSPACE(a)        a
 180      =1  
 181      =1  // Index 0xa9 Defination
 182      =1  #define WIN_VZOOM(a)            (a-1)
 183      =1  #define WIN_HZOOM(a)            (a-1)
 184      =1  #define WIN_SADDR(a)            a
 185      =1  
 186      =1  // Index 0xab
 187      =1  #define WIN_SHADOW_EN           0x80
 188      =1  #define WIN_SHADOW_EN0          0x00
 189      =1  #define WIN_SHADOW_W(a)         a
 190      =1  
 191      =1  // ad
 192      =1  #define WIN_SHADOW_COLOR_EX             0x80
 193      =1  #define WIN_SHADOW_COLOR_EX0    0x00
 194      =1  #define WIN_MULTI_EN                    0x40
 195      =1  #define WIN_MULTI_EN0                   0x00
 196      =1  #define WIN_V_EXT_EN                    0x20
 197      =1  #define WIN_V_EXT_EN0                   0x00
 198      =1  #define WIN_CH_BDSH_SEL(a)              a
 199      =1  #define SEL_BORDER                              0
 200      =1  #define SEL_SHADOW                              1
 201      =1  #define WIN_CH_BDSH_COLOR_EX    0x08
 202      =1  #define WIN_CH_BDSH_COLOR_EX0   0x00
 203      =1  
 204      =1  #define OSD_Win_Num(a)                  0x9e, a-1
 205      =1  #define OSD_Win_Start_Addr              0xa0
 206      =1  #define OSD_Win_Attr(a)                         a
 207      =1  #define OSD_Win_Start(h,v)                       (BYTE)(((WORD)h>>8) | (((WORD)v>>8)<<4)),(BYTE)h, (BYTE)v
 208      =1  #define OSD_Win_Width(a)                        a
 209      =1  #define OSD_Win_Height(a)                       a
 210      =1  #define OSD_Win_Border(a)                       a
 211      =1  #define OSD_Win_HBorder(a)                      a
 212      =1  #define OSD_Win_VBorder(a)                      a
 213      =1  #define OSD_Win_CH_Space(a)                     a
 214      =1  #define OSD_Win_ZM_SAddr(h,v,a)         ((h<<6)|(v<<4)|(a>>8)), (BYTE)a
 215      =1  #define OSD_Win_Shadow(a)                       a
 216      =1  #define OSD_Win_Blending(a)                     a
 217      =1  #define OSD_Win_CH_BorderShadow(a)      a
 218      =1  
 219      =1  
 220      =1  #define SetOSDWindowNum(winno)          WriteTW88(TW88_WINNUM, winno-1)
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 23  

 221      =1  
 222      =1  //#define  OSD_Window_Attr(Trans_en,Color,3D_Type,3D_en,W_en)       (((( Trans_en | Color ) | 3D_Type) | 3
             -D_en) | W_en)
 223      =1  #define  OSD_Window_Attr(a,b,c,d,e)                                                                     (((( a | b ) | c) | d) | e)
 224      =1  #define  OSD_WShadow_Attr(W_Shadow_en,Color,Width)                                      W_Shadow_en | Color | Width
 225      =1  //#define  OSD_Blending(en,level)                                                                               en | (level & 0x0f)
 226      =1  //#define  OSD_Ch_Effect(Multi, Effect_En, ShadowBorder, Color)         Multi | Effect_En | ShadowBorder | Color 
             - 
 227      =1  
 228      =1  
 229      =1  struct OSDStrInfo 
 230      =1  {
 231      =1          BYTE    cnt;
 232      =1          WORD    addr;
 233      =1          BYTE    attr;
 234      =1          DWORD   str;
 235      =1  };
 236      =1  /*
 237      =1  struct BarInfo {
 238      =1          struct RegisterInfo BarCnt;
 239      =1          BYTE    winno;
 240      =1          BYTE    xoff;
 241      =1          BYTE    yoff;
 242      =1          BYTE    color;
 243      =1          int             bar_cnt;
 244      =1  };
 245      =1  */
 246      =1  struct FontData {
 247      =1          BYTE    font[27];
 248      =1  } ;
 249      =1  
 250      =1  //====================================================================
 251      =1  //  Internal OSD Function
 252      =1  void CopyCharToOSDRAM_TW88(BYTE Addr, BYTE attr, BYTE ch);
 253      =1  void CopyUDCharToOSDRAM_TW88(BYTE Addr, BYTE attr, BYTE ch);
 254      =1  //BYTE GetOSDWindowWidth_TW88(BYTE winno);
 255      =1  WORD GetOSDWindowSA_TW88(BYTE winno);
 256      =1  void SetOSDWindowX_TW88(BYTE winno, BYTE x);
 257      =1  void SetOSDWindowY_TW88(BYTE winno, BYTE y);
 258      =1  void SetOSDWindowWidth_TW88(BYTE winno, BYTE w);
 259      =1  void SetOSDWindowSA_TW88(BYTE winno, WORD sa);
 260      =1  
 261      =1  void SetOSDItalicsAndUnderline(BYTE italics, BYTE underline);
 262      =1  
 263      =1  void SetOSDHBorderWidth_TW88(BYTE winno, BYTE w);
 264      =1  //BYTE GetOSDWindowColor_TW88(BYTE winno);
 265      =1  void SetOSDWindowColor_TW88(BYTE CCWin, BYTE color);
 266      =1  void EnableOSDRAMAndChangeFont(BYTE type);
 267      =1  void WriteCharToOSDRAM(WORD addr, BYTE ch, BYTE attr);
 268      =1  
 269      =1  
 270      =1  void ShowOSDWindowAll(BYTE on);
 271      =1  void ShowOSDWindow_TW88(BYTE winno, BYTE onoff);
 272      =1  void ClearOSD_TW88(void);
 273      =1  //void CreateOSDWindow_TW88(BYTE winno, BYTE x, BYTE y, BYTE w, BYTE h, WORD sa, BYTE attr);
 274      =1  /*not yet!!
 275      =1  //ljy012304...CC_ADJUST_POS
 276      =1  void SetOSDWindowXS_TW88(BYTE winno, BYTE xs);
 277      =1  void SetOSDWindowYS_TW88(BYTE winno, BYTE ys);
 278      =1  */
 279      =1  
 280      =1  //====================================================================
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 24  

 281      =1  //      OSDMenu Functions
 282      =1  
 283      =1  //--------------------------------------------------------------------
 284      =1  //      Functions used in only Menu
 285      =1  #define         CONVERT_CODE                    0x80
 286      =1  
 287      =1  void InitOSDWindow(BYTE *ptr);
 288      =1  
 289      =1  WORD GetOSDWindowX(BYTE winno);
 290      =1  WORD GetOSDWindowY(BYTE winno);
 291      =1  BYTE CreateOSDWindowOutline(BYTE winno, BYTE w, BYTE color);
 292      =1  void CreateOSDMenuWindow(BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE);
 293      =1  void ClearOSDLine(BYTE winno, BYTE sx, BYTE sy, BYTE cnt, BYTE attr);
 294      =1  void WriteStringToAddr(WORD addr, BYTE *str, BYTE cnt);
 295      =1  void DrawAttrString(WORD addr, BYTE *str, BYTE cnt);
 296      =1  void DrawAttrCnt(WORD addr, BYTE color, BYTE cnt);
 297      =1  void ClearDataCnt(WORD, BYTE);
 298      =1  #define         SetOSDWindowX(A, B)                                                     SetOSDWindowX_TW88(A, B)
 299      =1  #define     SetOSDWindowY(A, B)                                                 SetOSDWindowY_TW88(A, B)
 300      =1  
 301      =1  
 302      =1  //--------------------------------------------------------------------
 303      =1  //      Functions used in Menu and others
 304      =1  #define         ShowOSDWindow(A, B)                                                     ShowOSDWindow_TW88(A, B)
 305      =1  #define     ClearOSD()                                                                  ClearOSD_TW88()
 306      =1  
 307      =1  //================================================================
 308      =1  //      Font
 309      =1  void DownloadUDFont(void);
 310      =1  #ifdef Hs_debug
           =1 void DisplayROMFont(BYTE);
           =1 void DisplayRAMFont(BYTE);
           =1 #endif
 314      =1  void DownloadFont(BYTE cod, CODE_P BYTE *fontdata);
 315      =1  //void DisplayGrid( void );
 316      =1  //void DisplayCone( void );
 317      =1  //void DisplayJapanese( void );
 318      =1  void TestRAMFont( void );
 319      =1  #ifdef BANKING
           =1 void DisplayMGrid( BYTE );
           =1 void DisplayMessage( void );
           =1 void DisplayChinese( void );
           =1 void DisplayJapanese( void );
           =1 void DisplayKorean( void );
           =1 void DisplayGridBank0( BYTE n );
           =1 void DisplayGridBank1( BYTE n );
           =1 #endif
 328      =1  
 329      =1  //================================================================
 330      =1  //      OSD COLOR
 331      =1  void Change_OSDColorLookup(void);
 332      =1  void Reset_OSDColorLookup(void);
 333      =1  
 334      =1  //====================================================================
 335      =1  //                              Conversion
 336      =1  //====================================================================
 337      =1  BYTE utoa(WORD value, BYTE *str, BYTE radix);
 338      =1  BYTE ltoa_K(long value, BYTE *str, BYTE);
 339      =1  BYTE strlen( BYTE *str );
 340      =1  
 341      =1  #define CStrlen(A)                              strlen(A)
 342      =1  
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 25  

 343      =1  void WaitEndofDisplayArea(void);
 344      =1  
 345      =1  #endif  // __OSD_BASIC__
  18          #include "CPU.h"
   1      =1  #ifndef __CPU__
           =1 #define __CPU__
           =1 
           =1 /*
           =1 #ifdef INTERNAL_MCU
           =1 #define I2C_SCL         P2_0
           =1 #else
           =1 #define I2C_SCL         P1_0
           =1 #endif
           =1 #define I2C_SDA         P1_1
           =1 */
           =1 #define I2C_SCL         P1_0
           =1 #define I2C_SDA         P1_1
           =1 #define BUF_MAX         8
           =1 #define DVR_BUF_MAX     30
           =1 
           =1 #ifdef REMO_RC5
           =1 #define EnableRemoconInt()      { RemoDataReady = 0;    EX0 = 1;}
           =1 #endif
           =1 void    InitCPU(void);
           =1 void    InitVars(void);
           =1 void    InitTechwell(void);
           =1 void    main_init (void);
           =1 void    PowerDown( void );
           =1 #if 0
           =1 BYTE    OKSleepTime(void);
           =1 #endif
           =1 #ifdef REMO_RC5
           =1 void    InitForRemo(void);
           =1 #endif
           =1 void    PowerLED(BYTE flag);
           =1 void    Wait_ms(WORD Tms);
           =1 BYTE    TW2835Command(char,char,char,char,char);
           =1 
           =1 #endif
  19          
  20          
  21          #define ID_ADDR         0xc5
  22          #define ID_DATA         0xc6
  23          
  24          extern  BYTE    DebugLevel;
  25          #ifdef  INTERNAL_MCU
              extern  BYTE    xdata * data regTW88;
              #endif
  28          
  29          
  30          /*****************************************************************************/
  31          /*                                                                           */
  32          /*****************************************************************************/
  33          
  34          #define I2C_FAST
  35          
  36          #ifdef I2C_FAST
  37           #define I2Cdelay()
  38          #else
               void I2Cdelay(void)
               {
                       BYTE i;
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 26  

                       for(i=0; i<1; i++){
                       }
               }
              #endif
  46          
  47          #if (defined  QVGA) || (defined WQVGA)
              void I2C_delay(void)
              {
                       BYTE i;
                       for(i=0; i<255; i++){
                              i=i;
                       }
                       for(i=0; i<128; i++){
                              i=i;
                       }
              }
              #else
  59           #define I2C_delay() 
  60          #endif
  61          #if 0
              BYTE I2CWriteData_Wait(BYTE value);
              #endif
  64          #if defined( SUPPORT_PC ) || defined( SUPPORT_DTV )
  65          void WriteADC_TW88(BYTE index, BYTE dat)
  66          {
  67   1              BYTE    page;
  68   1      
  69   1              page = ReadTW88( 0xff );                // save page
  70   1              WriteTW88( 0xff, 0x01 );                // change page1
  71   1              WriteTW88(index, dat);  
  72   1              WriteTW88( 0xff, page );                // restore page
  73   1      
  74   1      }
  75          
  76          BYTE ReadADC_TW88(BYTE index)
  77          {
  78   1              BYTE    page, val;
  79   1      
  80   1              page = ReadTW88( 0xff );                // save page
  81   1              WriteTW88( 0xff, 0x01 );                // change page1
  82   1              val = ReadTW88( index );
  83   1              WriteTW88( 0xff, page );                // restore page
  84   1              
  85   1              return val;
  86   1      }
  87          
  88          
  89          #endif  // SUPPORT_PC
  90          
  91          void WriteEEP(WORD index, BYTE dat)
  92          {
  93   1              BYTE addr;
  94   1      
  95   1              addr = (EEPROMI2CAddress | (index>>7)) & 0xfe;
  96   1      
  97   1              I2CStart();
  98   1              I2CWriteData(addr);
  99   1              I2CWriteData((BYTE)index);
 100   1              I2CWriteData(dat);
 101   1              I2CStop();
 102   1      
 103   1              #ifdef DEBUG_EEP
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 27  

                              dPrintf("Write %02xh to [Adrs(%02xh)Index(%02xh)\r\n", (WORD)dat, (WORD)addr, (WORD)index );
                      #endif
 106   1      
 107   1              delay(2);
 108   1      }
 109          
 110          BYTE ReadEEP(WORD index)
 111          {
 112   1              BYTE val;
 113   1              BYTE addr;
 114   1      
 115   1              addr = (EEPROMI2CAddress | (index>>7)) & 0xfe;
 116   1      
 117   1              val = ReadI2C(addr,(BYTE)index);
 118   1      
 119   1              #ifdef DEBUG_OSD
                              dPrintf("Read [Adrs:%02xh,Index:%02xh] %02xh\r\n", (WORD)addr, (WORD)index, (WORD)val);
                      #endif
 122   1      
 123   1              return val;
 124   1      }
 125          
 126          BYTE ReadI2C(BYTE addr, BYTE index)
 127          {
 128   1              BYTE val;
 129   1      
 130   1              I2CStart();
 131   1              I2CWriteData(addr);
 132   1              I2CWriteData(index);
 133   1              I2CStart();
 134   1              I2CWriteData(addr | 0x01);
 135   1              val = I2CReadData();
 136   1              I2CStop();
 137   1      
 138   1              return val;
 139   1      }
 140          
 141          
 142          void WriteI2C(BYTE addr, BYTE index, BYTE val)
 143          {
 144   1              I2CStart();
 145   1              I2CWriteData(addr);
 146   1              I2CWriteData(index);
 147   1              I2CWriteData(val);
 148   1              I2CStop();
 149   1      }
 150          
 151          void WriteI2CnD(BYTE addr, BYTE index, BYTE val, BYTE cnt)
 152          {
 153   1              BYTE i;
 154   1      
 155   1              I2CStart();
 156   1              I2CWriteData(addr);
 157   1              I2CWriteData(index);
 158   1      
 159   1              for(i=0; i<cnt; i++){
 160   2                      I2CWriteData(val);              //LJY050101
 161   2                      I2C_delay();
 162   2              }
 163   1      
 164   1              I2CStop();
 165   1      }
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 28  

 166          
 167          void WriteI2Cn(BYTE addr, BYTE index, BYTE *val, BYTE cnt)
 168          {
 169   1              BYTE i;
 170   1      
 171   1      
 172   1              I2CStart();
 173   1              I2CWriteData(addr);
 174   1              I2CWriteData(index);
 175   1      
 176   1              for(i=0; i<cnt; i++){
 177   2                      I2CWriteData(*(val+i)); 
 178   2                      I2C_delay();
 179   2              }
 180   1              I2CStop();
 181   1      }
 182          
 183          void WriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt)
 184          {
 185   1              BYTE i;
 186   1      
 187   1              I2CStart();
 188   1              I2CWriteData(addr);
 189   1      
 190   1              for(i=0; i<cnt; i++){
 191   2                      I2CWriteData(*(val+i));         //LJY050101
 192   2              }
 193   1              I2CStop();
 194   1      }
 195          #if 0
              //BYTE I2CWriteData_Wait(BYTE value);
              
              void I2CReadByteMSP(BYTE addr, BYTE index, BYTE *pd, BYTE cnt)
              {
                      BYTE i;
              
                      I2CStart();
                      I2CWriteData_Wait(addr);
                      I2CWriteData(index);
                      for(i=0; i<cnt; i++) {
                              I2CWriteData(*(pd+i));
                      }
                      I2CStart();
                      I2CWriteData_Wait(addr | 0x01);
                      *pd = I2CReadDataWithACK();
                      *(pd+1) = I2CReadData();
              
                      I2CStop();
              }
              
              
              
              /*****************************************************************************/
              /*                                                                           */
              /*****************************************************************************/
              
              BYTE I2CWriteData_Wait(BYTE value)
              {
                      WORD i;
                      BYTE ack;
              
                      for(i=0; i<8; i++, value<<=1) {
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 29  

                              if(value & 0x80) I2C_SDA = 1;
                              else                     I2C_SDA = 0;
                              I2Cdelay();
                              I2C_SCL = 1;    I2Cdelay();
                              I2C_SCL = 0;
                      }
                      I2C_SDA = 1;    I2Cdelay();
                      I2C_SCL = 1;    I2Cdelay();
                      i=0;
                  while(1) {
                              if( I2C_SCL ) break;
                              i++;
                      }
              
                      ack = I2C_SDA;  //I2Cdelay();
                      I2C_SCL = 0;
                      return (1-ack);
              }
              #endif
 247          
 248          #ifndef QVGA
 249          void dd(void)
 250          {
 251   1      }
 252          #else
              #define dd()  I2Cdelay()
              #endif
 255          
 256          void I2CStart()
 257          {
 258   1              I2C_SDA = 1;    dd();
 259   1              I2C_SCL = 1;    dd();
 260   1              I2C_SDA = 0;    dd();
 261   1              I2C_SCL = 0;
 262   1      }
 263          
 264          void I2CStop()
 265          {
 266   1              I2C_SDA = 0;    dd();
 267   1              I2C_SCL = 1;    dd();
 268   1              I2C_SDA = 1;
 269   1      }
 270          
 271          void I2CWriteData(BYTE value)
 272          {
 273   1      /*
 274   1              int i;
 275   1      
 276   1              for(i=0; i<8; i++, value<<=1) {
 277   1                      I2C_SCL = 0;
 278   1                      I2Cdelay();     // HHY 2.04 in special case, it was unstable
 279   1                      if(value & 0x80) I2C_SDA = 1;
 280   1                      else                     I2C_SDA = 0;
 281   1                      I2Cdelay();
 282   1                      I2C_SCL = 1;
 283   1              }
 284   1      */
 285   1      
 286   1              I2C_SCL=0;      I2C_SDA=(value & 0x80)? 1:0;    I2C_SCL=1;      dd();
 287   1              I2C_SCL=0;      I2C_SDA=(value & 0x40)? 1:0;    I2C_SCL=1;      dd();
 288   1              I2C_SCL=0;      I2C_SDA=(value & 0x20)? 1:0;    I2C_SCL=1;      dd();
 289   1              I2C_SCL=0;      I2C_SDA=(value & 0x10)? 1:0;    I2C_SCL=1;      dd();
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 30  

 290   1      
 291   1              I2C_SCL=0;      I2C_SDA=(value & 0x08)? 1:0;    I2C_SCL=1;      dd();
 292   1              I2C_SCL=0;      I2C_SDA=(value & 0x04)? 1:0;    I2C_SCL=1;      dd();
 293   1              I2C_SCL=0;      I2C_SDA=(value & 0x02)? 1:0;    I2C_SCL=1;      dd();
 294   1              I2C_SCL=0;      I2C_SDA=(value & 0x01)? 1:0;    I2C_SCL=1;      dd();
 295   1      
 296   1      
 297   1              I2C_SCL = 0;    // HHY 3.00
 298   1              I2C_SCL = 0;    // HHY 3.00
 299   1              I2C_SCL = 0;    //      I2Cdelay();
 300   1              I2C_SDA = 1;    //      I2Cdelay();
 301   1      
 302   1              I2C_SCL = 1;    // HHY 3.00
 303   1              I2C_SCL = 1;    // HHY 3.00
 304   1              I2C_SCL = 1;    //      I2Cdelay();
 305   1              I2C_SCL = 0;
 306   1      }
 307          
 308          BYTE I2CReadData()
 309          {
 310   1              int i;
 311   1              BYTE value=0;
 312   1      
 313   1              I2C_SDA = 1;    dd();
 314   1              I2C_SCL = 0;
 315   1              
 316   1              for(i=0; i<8; i++) {
 317   2                      I2C_SCL = 1;
 318   2                      value <<= 1;
 319   2                      if(I2C_SDA) value |= 1;
 320   2                      I2C_SCL = 0;
 321   2              }
 322   1              dd();
 323   1              
 324   1              I2C_SCL = 1;    // HHY 3.00
 325   1              I2C_SCL = 1;    // HHY 3.00
 326   1              I2C_SCL = 1;
 327   1              I2C_SCL = 0;
 328   1      
 329   1              return value;
 330   1      
 331   1      }
 332          #if 0
              BYTE I2CReadDataWithACK()
              {
                      int i;
                      BYTE value=0;
              
                      I2C_SDA = 1;    I2Cdelay();
                      I2C_SCL = 0;
              
                      for(i=0; i<8; i++) {
                              I2C_SCL = 1;
                              value <<= 1;
                              if(I2C_SDA) value |= 1;
                              I2C_SCL = 0;
                      }
                      I2C_SDA = 0;    I2Cdelay();             //ack
                      I2C_SCL = 1;    I2Cdelay();
                      I2C_SCL = 0;
              
                      return value;
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 31  

              }
              #endif
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 32  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com002F (BEGIN)
0000         L?0048:
0000         L?0049:
0000 9291              MOV     P1_1,C
0002 D290              SETB    P1_0
0004 120000      R     LCALL   dd
0007 C290              CLR     P1_0
0009 22                RET     
000A         L?0050:
000A 120000      E     LCALL   ?C?PLDPDATA
000D 8E82              MOV     DPL,R6
000F 758300            MOV     DPH,#00H
0012 120000      E     LCALL   ?C?CLDOPTR
0015 FF                MOV     R7,A
0016 22                RET     
0017         L?0051:
0017         L?0052:
0017 EF                MOV     A,R7
0018 F2                MOVX    @R0,A
0019 08                INC     R0
001A ED                MOV     A,R5
001B F2                MOVX    @R0,A
001C 08                INC     R0
001D 22                RET     
             ; FUNCTION Com002F (END)

             ; FUNCTION _WriteADC_TW88 (BEGIN)
                                           ; SOURCE LINE # 65
0000 7800        R     MOV     R0,#LOW index
0002 EF                MOV     A,R7
0003 F2                MOVX    @R0,A
0004 08                INC     R0
0005 ED                MOV     A,R5
0006 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 66
                                           ; SOURCE LINE # 69
0007 7DFF              MOV     R5,#0FFH
0009 7F8A              MOV     R7,#08AH
000B 120000      R     LCALL   _ReadI2C
000E 7800        R     MOV     R0,#LOW page
0010 EF                MOV     A,R7
0011 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 70
0012 7B01              MOV     R3,#01H
0014 7DFF              MOV     R5,#0FFH
0016 7F8A              MOV     R7,#08AH
0018 120000      R     LCALL   _WriteI2C
                                           ; SOURCE LINE # 71
001B 7800        R     MOV     R0,#LOW index
001D E2                MOVX    A,@R0
001E FD                MOV     R5,A
001F 08                INC     R0
0020 E2                MOVX    A,@R0
0021 FB                MOV     R3,A
0022 7F8A              MOV     R7,#08AH
0024 120000      R     LCALL   _WriteI2C
                                           ; SOURCE LINE # 72
0027 7800        R     MOV     R0,#LOW page
0029 E2                MOVX    A,@R0
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 33  

002A FB                MOV     R3,A
002B 7DFF              MOV     R5,#0FFH
002D 7F8A              MOV     R7,#08AH
002F 020000      R     LJMP    _WriteI2C
             ; FUNCTION _WriteADC_TW88 (END)

             ; FUNCTION _ReadADC_TW88 (BEGIN)
                                           ; SOURCE LINE # 76
0000 7800        R     MOV     R0,#LOW index
0002 EF                MOV     A,R7
0003 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 80
0004 7DFF              MOV     R5,#0FFH
0006 7F8A              MOV     R7,#08AH
0008 120000      R     LCALL   _ReadI2C
000B 7800        R     MOV     R0,#LOW page
000D EF                MOV     A,R7
000E F2                MOVX    @R0,A
                                           ; SOURCE LINE # 81
000F 7B01              MOV     R3,#01H
0011 7DFF              MOV     R5,#0FFH
0013 7F8A              MOV     R7,#08AH
0015 120000      R     LCALL   _WriteI2C
                                           ; SOURCE LINE # 82
0018 7800        R     MOV     R0,#LOW index
001A E2                MOVX    A,@R0
001B FD                MOV     R5,A
001C 7F8A              MOV     R7,#08AH
001E 120000      R     LCALL   _ReadI2C
0021 7800        R     MOV     R0,#LOW val
0023 EF                MOV     A,R7
0024 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 83
0025 18                DEC     R0
0026 E2                MOVX    A,@R0
0027 FB                MOV     R3,A
0028 7DFF              MOV     R5,#0FFH
002A 7F8A              MOV     R7,#08AH
002C 120000      R     LCALL   _WriteI2C
                                           ; SOURCE LINE # 85
002F 7800        R     MOV     R0,#LOW val
0031 E2                MOVX    A,@R0
0032 FF                MOV     R7,A
                                           ; SOURCE LINE # 86
0033         ?C0002:
0033 22                RET     
             ; FUNCTION _ReadADC_TW88 (END)

             ; FUNCTION _WriteEEP (BEGIN)
                                           ; SOURCE LINE # 91
0000 7800        R     MOV     R0,#LOW index
0002 EE                MOV     A,R6
0003 F2                MOVX    @R0,A
0004 08                INC     R0
0005 EF                MOV     A,R7
0006 F2                MOVX    @R0,A
0007 08                INC     R0
0008 ED                MOV     A,R5
0009 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 92
                                           ; SOURCE LINE # 95
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 34  

000A 7800        R     MOV     R0,#LOW index
000C E2                MOVX    A,@R0
000D FE                MOV     R6,A
000E 08                INC     R0
000F E2                MOVX    A,@R0
0010 7807              MOV     R0,#07H
0012         ?C0044:
0012 CE                XCH     A,R6
0013 C3                CLR     C
0014 13                RRC     A
0015 CE                XCH     A,R6
0016 13                RRC     A
0017 D8F9              DJNZ    R0,?C0044
0019 44A0              ORL     A,#0A0H
001B 54FE              ANL     A,#0FEH
001D 7800        R     MOV     R0,#LOW addr
001F F2                MOVX    @R0,A
                                           ; SOURCE LINE # 97
0020 120000      R     LCALL   I2CStart
                                           ; SOURCE LINE # 98
0023 7800        R     MOV     R0,#LOW addr
0025 E2                MOVX    A,@R0
0026 FF                MOV     R7,A
0027 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 99
002A 7800        R     MOV     R0,#LOW index
002C 08                INC     R0
002D E2                MOVX    A,@R0
002E FF                MOV     R7,A
002F 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 100
0032 7800        R     MOV     R0,#LOW dat
0034 E2                MOVX    A,@R0
0035 FF                MOV     R7,A
0036 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 101
0039 120000      R     LCALL   I2CStop
                                           ; SOURCE LINE # 107
003C 7F02              MOV     R7,#02H
003E 020000      E     LJMP    _delay
             ; FUNCTION _WriteEEP (END)

             ; FUNCTION _ReadEEP (BEGIN)
                                           ; SOURCE LINE # 110
;---- Variable 'index' assigned to Register 'R4/R5' ----
0000 AD07              MOV     R5,AR7
0002 AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 111
                                           ; SOURCE LINE # 115
0004 ED                MOV     A,R5
0005 7807              MOV     R0,#07H
0007         ?C0045:
0007 CE                XCH     A,R6
0008 C3                CLR     C
0009 13                RRC     A
000A CE                XCH     A,R6
000B 13                RRC     A
000C D8F9              DJNZ    R0,?C0045
000E 44A0              ORL     A,#0A0H
0010 54FE              ANL     A,#0FEH
0012 FF                MOV     R7,A
;---- Variable 'addr' assigned to Register 'R7' ----
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 35  

                                           ; SOURCE LINE # 117
0013 120000      R     LCALL   _ReadI2C
;---- Variable 'val' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 123
                                           ; SOURCE LINE # 124
0016         ?C0004:
0016 22                RET     
             ; FUNCTION _ReadEEP (END)

             ; FUNCTION _ReadI2C (BEGIN)
                                           ; SOURCE LINE # 126
0000 7800        R     MOV     R0,#LOW addr
0002 EF                MOV     A,R7
0003 F2                MOVX    @R0,A
0004 08                INC     R0
0005 ED                MOV     A,R5
0006 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 127
                                           ; SOURCE LINE # 130
0007 120000      R     LCALL   I2CStart
                                           ; SOURCE LINE # 131
000A 7800        R     MOV     R0,#LOW addr
000C E2                MOVX    A,@R0
000D FF                MOV     R7,A
000E 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 132
0011 7800        R     MOV     R0,#LOW index
0013 E2                MOVX    A,@R0
0014 FF                MOV     R7,A
0015 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 133
0018 120000      R     LCALL   I2CStart
                                           ; SOURCE LINE # 134
001B 7800        R     MOV     R0,#LOW addr
001D E2                MOVX    A,@R0
001E 4401              ORL     A,#01H
0020 FF                MOV     R7,A
0021 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 135
0024 120000      R     LCALL   I2CReadData
0027 7800        R     MOV     R0,#LOW val
0029 EF                MOV     A,R7
002A F2                MOVX    @R0,A
                                           ; SOURCE LINE # 136
002B 120000      R     LCALL   I2CStop
                                           ; SOURCE LINE # 138
002E 7800        R     MOV     R0,#LOW val
0030 E2                MOVX    A,@R0
0031 FF                MOV     R7,A
                                           ; SOURCE LINE # 139
0032         ?C0005:
0032 22                RET     
             ; FUNCTION _ReadI2C (END)

             ; FUNCTION _WriteI2C (BEGIN)
                                           ; SOURCE LINE # 142
0000 7800        R     MOV     R0,#LOW addr
0002 120000      R     LCALL   L?0051
0005 EB                MOV     A,R3
0006 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 143
                                           ; SOURCE LINE # 144
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 36  

0007 120000      R     LCALL   I2CStart
                                           ; SOURCE LINE # 145
000A 7800        R     MOV     R0,#LOW addr
000C E2                MOVX    A,@R0
000D FF                MOV     R7,A
000E 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 146
0011 7800        R     MOV     R0,#LOW index
0013 E2                MOVX    A,@R0
0014 FF                MOV     R7,A
0015 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 147
0018 7800        R     MOV     R0,#LOW val
001A E2                MOVX    A,@R0
001B FF                MOV     R7,A
001C 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 148
001F 020000      R     LJMP    I2CStop
             ; FUNCTION _WriteI2C (END)

             ; FUNCTION _WriteI2CnD (BEGIN)
                                           ; SOURCE LINE # 151
0000 7800        R     MOV     R0,#LOW addr
0002 120000      R     LCALL   L?0051
0005 EB                MOV     A,R3
0006 F2                MOVX    @R0,A
                                           ; SOURCE LINE # 152
                                           ; SOURCE LINE # 155
0007 120000      R     LCALL   I2CStart
                                           ; SOURCE LINE # 156
000A 7800        R     MOV     R0,#LOW addr
000C E2                MOVX    A,@R0
000D FF                MOV     R7,A
000E 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 157
0011 7800        R     MOV     R0,#LOW index
0013 E2                MOVX    A,@R0
0014 FF                MOV     R7,A
0015 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 159
0018 E4                CLR     A
0019 7800        R     MOV     R0,#LOW i
001B F2                MOVX    @R0,A
001C         ?C0007:
001C 7800        R     MOV     R0,#LOW cnt
001E E2                MOVX    A,@R0
001F FF                MOV     R7,A
0020 08                INC     R0
0021 E2                MOVX    A,@R0
0022 C3                CLR     C
0023 9F                SUBB    A,R7
0024 500E              JNC     ?C0008
                                           ; SOURCE LINE # 160
0026 7800        R     MOV     R0,#LOW val
0028 E2                MOVX    A,@R0
0029 FF                MOV     R7,A
002A 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 162
002D 7800        R     MOV     R0,#LOW i
002F E2                MOVX    A,@R0
0030 04                INC     A
0031 F2                MOVX    @R0,A
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 37  

0032 80E8              SJMP    ?C0007
0034         ?C0008:
                                           ; SOURCE LINE # 164
0034 020000      R     LJMP    I2CStop
             ; FUNCTION _WriteI2CnD (END)

             ; FUNCTION _WriteI2Cn (BEGIN)
                                           ; SOURCE LINE # 167
0000 7800        R     MOV     R0,#LOW addr
0002 120000      R     LCALL   L?0052
0005 120000      E     LCALL   ?C?PSTPDATA
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 172
0008 120000      R     LCALL   I2CStart
                                           ; SOURCE LINE # 173
000B 7800        R     MOV     R0,#LOW addr
000D E2                MOVX    A,@R0
000E FF                MOV     R7,A
000F 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 174
0012 7800        R     MOV     R0,#LOW index
0014 E2                MOVX    A,@R0
0015 FF                MOV     R7,A
0016 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 176
0019 E4                CLR     A
001A 7800        R     MOV     R0,#LOW i
001C F2                MOVX    @R0,A
001D         ?C0011:
001D 7800        R     MOV     R0,#LOW cnt
001F E2                MOVX    A,@R0
0020 FF                MOV     R7,A
0021 08                INC     R0
0022 E2                MOVX    A,@R0
0023 FE                MOV     R6,A
0024 C3                CLR     C
0025 9F                SUBB    A,R7
0026 500F              JNC     ?C0012
                                           ; SOURCE LINE # 177
0028 7800        R     MOV     R0,#LOW val
002A 120000      R     LCALL   L?0050
002D 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 179
0030 7800        R     MOV     R0,#LOW i
0032 E2                MOVX    A,@R0
0033 04                INC     A
0034 F2                MOVX    @R0,A
0035 80E6              SJMP    ?C0011
0037         ?C0012:
                                           ; SOURCE LINE # 180
0037 020000      R     LJMP    I2CStop
             ; FUNCTION _WriteI2Cn (END)

             ; FUNCTION _WriteI2Cn_ (BEGIN)
                                           ; SOURCE LINE # 183
0000 7800        R     MOV     R0,#LOW addr
0002 EF                MOV     A,R7
0003 F2                MOVX    @R0,A
0004 08                INC     R0
0005 120000      E     LCALL   ?C?PSTPDATA
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 187
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 38  

0008 120000      R     LCALL   I2CStart
                                           ; SOURCE LINE # 188
000B 7800        R     MOV     R0,#LOW addr
000D E2                MOVX    A,@R0
000E FF                MOV     R7,A
000F 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 190
0012 E4                CLR     A
0013 7800        R     MOV     R0,#LOW i
0015 F2                MOVX    @R0,A
0016         ?C0015:
0016 7800        R     MOV     R0,#LOW cnt
0018 E2                MOVX    A,@R0
0019 FF                MOV     R7,A
001A 08                INC     R0
001B E2                MOVX    A,@R0
001C FE                MOV     R6,A
001D C3                CLR     C
001E 9F                SUBB    A,R7
001F 500F              JNC     ?C0016
                                           ; SOURCE LINE # 191
0021 7800        R     MOV     R0,#LOW val
0023 120000      R     LCALL   L?0050
0026 120000      R     LCALL   _I2CWriteData
                                           ; SOURCE LINE # 192
0029 7800        R     MOV     R0,#LOW i
002B E2                MOVX    A,@R0
002C 04                INC     A
002D F2                MOVX    @R0,A
002E 80E6              SJMP    ?C0015
0030         ?C0016:
                                           ; SOURCE LINE # 193
0030 020000      R     LJMP    I2CStop
             ; FUNCTION _WriteI2Cn_ (END)

             ; FUNCTION dd (BEGIN)
                                           ; SOURCE LINE # 249
                                           ; SOURCE LINE # 250
                                           ; SOURCE LINE # 251
0000 22                RET     
             ; FUNCTION dd (END)

             ; FUNCTION I2CStart (BEGIN)
                                           ; SOURCE LINE # 256
                                           ; SOURCE LINE # 257
                                           ; SOURCE LINE # 258
0000 D291              SETB    P1_1
0002 120000      R     LCALL   dd
                                           ; SOURCE LINE # 259
0005 D290              SETB    P1_0
0007 120000      R     LCALL   dd
                                           ; SOURCE LINE # 260
000A C291              CLR     P1_1
000C 120000      R     LCALL   dd
                                           ; SOURCE LINE # 261
000F C290              CLR     P1_0
                                           ; SOURCE LINE # 262
0011 22                RET     
             ; FUNCTION I2CStart (END)

             ; FUNCTION I2CStop (BEGIN)
                                           ; SOURCE LINE # 264
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 39  

                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
0000 C291              CLR     P1_1
0002 120000      R     LCALL   dd
                                           ; SOURCE LINE # 267
0005 D290              SETB    P1_0
0007 120000      R     LCALL   dd
                                           ; SOURCE LINE # 268
000A D291              SETB    P1_1
                                           ; SOURCE LINE # 269
000C 22                RET     
             ; FUNCTION I2CStop (END)

             ; FUNCTION _I2CWriteData (BEGIN)
                                           ; SOURCE LINE # 271
;---- Variable 'value' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 272
                                           ; SOURCE LINE # 286
0000 C290              CLR     P1_0
0002 EF                MOV     A,R7
0003 30E703            JNB     ACC.7,?C0022
0006 D3                SETB    C
0007 8001              SJMP    ?C0023
0009         ?C0022:
0009 C3                CLR     C
000A         ?C0023:
                                           ; SOURCE LINE # 287
000A 120000      R     LCALL   L?0048
000D EF                MOV     A,R7
000E 30E603            JNB     ACC.6,?C0024
0011 D3                SETB    C
0012 8001              SJMP    ?C0025
0014         ?C0024:
0014 C3                CLR     C
0015         ?C0025:
                                           ; SOURCE LINE # 288
0015 120000      R     LCALL   L?0048
0018 EF                MOV     A,R7
0019 30E503            JNB     ACC.5,?C0026
001C D3                SETB    C
001D 8001              SJMP    ?C0027
001F         ?C0026:
001F C3                CLR     C
0020         ?C0027:
                                           ; SOURCE LINE # 289
0020 120000      R     LCALL   L?0049
0023 EF                MOV     A,R7
0024 30E403            JNB     ACC.4,?C0028
0027 D3                SETB    C
0028 8001              SJMP    ?C0029
002A         ?C0028:
002A C3                CLR     C
002B         ?C0029:
                                           ; SOURCE LINE # 291
002B 120000      R     LCALL   L?0049
002E EF                MOV     A,R7
002F 30E303            JNB     ACC.3,?C0030
0032 D3                SETB    C
0033 8001              SJMP    ?C0031
0035         ?C0030:
0035 C3                CLR     C
0036         ?C0031:
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 40  

                                           ; SOURCE LINE # 292
0036 120000      R     LCALL   L?0049
0039 EF                MOV     A,R7
003A 30E203            JNB     ACC.2,?C0032
003D D3                SETB    C
003E 8001              SJMP    ?C0033
0040         ?C0032:
0040 C3                CLR     C
0041         ?C0033:
                                           ; SOURCE LINE # 293
0041 120000      R     LCALL   L?0049
0044 EF                MOV     A,R7
0045 30E103            JNB     ACC.1,?C0034
0048 D3                SETB    C
0049 8001              SJMP    ?C0035
004B         ?C0034:
004B C3                CLR     C
004C         ?C0035:
                                           ; SOURCE LINE # 294
004C 120000      R     LCALL   L?0049
004F EF                MOV     A,R7
0050 30E003            JNB     ACC.0,?C0036
0053 D3                SETB    C
0054 8001              SJMP    ?C0037
0056         ?C0036:
0056 C3                CLR     C
0057         ?C0037:
                                           ; SOURCE LINE # 297
0057 120000      R     LCALL   L?0049
                                           ; SOURCE LINE # 298
005A C290              CLR     P1_0
                                           ; SOURCE LINE # 299
005C C290              CLR     P1_0
                                           ; SOURCE LINE # 300
005E D291              SETB    P1_1
                                           ; SOURCE LINE # 302
0060 D290              SETB    P1_0
                                           ; SOURCE LINE # 303
0062 D290              SETB    P1_0
                                           ; SOURCE LINE # 304
0064 D290              SETB    P1_0
                                           ; SOURCE LINE # 305
0066 C290              CLR     P1_0
                                           ; SOURCE LINE # 306
0068 22                RET     
             ; FUNCTION _I2CWriteData (END)

             ; FUNCTION I2CReadData (BEGIN)
                                           ; SOURCE LINE # 308
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 311
;---- Variable 'value' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 313
0002 D291              SETB    P1_1
0004 120000      R     LCALL   dd
                                           ; SOURCE LINE # 314
0007 C290              CLR     P1_0
                                           ; SOURCE LINE # 316
;---- Variable 'i' assigned to Register 'R4/R5' ----
0009 FD                MOV     R5,A
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 41  

000A FC                MOV     R4,A
000B         ?C0039:
                                           ; SOURCE LINE # 317
000B D290              SETB    P1_0
                                           ; SOURCE LINE # 318
000D EF                MOV     A,R7
000E 25E0              ADD     A,ACC
0010 FF                MOV     R7,A
                                           ; SOURCE LINE # 319
0011 309103            JNB     P1_1,?C0042
0014 4401              ORL     A,#01H
0016 FF                MOV     R7,A
0017         ?C0042:
                                           ; SOURCE LINE # 320
0017 C290              CLR     P1_0
                                           ; SOURCE LINE # 321
0019 0D                INC     R5
001A BD0001            CJNE    R5,#00H,?C0046
001D 0C                INC     R4
001E         ?C0046:
001E ED                MOV     A,R5
001F 6408              XRL     A,#08H
0021 4C                ORL     A,R4
0022 70E7              JNZ     ?C0039
0024         ?C0040:
                                           ; SOURCE LINE # 322
0024 120000      R     LCALL   dd
                                           ; SOURCE LINE # 324
0027 D290              SETB    P1_0
                                           ; SOURCE LINE # 325
0029 D290              SETB    P1_0
                                           ; SOURCE LINE # 326
002B D290              SETB    P1_0
                                           ; SOURCE LINE # 327
002D C290              CLR     P1_0
                                           ; SOURCE LINE # 329
                                           ; SOURCE LINE # 331
002F         ?C0043:
002F 22                RET     
             ; FUNCTION I2CReadData (END)

C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 42  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_WriteI2CnD. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
  index. . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0001H  1
  val. . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0002H  1
  cnt. . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0003H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0004H  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
CAM_R. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
CAM_BAR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ABR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_CAR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ACR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_CBR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_BCR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P1_0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
_delay . . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P1_1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
FontData . . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  27
  font . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  27
_WriteI2Cn_. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
  val. . . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0001H  3
  cnt. . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0004H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0005H  1
AVMode . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SourceModeType . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CAM_NUM. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_RAB_H. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
OSDStrInfo . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  8
  cnt. . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
  attr . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  str. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
CAM_BA . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_AB . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CAM_CA . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_AC . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_BC . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_CB . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
I2CReadData. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0004H  2
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SourceModeTypeEnum . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
struct_IdName. . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  17
  Id . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Name . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0001H  16
_WriteI2Cn . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
  index. . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0001H  1
  val. . . . . . . . . . . . . . . . .  AUTO     PDATA  PTR      0002H  3
  cnt. . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0005H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0006H  1
CAM_RAB_T. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_ReadI2C . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 43  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  index. . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0001H  1
  val. . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0002H  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
_ReadADC_TW88. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  index. . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
  page . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0001H  1
  val. . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0002H  1
CAM_AR . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_BR . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_RB . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_CR . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
dd . . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_I2CWriteData. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
Register . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_WriteI2C. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
  index. . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0001H  1
  val. . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0002H  1
I2CStart . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_WriteADC_TW88 . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  index. . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0000H  1
  dat. . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0001H  1
  page . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0002H  1
RegisterInfo . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  INT      0004H  2
_ReadEEP . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  index. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  val. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  addr . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
CAM_QUAD . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
VGAMode. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
I2CStop. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_WriteEEP. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  index. . . . . . . . . . . . . . . .  AUTO     PDATA  U_INT    0000H  2
  dat. . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0002H  1
  addr . . . . . . . . . . . . . . . .  AUTO     PDATA  U_CHAR   0003H  1
SEQ. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LongRegisterInfo . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
CAM_ABR_T3 . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ABR_T4 . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_A. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_B. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_C. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_D. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_CAB. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_BAC. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ABC. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    654    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V8.16   I2C                                                                   03/04/2011 15:51:16 PAGE 44  

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----      34
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
