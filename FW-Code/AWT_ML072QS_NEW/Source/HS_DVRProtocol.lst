C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE HS_DVRPROTOCOL
OBJECT MODULE PLACED IN .\Output\HS_DVRProtocol.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE HS_DVRProtocol.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Include\) DEBUG 
                    -OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PRINT(.\Source\HS_DVRProtocol.lst) TABS(2) OBJECT(.\Output\HS_DVRProtocol.obj)

line level    source

   1          //=====================================================================
   2          //  Work file: Hs_Protocol.c
   3          //
   4          //  This file is generating the HS protocol for DVR .
   5          //
   6          //                                
   7          //=====================================================================
   8          //******************************************************************************
   9          //  I N C L U D E    F I L E S
  10          //******************************************************************************
  11          #include "Config.h"
   1      =1  /*****************************************************************************/
   2      =1  /*                           System Configurations                           */
   3      =1  /*              rev 0.10 include auto test             */
   4      =1  // 0.11 change DTV, PC input initial download data correct for Charge Pump
   5      =1  // 0.12 correct phase measurement routine '>>3'
   6      =1  // 0.13 enable function for SPI control... only EXT MCU case
   7      =1  // 0.14 corrected PC measurement......
   8      =1  // 0.0a test function only for CVBS, SVIDEO
   9      =1  // 0.15 corrected DTV scaler setting for panel resolutions
  10      =1  // 0.0b panel for AND 640x480 TICON panel
  11      =1  // 0.16 corrected COMPONENT scaler setting for panel resolutions  11/21/2007
  12      =1  // 0.0c automatic chip test
  13      =1  // 0.17 add monitor function, osd grid for writing grid
  14      =1  // 0.18 add component, dtv pc for analogpanel, 12/06/2007
  15      =1  // 0.19 correct pal input for CES, 12/20/2007
  16      =1  // 0.1a CCFL control, 12/28/2007
  17      =1  // 0.19 Multi Grid for Banking on Internal MCU  01/17/2008
  18      =1  // 0.20 CCFL contol for backlight brightness  01/21/2008
  19      =1  // 0.21 CCFL contol for backlight brightness  01/25/2008
  20      =1  // 0.22 phase setting 02/07/2008
  21      =1  // 0.221 display input correction 04/03/2008
  22      =1  // 0.23 PC, DTV mode, no signal display
  23      =1  // 0.24 PC Auto Color adjustment
  24      =1  // 0.25 revised PC Auto Clock adjustment - find divide number and phase
  25      =1  // 0.26 Digital RGB for TW8826
  26      =1  // 0.27 Correct LVDS control          08/22/2008
  27      =1  // 0.28 Add WSVGA resolution          10/23/2008
  28      =1  // 0.29 Add NEW GRID              11/14/2008
  29      =1  // 0.30 Fix DTV input             12/10/2008
  30      =1  // 0.31 Add 1080i23, 24, 25A, 25B       01/20/2009
  31      =1  // 0.32 TCON setting FIX all mode       01/22/2009
  32      =1  // 0.33 autodetect is auto on/off by dip sw1  02/02/2009
  33      =1  // 0.34 Fix autocolor function and clamp position 02/08/2009
  34      =1  /*****************************************************************************/
  35      =1  #ifndef __CONFIG_H__
  36      =1  #define __CONFIG_H__
  37      =1  
  38      =1  //#define INTERNAL_MCU -- defined by Project Compiler session
  39      =1  #define   HS        
  40      =1  //#define   E_Wintek  
  41      =1  //#define   AWT 
  42      =1  //#define Holtz
  43      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 2   

  44      =1  //#define QUAD
  45      =1  
  46      =1  #ifdef QUAD
           =1   #define AWT_ML072Q  //Pinchi 20150827 disable for HTRV
           =1 //  #define HTRV  //Pinchi 20140902 disable for AWT ML072Q
           =1 #else
  50      =1    #define AWT_ML072S
  51      =1  #endif
  52      =1  
  53      =1  //--------------------------------------------------
  54      =1  //              Common Feature Define
  55      =1  //--------------------------------------------------
  56      =1  //#define FIRST_RUN_FROM_AC  //Pinchi 20150831 disable for Screen re-setting by Set4WideScreen()  //Pinchi
             - 20141029 add
  57      =1  #define SUPPORT_ML072Q_AUTO_DAY_NIGHT  //Pinchi 20150825 add for function define
  58      =1  #define SUPPORT_TRIGGER_EXIT_MENU  //Pinchi 20150827 add for exit OSD Menu by CAM trigger
  59      =1  #define SUPPORT_AC_ON_NORMAL_SCREEN  //Pinchi 20150901 add to set 4:3 screen when AC on
  60      =1  
  61      =1  #define FIX_DISPLAY_OFF_TRIGGER_ISSUE  //Pinchi 20150908 add to fix [Display] set OFF and trigger release 
             -then trigger again during display info the CAM will change from trigger CH to original CH
  62      =1  #define FIX_EXIT_STANDBY_NO_AUDIO  //Pinchi 20150908 add to fix no audio output when exit Standby mode
  63      =1  #ifdef AWT_ML072Q
           =1 #define FIX_2835_SCREEN_NOISE  //Pinchi 20160929 add to fix the screen noise of TW2835 by change DDR to ma
             -ke clock shift
           =1 #endif
  66      =1  
  67      =1  #define SUPPORT_NEW_TRIGGER_FUNCTION  /////修改新的Trigger方式減少trigger polling 時間 add by ryan@2018012
             -4
  68      =1  
  69      =1  //#define AWT_ML072QS_MSG  //Pinchi 20140925 add
  70      =1  //#define REDUCE_DELAY_TIME  //Pinchi 20141029 add
  71      =1  //#define DISPLAY_TECHWELL_LOGO  //Pinchi 2050903 add to disable the Techwell logo
  72      =1  
  73      =1  //#define SUPPORT_SVIDEO                     //andy Awt 20090914
  74      =1  //#define SUPPORT_COMPONENT     // support component analog to decoder//andy Awt 20090914
  75      =1  //#define SUPPORT_DTV           // support DTV input through component( to ADC ).//andy Awt 20090914
  76      =1  //#define SUPPORT_PC        // support PC function
  77      =1  //#define SUPPORT_DVI       // support DVI input
  78      =1  //#define SUPPORT_SDCARD
  79      =1  
  80      =1  #define SUPPORT_2835_CLK_TUNE_BACK_DOOR  //Pinchi 20160913 add to fine tune TW2835 clock by hot key
  81      =1  //#define SUPPORT_DISPLAY_TEST_VERSION  //Pinchi 20150929 add to display test software version on OSD
  82      =1  
  83      =1  //--------------------------------------------------
  84      =1  //              Model Feature Define
  85      =1  //--------------------------------------------------
  86      =1  #if (defined AWT_ML072Q) || (defined AWT_ML072S)
  87      =1  #define AWT_ML072QS_FW_RULE  //Pinchi 20140902 add
  88      =1  //#define AWT_NEW_SLIM_MODEL  //Pinchi 20150203 add for AWT new slim model
  89      =1  #define AWT_NO_SIGNAL_MSG  //Pinchi 20150319 add for display "NO VIDEO SIGNAL" by AWT request of 20150302
  90      =1  #define AWT_TW2835_DRAW_T_ICON  //Pinchi 20150415 add to draw T icon by TW2835 when CAM C trigger
  91      =1  #define SUPPORT_AC_ON_REDUCE_TIME  //Pinchi 20150903 add to reduce Power time when AC on
  92      =1  
  93      =1  //#define SUPPORT_TRIGGER_RELEASE_DELAY  //Pinchi 20150908 add to support delay time when CAM trigger rele
             -ase
  94      =1  
  95      =1  typedef enum  //Pinchi 20150326 add
  96      =1  {
  97      =1       LAST_TRIG_NON =  0x00,
  98      =1       LAST_TRIG_LEFT =   0x01,
  99      =1       LAST_TRIG_RIGHT =  0x02,
 100      =1       LAST_TRIG_REVERSE =0x03,
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 3   

 101      =1       LAST_TRIG_CAMC =   0x04,
 102      =1  
 103      =1  } AWT_LAST_TRIGGER;
 104      =1  
 105      =1  #endif
 106      =1  
 107      =1  
 108      =1  #ifdef HTRV  //Pinchi 20150825 add
           =1 #define HTRV_ML072Q_FW_RULE  //Pinchi 20150827 add
           =1 #define HTRV_REDUCE_SCREEN_CHANGE  //Pinchi 20150828 add to reduce screen double change
           =1 
           =1 #if 0  //Pinchi 20151209 add to remove 4:3 screen by HTRV request of 20151209
           =1 #define HTRV_SUPPORT_4_3_SCREEN
           =1 #else
           =1 #undef SUPPORT_AC_ON_NORMAL_SCREEN  //Pinchi 20151210 add
           =1 #endif
           =1 
           =1 #endif
 119      =1  
 120      =1  //#define SUPPORT_RS485
 121      =1  //-----------------------------------------------------------------------------
 122      =1  //    Firmware Version
 123      =1  //-----------------------------------------------------------------------------
 124      =1  #ifdef HTRV  //Pinchi 20150907 add
           =1 //#define FWVER     0x200 // Rev 2.00
           =1 //#define FWVER     0x210   // Rev 2.1  //Pinchi 20151209 update version for HTRV request to remove 4:3 scree
             -n
           =1 //#define FWVER     0x220   // Rev 2.2  //Pinchi 20160929 change for V2.2
           =1 #define FWVER     0x230     //Rev 2.3    ryan@20170727 update version by Encoder switches零件 EOL更換
           =1 #else
 130      =1  #define FWVER     0x210   // Rev 0.14
 131      =1  #endif
 132      =1  
 133      =1  //-----------------------------------------------------------------------------
 134      =1  //    Compiler
 135      =1  //-----------------------------------------------------------------------------
 136      =1  #define KEILC           // Keil C 5.0
 137      =1  //-----------------------------------------------------------------------------
 138      =1  //    MPU Clock
 139      =1  //-----------------------------------------------------------------------------
 140      =1  #ifndef INTERNAL_MCU
 141      =1  //#define CLOCK_11M         // 11.0592MHz
 142      =1  #define CLOCK_22M         // 22.1184MHz
 143      =1  #else                 // INTERNAL_MCU
           =1 #define CLOCK_27M         // 27MHz
           =1 #define REG_START_ADDRESS 0xc000    // register start 0xc000, for page0, 0xc100-page1 
           =1 #endif
 147      =1  //-----------------------------------------------------------------------------
 148      =1  //    TW88 Version
 149      =1  //-----------------------------------------------------------------------------
 150      =1  #define TW8816   ///AWT TW8806 change to TW8816 platform //ryan@20170921
 151      =1  //-----------------------------------------------------------------------------
 152      =1  //-----------------------------------------------------------------------------
 153      =1  //    Options for Backlight control
 154      =1  //-----------------------------------------------------------------------------
 155      =1  //#define BACKLIGHT_CCFL
 156      =1  //#define BACKLIGHT_LED
 157      =1  #define BACKLIGHT_PWM
 158      =1  
 159      =1  //-----------------------------------------------------------------------------
 160      =1  //    Panel Resolution
 161      =1  //-----------------------------------------------------------------------------
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 4   

 162      =1  // ---- Select Default Panel
 163      =1  //
 164      =1  //#define UXGA            // 1600 x 1200
 165      =1  //#define SXGA              // 1280 x 1024
 166      =1  //#define XGA  // 1024 x 768
 167      =1  #ifdef XGA
           =1   #define LVDS          
           =1   #define PWIDTH  1024
           =1   #define PHEIGHT 768
           =1 #endif
 172      =1  //#define SVGA            //  800 x 600
 173      =1  //#define VGA             //  640 x 480
 174      =1  #ifdef VGA
           =1   #define PWIDTH  640
           =1   #define PHEIGHT 480
           =1   //#define HITACHI_640_B_160   //--> 640 x 160
           =1   #define AND_640_480
           =1 #endif
 180      =1  //#define WXGA            // 1280 x 768 (15:9) // 1366 x 768 (16:9)
 181      =1  #ifdef WXGA
           =1     //#define WX_SHARP_LQ106K1LA
           =1   #define PWIDTH  1280
           =1   #define PHEIGHT 768
           =1 #endif
 186      =1  //#define WSVGA           // 1024 x 600 *** only video mode
 187      =1  #ifdef WSVGA
           =1   #define PWIDTH  1024
           =1   #define PHEIGHT 600
           =1   #define UNIDEN_1024_600
           =1 #endif
 192      =1  #define WVGA            //  800 x 480
 193      =1  #ifdef WVGA
 194      =1    #define PWIDTH  800
 195      =1    #define PHEIGHT 480//600
 196      =1    // If WVGA, you have to select panel.
 197      =1    //#define AU_10INCH
 198      =1    //#define WVGA_TPO
 199      =1    //#define SAMSUNG_10INCH
 200      =1    //#define SAMSUNG_TICONLESS_10INCH
 201      =1    //#define SHARP_TICONLESS_7INCH
 202      =1    //#define AU_TICONLESS_7INCH
 203      =1    //#define AU_G084SN05V8_8_4INCH 
 204      =1    #define HSD070IDW1_7INCH
 205      =1    //#define INNOLUX_AT080TN03
 206      =1    //#define AU_TICONLESS_7INCH_CCFL
 207      =1    //#define CMO     // CHIMEI panel
 208      =1    //#define AU_TICONLESS_10INCH
 209      =1    //#define HITACHI_T01
 210      =1    //#define HITACHI_TX23D12
 211      =1    //#define HITACHI_TX18D24
 212      =1    //#define HITACHI_TX18D16
 213      =1    //#define TMD_LTA070A320F
 214      =1    //#define TMD_LTA080B
 215      =1  #endif  //WVGA
 216      =1  //#define HVGA            //  480 x 320
 217      =1  //#define QVGA            //  320 x 240 *** only video mode
 218      =1  #ifdef QVGA
           =1   #define PWIDTH  320
           =1   #define PHEIGHT 240
           =1   //#define HITACHI_TX09D73
           =1   //#define AU_DELTARGB
           =1   //#define SHARP_LQ050Q5DR01
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 5   

           =1   //#define SHARP_LQ035
           =1   //#define TMD
           =1 #endif
 227      =1  
 228      =1  //#define WQVGA           //  480 x 234 *** only video mode
 229      =1  #ifdef WQVGA
           =1   #define PWIDTH  480
           =1   #define PHEIGHT 240
           =1   // If WQVGA, you have to select panel 
           =1     #define ANALOG_7INCH
           =1   //#define PWIDTH  400
           =1   //#define PHEIGHT 240
           =1   //#define SHARP_LQ043T3DX02   //  400 x 237
           =1   //#define LG_ANALOG
           =1   //#define TMD_ANALOG        //TMD_LTA05B352A
           =1   //#define T_51945GD       // Optorex Panel
           =1 #endif  // WQVGA
 241      =1  
 242      =1  //if LVDS pannel disable TICONLESS
 243      =1  
 244      =1  //-----------------------------------------------------------------------------
 245      =1  //---- Add Support One more panel with DIPSW#1
 246      =1  //---- Ex. Add Analog AU 7" Panel with Default Panel for evalution
 247      =1  //#define ADD_ANALOGPANEL   // Added Analog panel(AU7") from default set panel(expect WQVGA) with DIP #1 sw
             -itch.(DIP#1=L:ANALOG, H:DEFAULT)
 248      =1                // It can't support WQVGA and ADD_ANALOGPANEL same time!!
 249      =1    //#define ADD_ANALOG_7INCH
 250      =1    //#define ADD_TMD_LTA05B352A
 251      =1                    
 252      =1  //---- Support Wide panel function
 253      =1  #if (defined WXGA) || (defined WSVGA) || (defined WVGA) || (defined WQVGA)
 254      =1  #if 0///ryan@20180115//mask for NTSC sharpness issue
           =1 #define WIDE_SCREEN         // Can support 4 display mode, i.e. Normal, Wide, Full, Zoom
           =1 #endif
 257      =1  #endif                // Tested panasonic WVGA panel.
 258      =1  
 259      =1  //-----------------------------------------------------------------------------
 260      =1  //    Panel Vendor Specific
 261      =1  //-----------------------------------------------------------------------------
 262      =1  
 263      =1  //-----------------------------------------------------------------------------
 264      =1  //    TV Tuner
 265      =1  //-----------------------------------------------------------------------------
 266      =1  #define PHILIPS       0
 267      =1  #define ALPS        1   // ALPS, LG
 268      =1  #define TEMIC       2
 269      =1  #define TVAVA       3
 270      =1  #define LGTUNER       4
 271      =1  #define SAMSUNGMUTITUNER  5
 272      =1  
 273      =1  #define TVTunerDevice   4
 274      =1  //-----------------------------------------------------------------------------
 275      =1  //    IR Remote Controller Type
 276      =1  //-----------------------------------------------------------------------------
 277      =1  //#define REMO_RC5          // RC5 style
 278      =1  #define TECHWELL_REMOCON
 279      =1  //#define REMO_NEC          // NEC style
 280      =1  //#define PHILIPS_REMOCON // New remocon 
 281      =1  
 282      =1  //-----------------------------------------------------------------------------
 283      =1  //    I2C Device Access Address Mapping
 284      =1  //-----------------------------------------------------------------------------
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 6   

 285      =1  
 286      =1  #define EEPROMI2CAddress  0xa0  // EEPROM (24C16)
 287      =1  #define TW88I2CAddress    0x8a  // TW880x
 288      =1  
 289      =1  #define MSPI2CAddress   0x80  // MSP
 290      =1  #define ALC106I2CAddress  0x4A  // MSP
 291      =1  //-----------------------------------------------------------------------------
 292      =1  //    Options for Possible Inputs
 293      =1  //-----------------------------------------------------------------------------
 294      =1  
 295      =1  
 296      =1  //-----------------------------------------------------------------------------
 297      =1  //    Options for Possible Standards
 298      =1  //    Default:NTSC
 299      =1  //-----------------------------------------------------------------------------
 300      =1  #define SUPPORT_PAL     
 301      =1  #define SUPPORT_SECAM
 302      =1  #define SUPPORT_NTSC4   
 303      =1  #define SUPPORT_PALM  
 304      =1  #define SUPPORT_PALN    
 305      =1  #define SUPPORT_PAL60   
 306      =1  
 307      =1  //#define ID_CHECK_BY_FW        // in Video mode, check input system ID by firmware
 308      =1  
 309      =1  //-----------------------------------------------------------------------------
 310      =1  //    Options for Debugging/Release
 311      =1  //-----------------------------------------------------------------------------
 312      =1  //#define SUPPORT_PATTERN       // support LCD test pattern
 313      =1  
 314      =1  #ifndef WQVGA
 315      =1    #ifndef QVGA
 316      =1  #define SUPPORT_OSDPOSITIONMOVE
 317      =1    #endif
 318      =1  #endif
 319      =1  
 320      =1  #define SERIAL              // include serial communication routines
 321      =1  
 322      =1  //#define SUPPORT_DEBUG       // Support to use Read & Write in debug OSD Window by remocon.
 323      =1  
 324      =1  //#define DEBUG           // include debug information
 325      =1  #ifdef DEBUG
           =1   //#define DEBUG_MAIN
           =1   //#define DEBUG_TIME
           =1   //#define DEBUG_KEYREMO
           =1   //#define DEBUG_TW88
           =1   //#define DEBUG_DECODER
           =1   //#define DEBUG_I2C
           =1   //#define DEBUG_EEP
           =1   //#define DEBUG_OSD
           =1   //#define DEBUG_AUDIO
           =1   //#define DEBUG_SETPANEL
           =1   //#define DEBUG_DTV
           =1 //  #define DEBUG_PC
           =1   //#define DEBUG_PC_MEAS
           =1   //#define DEBUG_PC_COLOR
           =1   //#define DEBUG_COMPONENT
           =1   //#define DEBUG_BANK
           =1   //#define DEBUG_PAUSE
           =1   //#define DEBUG_MCU
           =1 #endif
 345      =1  
 346      =1  #define AUTOCALC_PC         // in PC mode, Enable Auto Calcuration
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 7   

 347      =1  //#define SUPPORT_USERCOLORFROMTXT  // Use color setting of text file in Color mode=USER MODE which is as B
             -rightness(Reg10), Contast(Reg11),
 348      =1                    //    Sat_U(Reg13),Sat_V(Reg14),Sharpness(Reg12,Reg78)                  
 349      =1  //#define SUPPORT_GAMMA
 350      =1  
 351      =1  //#define CHIP_MANUAL_TEST      // DIPSW#1
 352      =1  
 353      =1  #ifndef INTERNAL_MCU
 354      =1  //#define NO_INITIALIZE       // After Power switch turn on with DIP SW4 Enable(Low), or pressed MENU button 
             -for internal MCU
 355      =1                                      //     micom works to access only I2C bus by serial command.
 356      =1  #endif
 357      =1  
 358      =1  //#define SUPPORT_KRS_OSDDEMO   // For KRS Company Demo 
 359      =1  //#define SUPPORT_LINE_OSDDEMO
 360      =1  
 361      =1  //-----------------------------------------------------------------------------
 362      =1  //    Special Features
 363      =1  //-----------------------------------------------------------------------------
 364      =1  
 365      =1  #ifndef INTERNAL_MCU
 366      =1  //#define SUPPORT_DELTA_RGB
 367      =1  #endif
 368      =1  #define SUPPORT_SELECTKEY     // choose the keymap of using select key or left,right key.
 369      =1  //-----------------------------------------------------------------------------
 370      =1  
 371      =1  //#define HS_NEWOSDMENU     //Weylis -@121008 for Hor. Style OSD
 372      =1  //#define HS_NEWOSDMENU_2     //Weylis -@121008 for Hor. Style OSD(2 line)
 373      =1  
 374      =1  #endif  //__CONFIG_H__
 375      =1  
  12          #include "typedefs.h"
   1      =1  #ifndef __TYPEDEFS__
   2      =1  #define __TYPEDEFS__
   3      =1  
   4      =1  
   5      =1  #define DATA    data
   6      =1  #define PDATA   pdata
   7      =1  #define IDATA   data
   8      =1  #define CODE    code
   9      =1  #define CODE_P
  10      =1  #define PDATA_P
  11      =1  #define IDATA_P
  12      =1  #define DATA_P
  13      =1  
  14      =1  #define INTERRUPT( num, name ) name() interrupt num
  15      =1  
  16      =1  #define _between(x, a, b) (a<=x && x<=b)
  17      =1  #define _swap(a, b)     { a^=b; b^=a; a^=b; }
  18      =1  
  19      =1  typedef unsigned char Register;
  20      =1  typedef unsigned char BYTE;
  21      =1  typedef unsigned short  WORD;
  22      =1  typedef unsigned long DWORD;
  23      =1  
  24      =1  #define TRUE  1
  25      =1  #define FALSE 0
  26      =1  
  27      =1  //VInputStdDetectMode
  28      =1  #define AUTO  0
  29      =1  
  30      =1  //VInputStd
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 8   

  31      =1  #define NTSC  1     
  32      =1  #define PAL   2
  33      =1  #define SECAM 3
  34      =1  #define NTSC4 4
  35      =1  #define PALM  5
  36      =1  #define PALN  6
  37      =1  #define PAL60 7
  38      =1  
  39      =1  #define MAXINPUTSTD PAL60+1 // 
  40      =1  
  41      =1  #define UNKNOWN 0xfe
  42      =1  #define NOINPUT 0 //0xff
  43      =1  
  44      =1  #define NIL     0xff
  45      =1  
  46      =1  enum SourceModeTypeEnum
  47      =1  { 
  48      =1    AVMode,      // 0   0X00
  49      =1    //VGAMode,       // 1
  50      =1  #ifdef USE_CAMD 
           =1   CAM_D,         // 2
           =1 #endif
  53      =1    CAM_A,         // 3   0x01
  54      =1    CAM_B,         // 4   0x02
  55      =1    CAM_C,         // 5   0x03
  56      =1    CAM_R,         // 6   0x04
  57      =1    CAM_AB,        // 7   0x05
  58      =1    CAM_CR,        // 8   0x06
  59      =1    CAM_AR,        // 9   0x07
  60      =1    CAM_RB,        // 10    0x08
  61      =1    CAM_AC,        // 11    0x09
  62      =1    CAM_CB,        // 12    0x0a
  63      =1    CAM_RAB_T,     // 13    0x0b
  64      =1    CAM_RAB_H,     // 14    0x0c
  65      =1  
  66      =1    #ifdef HTRV
           =1   CAM_RC,
           =1   #endif
  69      =1    
  70      =1    CAM_QUAD,      // 15    0x0d
  71      =1    CAM_ABR_T3,    // 16    0x0e
  72      =1    CAM_ABR_T4,    // 17    0x0f
  73      =1    CAM_RAC_T,      //  0x10
  74      =1    CAM_RBC_T,      //  0x11
  75      =1    CAM_RAC_T2,     //  0x12
  76      =1    CAM_RBC_T2,     //  0x13
  77      =1    CAM_BA,       //  0x14
  78      =1    CAM_BC,       //  0x15
  79      =1    CAM_BR,       //  0x16
  80      =1    CAM_CA,       //  0x17
  81      =1    CAM_ABC,      //  0x18
  82      =1    CAM_ABR,      //  0x19
  83      =1    CAM_ACR,      //  0x1a
  84      =1    CAM_BAC,      //  0x1b
  85      =1    CAM_BAR,      //  0x1c
  86      =1    CAM_BCR,      //  0x1d
  87      =1    CAM_CAB,      //  0x1e
  88      =1    CAM_CAR,      //  0x1f
  89      =1    CAM_CBR,      //  0x20
  90      =1    SEQ,           // 18      0x10
  91      =1    CAM_NUM
  92      =1  };
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 9   

  93      =1  
  94      =1  typedef unsigned char SourceModeType;
  95      =1  
  96      =1  #endif  /* __TYPEDEFS__ */
  97      =1  
  13          #include "i2c.h"
   1      =1  #ifndef __I2C_H__
   2      =1  #define __I2C_H__
   3      =1  
   4      =1  
   5      =1  void I2CReadByte3(BYTE *);
   6      =1  void I2CRead8Byte(BYTE *);
   7      =1  #if 0
           =1 void I2CReadByteMSP(BYTE addr, BYTE index, BYTE *pd, BYTE cnt);
           =1 #endif
  10      =1  BYTE I2CWriteByte2(BYTE);
  11      =1  BYTE I2CWriteByte3(BYTE*);
  12      =1  BYTE I2CWrite8Byte(BYTE *);
  13      =1  
  14      =1  void I2CStart(void);
  15      =1  void I2CWriteData(BYTE value);
  16      =1  BYTE I2CReadData(void);
  17      =1  #if 0
           =1 BYTE I2CReadDataWithACK(void);
           =1 #endif
  20      =1  void I2CStop(void);
  21      =1  void I2Cdelay(void);
  22      =1  
  23      =1  
  24      =1  #define WriteTW88(a,b)    WriteI2C(TW88I2CAddress, a, b)
  25      =1  #define ReadTW88(a)     ReadI2C(TW88I2CAddress, a)
  26      =1  
  27      =1  BYTE WriteTW88_Wait (BYTE, BYTE);
  28      =1  void WriteADC   (BYTE, BYTE);
  29      =1  BYTE ReadADC    (BYTE);
  30      =1  BYTE ReadADC_TW88(BYTE index);
  31      =1  void WriteADC_TW88(BYTE index, BYTE dat);
  32      =1  
  33      =1  void WriteEEP   (WORD, BYTE);
  34      =1  BYTE ReadEEP    (WORD);
  35      =1  WORD ReadALC106(WORD index);
  36      =1  void WriteALC106(WORD index, WORD  dat);
  37      =1  WORD ReadI2CWORD(BYTE addr, BYTE index);
  38      =1  BYTE ReadI2C    (BYTE addr, BYTE index);
  39      =1  void WriteI2C   (BYTE addr, BYTE index, BYTE val);
  40      =1  
  41      =1  void WriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt);
  42      =1  void WriteI2Cn (BYTE addr, BYTE index, BYTE *val, BYTE cnt);
  43      =1  void WriteI2CnD(BYTE addr, BYTE index, BYTE val, BYTE cnt);
  44      =1  
  45      =1  void ReadI2Cmn(BYTE addr, BYTE wcnt, BYTE rcnt, BYTE *rwdata);
  46      =1  
  47      =1  #define   WriteADC(a,b) WriteADC_TW88(a,b)
  48      =1  #define   ReadADC(a)    ReadADC_TW88(a)
  49      =1  
  50      =1  #endif  /* __I2C_H__ */
  14          #include "main.h"
   1      =1  #ifndef __MAIN__
   2      =1  #define __MAIN__
   3      =1  
   4      =1  #define ON          1
   5      =1  #define OFF         0
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 10  

   6      =1  #if 1//ryan@20171214
   7      =1  #define Hs_debug
   8      =1  #define Monitor_debug  
   9      =1  //#define Trigger_debug 
  10      =1  #endif
  11      =1  
  12      =1  
  13      =1  //#define DVR
  14      =1  #define Format_SDCard
  15      =1  #define BJTSwitch
  16      =1  
  17      =1  #define Panel_Enable()    P4=P4|0x08 //andy 980908
  18      =1  #define Panel_Disable()   P4=P4&0xf7
  19      =1  
  20      =1  #if 0
           =1 #define SetBacklight()      P4=P4|0x04
           =1 #define clrBacklight()      P4=P4&0xfb
           =1 #else
  24      =1  #define SetBacklight()    P4=P4&0xfb
  25      =1  #define clrBacklight()    P4=P4|0x04
  26      =1  #endif
  27      =1  
  28      =1  //InputSelection
  29      =1  struct struct_IdName {
  30      =1    BYTE  Id;
  31      =1    BYTE  Name[16];
  32      =1  };
  33      =1  
  34      =1  #define CH_TW2835       1
  35      =1  #define CH_CAMD       2
  36      =1  #define CH_AV         3
  37      =1  #define PC          7
  38      =1  #define ChineseDefaultMenu  8
  39      =1  
  40      =1  #define SVIDEO        2
  41      =1  #define COMPONENT     3
  42      =1  //#define ANALOGDTV     4
  43      =1  #define DTV         4
  44      =1  #define TV          5
  45      =1  #define SCART       6
  46      =1  
  47      =1  #ifdef HS
  48      =1  #define CH_CAMB         4
  49      =1  #endif
  50      =1  
  51      =1  #define DIGITALVGA      8
  52      =1  
  53      =1  #define AIRTV       0 //9
  54      =1  #define CABLETV       1 //0xa
  55      =1  
  56      =1  #define TVTUNER       0xd   //10
  57      =1  #define MUTE        1 
  58      =1  #define MENU        2 
  59      =1  #define TVVOL       4 
  60      =1  #ifdef AWT_ML072S
  61      =1  #define VLOSSINFO     8 
  62      =1  #else
           =1 #define CC          8 
           =1 #endif
  65      =1  #define INPUTINFO     0x10
  66      =1  #define PCINFO        0x20
  67      =1  #define GAUGEINFO       0x40
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 11  

  68      =1  //#define RATINGINFO      0x40
  69      =1  #define TVCHN       0x80
  70      =1  //#define MUTE        0x40
  71      =1  
  72      =1  #define YPBPR_480i      0
  73      =1  #define YPBPR_576i      1
  74      =1  #define YPBPR_480p      2
  75      =1  #define YPBPR_576p      3
  76      =1  #define YPBPR_1080i     4
  77      =1  #define YPBPR_720p      5
  78      =1  #define YPBPR_720p50    6
  79      =1  
  80      =1  //---------------------- Feature Define ----------------------------
  81      =1  #ifdef AWT_ML072Q
           =1 
           =1 //mask by ryan@20171018   #define AWT_ML720Q_NEW_TRIGGER_FUN    //Pinchi 20141031 add for AWT request each t
             -rigger can work by PRIORITY OFF
           =1 #define AWT_ADD_TRIGGER_DELAY_FUN 
           =1 #define AWT_SUPPORT_4_3_SCREEN    //ryan@20170907 
           =1 #endif
  87      =1  
  88      =1  #ifdef AWT_ML072S
  89      =1  #define AWT_ADD_TRIGGER_DELAY_FUN 
  90      =1  #endif
  91      =1  
  92      =1  //--------------------------- P0 Define -----------------------------
  93      =1  //#define SEL_MIX     P0_6  // 
  94      =1  //--------------------------- P1 Define -----------------------------
  95      =1  //#define SEL_DVI     P3_5  //LJY062001   
  96      =1  
  97      =1  #define TW88HWReset     P3_4  //LJY001010 //LJY000721
  98      =1  #define PowerUp       P3_7
  99      =1  //======================= CDS Control ================================= 
 100      =1  //#define CDS_CTRL           P1_5
 101      =1  extern BYTE SelectModeType;
 102      =1  extern BYTE InputSelection;
 103      =1  extern BYTE SEQTime;
 104      =1  extern BYTE Priority;
 105      =1  extern BYTE PowerFlag;
 106      =1  //extern bit AutoDayNight;
 107      =1  extern bit SDCardCoverDetect;
 108      =1  
 109      =1  BYTE keyIn(void);
 110      =1  void TimerForRemocon(void);
 111      =1  void TimerForTick(void);
 112      =1  void DisableRemoconInt(void);
 113      =1  BYTE SetSupport_remocon(BYTE newd);
 114      =1  
 115      =1  void delay(BYTE cnt);
 116      =1  
 117      =1  BYTE RS_ready(void);
 118      =1  #ifdef Monitor_debug
 119      =1  BYTE RS_rx(void);
 120      =1  #endif
 121      =1  void RS_tx(BYTE tx_buf);
 122      =1  
 123      =1  BYTE RS2_rx(void);
 124      =1  void RS2_tx(BYTE tx_buf);
 125      =1  
 126      =1  void NewLine(void);
 127      =1  void PutsP(PDATA_P BYTE *ptr);
 128      =1  #ifdef Hs_debug
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 12  

 129      =1  //void MonWriteI2C(BYTE addr, BYTE index, BYTE val);
 130      =1  //BYTE MonReadI2C(BYTE addr, BYTE index);
 131      =1  #endif
 132      =1  BYTE Asc1Bin(BYTE asc);
 133      =1  BYTE Asc2Bin(PDATA_P BYTE *s);
 134      =1  
 135      =1  void I2CDeviceInitialize( CODE_P BYTE *RegSet);
 136      =1  
 137      =1  //void RestartSystemClock(WORD clock_hm);
 138      =1  WORD GetTime_ms(void);
 139      =1  #if 0
           =1 BYTE GetTime_H(void);
           =1 BYTE GetTime_M(void);
           =1 #endif
 143      =1  void ChangeTime_H( char add );
 144      =1  void ChangeTime_M( char add );
 145      =1  //WORD GetWakeupTime(void);
 146      =1  //void SetWakeupTime(WORD wtime);
 147      =1  
 148      =1  
 149      =1  //WORD GetOffTime(void);
 150      =1  //void SetOffTime(WORD wtime);
 151      =1  //BYTE GetSleepTimer(void);
 152      =1  //void SetSleepTimer(BYTE stime);
 153      =1  WORD DiffTime_ms( WORD stime, WORD etime );
 154      =1  //void SetLastBlockedTime(void);
 155      =1  void SetLastCCTime(void);       //ljy010904...CC_FIX_CLEAR_ON_TIME
 156      =1  
 157      =1  void SetOSDLastKeyInTime(void);
 158      =1  WORD GetOSDLastKeyInTime(void);
 159      =1  WORD GetIVF(void);
 160      =1  DWORD GetIHF(void);
 161      =1  BYTE ReadVInputSTD(void);
 162      =1  void SetVInputStd(BYTE newd);
 163      =1  BYTE GetVInputStd(void);
 164      =1  BYTE GetInputSelection(void);
 165      =1  #ifdef ADD_ANALOGPANEL
           =1 BYTE IsAnalogOn(void);
           =1 #endif
 168      =1  void InitVideoData(BYTE src);
 169      =1  void ChangeVInputStdDetectMode(BYTE val);
 170      =1  BYTE GetVInputStdInx(void);
 171      =1  
 172      =1  void MonWriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt) ;
 173      =1  
 174      =1  void CheckNewTriggerFunc(void);
 175      =1  ///void Usage(void);
 176      =1  #ifdef Monitor_debug
 177      =1    void Prompt(void);
 178      =1  #endif
 179      =1  void DebugKeyIn(BYTE ikey);
 180      =1  void DVIPowerDown(bit flag);
 181      =1  void PowerDown_XTAL(bit flag);
 182      =1  
 183      =1  void ChangeInput(BYTE newsel);
 184      =1  
 185      =1  
 186      =1  void WaitPowerOn(void);
 187      =1  void PowerOff(void);
 188      =1  BYTE GetNextInputSelection(void);
 189      =1  
 190      =1  BYTE WantToStopTVScan(void);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 13  

 191      =1  
 192      =1  //BYTE IsTW8801(void);
 193      =1  //BYTE IsTW8803(void);
 194      =1  //BYTE ConvertVideoVSAT(BYTE reg);
 195      =1  
 196      =1  BYTE IsNoInput(void);
 197      =1  void LoadEEPROM (void);
 198      =1  void Hs_InitVars(void);
 199      =1  void AdjustAutoDayNight(BYTE val);
 200      =1  void ACCPowerControl(void);
 201      =1  void ON_LVDS(void);
 202      =1  void OFF_LVDS(void);
 203      =1  void main_loop(void);
 204      =1  struct RegisterInfo
 205      =1  {
 206      =1     int  Min;
 207      =1     int  Max;
 208      =1     int  Default;
 209      =1  };
 210      =1  struct LongRegisterInfo
 211      =1  {
 212      =1     WORD Min;
 213      =1     WORD Max;
 214      =1     WORD Default;
 215      =1  };
 216      =1  
 217      =1  
 218      =1  typedef enum   ///add enum  by ryan@20170907
 219      =1  {
 220      =1    NORMALL_MODE,
 221      =1    REVERSE_TRIG,
 222      =1    LEFT_TRIG,
 223      =1    RIGHT_TRIG,
 224      =1  #ifdef USE_CAMD 
           =1   CAMD_TRIG,
           =1 #endif  
 227      =1    CAMC_TRIG,
 228      =1    VGA_TRIG,
 229      =1    PARK_TRIG,
 230      =1    No_TRIG,
 231      =1    TRIGGER_NUM
 232      =1  }TriggerModeType;
 233      =1  
 234      =1  
 235      =1  #endif  // __MAIN__
 236      =1  
  15          #include "tw88.h"
   1      =1  #ifndef __TW88__
   2      =1  #define __TW88__
   3      =1  
   4      =1  #include "main.h"
   1      =2  #ifndef __MAIN__
           =2 #define __MAIN__
           =2 
           =2 #define ON          1
           =2 #define OFF         0
           =2 #if 1//ryan@20171214
           =2 #define Hs_debug
           =2 #define Monitor_debug  
           =2 //#define Trigger_debug 
           =2 #endif
           =2 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 14  

           =2 
           =2 //#define DVR
           =2 #define Format_SDCard
           =2 #define BJTSwitch
           =2 
           =2 #define Panel_Enable()    P4=P4|0x08 //andy 980908
           =2 #define Panel_Disable()   P4=P4&0xf7
           =2 
           =2 #if 0
           =2 #define SetBacklight()      P4=P4|0x04
           =2 #define clrBacklight()      P4=P4&0xfb
           =2 #else
           =2 #define SetBacklight()    P4=P4&0xfb
           =2 #define clrBacklight()    P4=P4|0x04
           =2 #endif
           =2 
           =2 //InputSelection
           =2 struct struct_IdName {
           =2   BYTE  Id;
           =2   BYTE  Name[16];
           =2 };
           =2 
           =2 #define CH_TW2835       1
           =2 #define CH_CAMD       2
           =2 #define CH_AV         3
           =2 #define PC          7
           =2 #define ChineseDefaultMenu  8
           =2 
           =2 #define SVIDEO        2
           =2 #define COMPONENT     3
           =2 //#define ANALOGDTV     4
           =2 #define DTV         4
           =2 #define TV          5
           =2 #define SCART       6
           =2 
           =2 #ifdef HS
           =2 #define CH_CAMB         4
           =2 #endif
           =2 
           =2 #define DIGITALVGA      8
           =2 
           =2 #define AIRTV       0 //9
           =2 #define CABLETV       1 //0xa
           =2 
           =2 #define TVTUNER       0xd   //10
           =2 #define MUTE        1 
           =2 #define MENU        2 
           =2 #define TVVOL       4 
           =2 #ifdef AWT_ML072S
           =2 #define VLOSSINFO     8 
           =2 #else
           =2 #define CC          8 
           =2 #endif
           =2 #define INPUTINFO     0x10
           =2 #define PCINFO        0x20
           =2 #define GAUGEINFO       0x40
           =2 //#define RATINGINFO      0x40
           =2 #define TVCHN       0x80
           =2 //#define MUTE        0x40
           =2 
           =2 #define YPBPR_480i      0
           =2 #define YPBPR_576i      1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 15  

           =2 #define YPBPR_480p      2
           =2 #define YPBPR_576p      3
           =2 #define YPBPR_1080i     4
           =2 #define YPBPR_720p      5
           =2 #define YPBPR_720p50    6
           =2 
           =2 //---------------------- Feature Define ----------------------------
           =2 #ifdef AWT_ML072Q
           =2 
           =2 //mask by ryan@20171018   #define AWT_ML720Q_NEW_TRIGGER_FUN    //Pinchi 20141031 add for AWT request each t
             -rigger can work by PRIORITY OFF
           =2 #define AWT_ADD_TRIGGER_DELAY_FUN 
           =2 #define AWT_SUPPORT_4_3_SCREEN    //ryan@20170907 
           =2 #endif
           =2 
           =2 #ifdef AWT_ML072S
           =2 #define AWT_ADD_TRIGGER_DELAY_FUN 
           =2 #endif
           =2 
           =2 //--------------------------- P0 Define -----------------------------
           =2 //#define SEL_MIX     P0_6  // 
           =2 //--------------------------- P1 Define -----------------------------
           =2 //#define SEL_DVI     P3_5  //LJY062001   
           =2 
           =2 #define TW88HWReset     P3_4  //LJY001010 //LJY000721
           =2 #define PowerUp       P3_7
           =2 //======================= CDS Control ================================= 
           =2 //#define CDS_CTRL           P1_5
           =2 extern BYTE SelectModeType;
           =2 extern BYTE InputSelection;
           =2 extern BYTE SEQTime;
           =2 extern BYTE Priority;
           =2 extern BYTE PowerFlag;
           =2 //extern bit AutoDayNight;
           =2 extern bit SDCardCoverDetect;
           =2 
           =2 BYTE keyIn(void);
           =2 void TimerForRemocon(void);
           =2 void TimerForTick(void);
           =2 void DisableRemoconInt(void);
           =2 BYTE SetSupport_remocon(BYTE newd);
           =2 
           =2 void delay(BYTE cnt);
           =2 
           =2 BYTE RS_ready(void);
           =2 #ifdef Monitor_debug
           =2 BYTE RS_rx(void);
           =2 #endif
           =2 void RS_tx(BYTE tx_buf);
           =2 
           =2 BYTE RS2_rx(void);
           =2 void RS2_tx(BYTE tx_buf);
           =2 
           =2 void NewLine(void);
           =2 void PutsP(PDATA_P BYTE *ptr);
           =2 #ifdef Hs_debug
           =2 //void MonWriteI2C(BYTE addr, BYTE index, BYTE val);
           =2 //BYTE MonReadI2C(BYTE addr, BYTE index);
           =2 #endif
           =2 BYTE Asc1Bin(BYTE asc);
           =2 BYTE Asc2Bin(PDATA_P BYTE *s);
           =2 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 16  

           =2 void I2CDeviceInitialize( CODE_P BYTE *RegSet);
           =2 
           =2 //void RestartSystemClock(WORD clock_hm);
           =2 WORD GetTime_ms(void);
           =2 #if 0
           =2 BYTE GetTime_H(void);
           =2 BYTE GetTime_M(void);
           =2 #endif
           =2 void ChangeTime_H( char add );
           =2 void ChangeTime_M( char add );
           =2 //WORD GetWakeupTime(void);
           =2 //void SetWakeupTime(WORD wtime);
           =2 
           =2 
           =2 //WORD GetOffTime(void);
           =2 //void SetOffTime(WORD wtime);
           =2 //BYTE GetSleepTimer(void);
           =2 //void SetSleepTimer(BYTE stime);
           =2 WORD DiffTime_ms( WORD stime, WORD etime );
           =2 //void SetLastBlockedTime(void);
           =2 void SetLastCCTime(void);       //ljy010904...CC_FIX_CLEAR_ON_TIME
           =2 
           =2 void SetOSDLastKeyInTime(void);
           =2 WORD GetOSDLastKeyInTime(void);
           =2 WORD GetIVF(void);
           =2 DWORD GetIHF(void);
           =2 BYTE ReadVInputSTD(void);
           =2 void SetVInputStd(BYTE newd);
           =2 BYTE GetVInputStd(void);
           =2 BYTE GetInputSelection(void);
           =2 #ifdef ADD_ANALOGPANEL
           =2 BYTE IsAnalogOn(void);
           =2 #endif
           =2 void InitVideoData(BYTE src);
           =2 void ChangeVInputStdDetectMode(BYTE val);
           =2 BYTE GetVInputStdInx(void);
           =2 
           =2 void MonWriteI2Cn_(BYTE addr, BYTE *val, BYTE cnt) ;
           =2 
           =2 void CheckNewTriggerFunc(void);
           =2 ///void Usage(void);
           =2 #ifdef Monitor_debug
           =2   void Prompt(void);
           =2 #endif
           =2 void DebugKeyIn(BYTE ikey);
           =2 void DVIPowerDown(bit flag);
           =2 void PowerDown_XTAL(bit flag);
           =2 
           =2 void ChangeInput(BYTE newsel);
           =2 
           =2 
           =2 void WaitPowerOn(void);
           =2 void PowerOff(void);
           =2 BYTE GetNextInputSelection(void);
           =2 
           =2 BYTE WantToStopTVScan(void);
           =2 
           =2 //BYTE IsTW8801(void);
           =2 //BYTE IsTW8803(void);
           =2 //BYTE ConvertVideoVSAT(BYTE reg);
           =2 
           =2 BYTE IsNoInput(void);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 17  

           =2 void LoadEEPROM (void);
           =2 void Hs_InitVars(void);
           =2 void AdjustAutoDayNight(BYTE val);
           =2 void ACCPowerControl(void);
           =2 void ON_LVDS(void);
           =2 void OFF_LVDS(void);
           =2 void main_loop(void);
           =2 struct RegisterInfo
           =2 {
           =2    int  Min;
           =2    int  Max;
           =2    int  Default;
           =2 };
           =2 struct LongRegisterInfo
           =2 {
           =2    WORD Min;
           =2    WORD Max;
           =2    WORD Default;
           =2 };
           =2 
           =2 
           =2 typedef enum   ///add enum  by ryan@20170907
           =2 {
           =2   NORMALL_MODE,
           =2   REVERSE_TRIG,
           =2   LEFT_TRIG,
           =2   RIGHT_TRIG,
           =2 #ifdef USE_CAMD 
           =2   CAMD_TRIG,
           =2 #endif  
           =2   CAMC_TRIG,
           =2   VGA_TRIG,
           =2   PARK_TRIG,
           =2   No_TRIG,
           =2   TRIGGER_NUM
           =2 }TriggerModeType;
           =2 
           =2 
           =2 #endif  // __MAIN__
 236      =2  
   5      =1  
   6      =1  //Value for register 0x44
   7      =1  //#define DECODER_YCbCr   0x08    //xxxx bbxx
   8      =1  //#define RGB_RGB       0x0C
   9      =1  
  10      =1  #define TW88_FPLL0      0xf9
  11      =1  #define TW88_FPLL1      0xfa
  12      =1  #define TW88_FPLL2      0xfb
  13      =1  #define TW88_FSS      0xfc
  14      =1  #define TW88_FSS_PD     0xfd
  15      =1  #define TW88_PLL_DIV    0xfe
  16      =1  
  17      =1  //#define TW88_XSCALE     0x5d
  18      =1  //#define TW88_YSCALE     0x5e
  19      =1  
  20      =1  #define TW88_XUSCALELO    0x60
  21      =1  #define TW88_XDSCALELO    0x61
  22      =1  #define TW88_YUSCALELO    0x62
  23      =1  #define TW88_XYSCALEHI    0x63
  24      =1  #define TW88_XUSCALEFINE  0x69
  25      =1  #define TW88_YUSCALEFINE  0x6a
  26      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 18  

  27      =1  //Power Mgt
  28      =1  #define POWER_OFF     0
  29      =1  #define POWER_STANDBY   1
  30      =1  #define POWER_SUSPEND   2
  31      =1  #define POWER_ON      3
  32      =1  
  33      =1  //void TWChipsDetect(void);
  34      =1  void SetAutoDetectStd(void);
  35      =1  void ClearAutoDetectStd(BYTE);
  36      =1  void I2CDeviceInitialize( CODE_P BYTE *RegSet);
  37      =1  
  38      =1  
  39      =1  //0x63.. Register Group
  40      =1  #define GROUP_YCbCr     0x40
  41      =1  #define GROUP_RGB     0
  42      =1  #define SelectPanelAttrRegGroup(A)        WriteTW88(0x70, (ReadTW88(0x70) & 0xbf) | A)
  43      =1  
  44      =1  //#if defined TW8801 || defined TW8803
  45      =1  #define FB_MAIN   2
  46      =1  #define FB_NORMAL 1
  47      =1  #define FB_RGB    0
  48      =1  //void SetFBmode( BYTE mode );
  49      =1  //#endif // TW8801
  50      =1  
  51      =1  
  52      =1  //=============================================================================
  53      =1  //                               LCD Functions   
  54      =1  //=============================================================================
  55      =1  //BYTE GetLCDPowerState(void);
  56      =1  void SetLCDPowerState(BYTE dat);
  57      =1  
  58      =1  BYTE IsFreeRun(void);
  59      =1  #if defined( SUPPORT_PC ) || defined( SUPPORT_DTV )
           =1 void PanelFreeRun(BYTE on);
           =1 void PanelBlack(BYTE on);
           =1 #endif
  63      =1  #if 0
           =1 void PanelMute(BYTE on);
           =1 #endif
  66      =1  void LCDPowerON(BYTE mute); 
  67      =1  
  68      =1  #ifdef AWT_ML072S
  69      =1  void LCDPowerOFF(void);
  70      =1  #endif
  71      =1  
  72      =1  #ifdef Hs_debug
  73      =1  void LCDPower(void);
  74      =1  #endif
  75      =1  void DPMSmodeOFF(void);
  76      =1  void DPMSmodeON(void);
  77      =1  //=============================================================================
  78      =1  //                          Get PC Parameter Functions   
  79      =1  //=============================================================================
  80      =1  void GetInitPanelAttribute1(void);
  81      =1  //void GetInitPanelAttribute2(void);
  82      =1  void DefaultPanelAttributeForVideo(void);
  83      =1  void SetPVR(WORD pvr);
  84      =1  void SetPHR(WORD phr);
  85      =1  WORD GetPVR(void);
  86      =1  WORD GetPHR(void);
  87      =1  WORD GetHPN(void);
  88      =1  WORD GetVPN(void);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 19  

  89      =1  
  90      =1  //WORD GetVactive(void);
  91      =1  
  92      =1  WORD GetHstart(void);
  93      =1  WORD GetHend(void);
  94      =1  WORD GetVstart(void);
  95      =1  WORD GetVend(void);
  96      =1  void TuneLineBuffer(BYTE field);
  97      =1  void TuneLineBuffer4Video(BYTE field);
  98      =1  
  99      =1  #if defined (SUPPORT_DTV)
           =1 void SetCoarstForDTV(BYTE en);
           =1 #endif
 102      =1  
 103      =1  WORD GetHactiveStart(void);
 104      =1  WORD GetHactiveEnd(void);
 105      =1  WORD GetVactiveStart(void);
 106      =1  //WORD GetVactiveLen(void);
 107      =1  BYTE GetVBackPorch(void);
 108      =1  void SetVBackPorch(BYTE val);
 109      =1  WORD GetPHP(void);
 110      =1  void SetPHP(WORD php);
 111      =1  void SetPVP(WORD period);
 112      =1  WORD GetPVP(void);
 113      =1  //void SetPanelRelatedRegisters(void);
 114      =1  //BYTE ChangedHPN(void);
 115      =1  //WORD GetVSUD(void);
 116      =1  
 117      =1  void SetDefaultPLL(void);
 118      =1  //void SetDefaultFPHSperiod(void);
 119      =1  //BYTE CalcPHP(DWORD ppf, BYTE tol);
 120      =1  //void ChangeFPHSperiod4DecoderInput(WORD vsud, BYTE tol);
 121      =1  
 122      =1  //-------------------------------------------------------------------
 123      =1  //                  Set Active Region Functions
 124      =1  //-------------------------------------------------------------------
 125      =1  void SetHactiveStart(WORD hstart);
 126      =1  void SetHactiveEnd(WORD hend);
 127      =1  void SetVactiveStart(WORD vstart);
 128      =1  //void SetVactiveLen(WORD van, WORD vstart);
 129      =1  void SetVactiveLen(WORD van);
 130      =1  //=============================================================================
 131      =1  //                     Set Measurement Window Functions   
 132      =1  //=============================================================================
 133      =1  void SetMeasureWindowH(WORD start, WORD stop);
 134      =1  void SetMeasureWindowV(WORD start, WORD stop);
 135      =1  //=============================================================================
 136      =1  //                          Video Input Functions   
 137      =1  //=============================================================================
 138      =1  BYTE IsVideoInput(void);
 139      =1  BYTE DetectDecoderInput(void);
 140      =1  //=============================================================================
 141      =1  //
 142      =1  //=============================================================================
 143      =1  #if defined( SUPPORT_PC ) || defined( SUPPORT_DTV )
           =1 void AutoPHPCalEnable(void);
           =1 void AutoPHPCalDisable(void);
           =1 #endif
 147      =1  void MakeStartInt(void);
 148      =1  void AVGAInput(void);
 149      =1  void DVIInput(void);
 150      =1  //void DVGAInput(void);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 20  

 151      =1  void DisableDVGA(void);
 152      =1  
 153      =1  void COMPOSITE1Input(void);
 154      =1  void COMPOSITE2Input(void);
 155      =1  void COMPOSITE3Input(void);
 156      =1  void COMPOSITE4Input(void);
 157      =1  
 158      =1  void SVIDEOInput(void);
 159      =1  void COMPONENTInput(void);
 160      =1  void ANALOGDTVInput(void);
 161      =1  void DTVInput(void);
 162      =1  void TVInput(void);
 163      =1  void SCARTInput(void);
 164      =1  
 165      =1  //=============================================================================
 166      =1  //                          Measurement Functions
 167      =1  //=============================================================================
 168      =1  ///void SetPanelBitOrder(BYTE swap);
 169      =1  //void SetPanelSingleDouble(BYTE single);
 170      =1  
 171      =1  BYTE MeasureAndWait(BYTE flag);
 172      =1  
 173      =1  //WORD GetHCounter1(BYTE field);
 174      =1  //void SetHInitial(BYTE field, WORD counter);
 175      =1  //=============================================================================
 176      =1  //                          Invert Polarity Functions
 177      =1  //=============================================================================
 178      =1  void InvertHSYNCPolarity(void);
 179      =1  void InvertVSYNCPolarity(void);
 180      =1  //=============================================================================
 181      =1  //            Interrupt / SW Reset Control Functions
 182      =1  //=============================================================================
 183      =1  void SetInt(void);
 184      =1  //void ClearInt(void);
 185      =1  void SetEnDet(void);
 186      =1  void ClearEnDet(void);
 187      =1  void SWReset(void);
 188      =1  //void ClearSYNCLossStatus(void);
 189      =1  //void ClearSYNCChangeStatus(void);
 190      =1  //=============================================================================
 191      =1  //
 192      =1  //=============================================================================
 193      =1  BYTE IsBypassmode(void);
 194      =1  //BYTE IsInteraced(void);
 195      =1  void Clear_bypass(void);
 196      =1  void MaskOnSYNCInt(void);
 197      =1  void MaskOffSYNCInt(void);
 198      =1  //=============================================================================
 199      =1  //                                ZoomControl
 200      =1  //=============================================================================
 201      =1  void BypassZoom(void);
 202      =1  
 203      =1  void XscaleU(DWORD scale);
 204      =1  void XscaleD(DWORD scale);
 205      =1  void XScale2(DWORD scale);
 206      =1  void YScale2(DWORD scale);
 207      =1  WORD GetYScale(void);
 208      =1  //=============================================================================
 209      =1  //
 210      =1  //=============================================================================
 211      =1  WORD GetHSYNCPulse(void);
 212      =1  WORD GetVSYNCPulse(void);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 21  

 213      =1  //#if defined TW8801 || defined TW8803
 214      =1  WORD GetRelativePosition(void);
 215      =1  //#endif
 216      =1  //=============================================================================
 217      =1  //                MISC2 for decoder
 218      =1  //=============================================================================
 219      =1  #define BLUE_DECODER    2
 220      =1  #define BLACK_DECODER   0
 221      =1  
 222      =1  BYTE ForceDecoderOutput(BYTE color);
 223      =1  BYTE ClearForcedDecoderOutput(void);
 224      =1  //=============================================================================
 225      =1  //                CC and EDS
 226      =1  //=============================================================================
 227      =1  BYTE GetCCStatus(void);
 228      =1  void DisableCC(void);
 229      =1  void EnableCC(void);
 230      =1  BYTE GetCCData(void);
 231      =1  BYTE IsCCEnabled(void);
 232      =1  void EnableEDS(void);
 233      =1  void DisableEDS(void);
 234      =1  void RecoverCCOverflow(void);
 235      =1  
 236      =1  #define CCFIFOHalfFull()      (ReadDecoder(CSTATUS) & 0x04)
 237      =1  //=============================================================================
 238      =1  //                Internal PLL
 239      =1  //=============================================================================
 240      =1  BYTE GetPOST(void);
 241      =1  void SetPLLS(BYTE plls);
 242      =1  BYTE GetREFDM(void);
 243      =1  void SetREFDM(BYTE refdm);
 244      =1  DWORD GetFBDN(void);
 245      =1  void SetFBDN(WORD fbdn, BYTE vcsel);
 246      =1  DWORD GetPPF(void);
 247      =1  void ChangeInternPLL(DWORD _PPF);
 248      =1  
 249      =1  //=============================================================================
 250      =1  //                Macros for attribute
 251      =1  //=============================================================================
 252      =1  //#define GetOSDTransReg()            ReadTW88(0xAE)
 253      =1  //#define SetOSDTransReg(AlphaV)          WriteTW88(0xAE, (BYTE)AlphaV )
 254      =1  
 255      =1  #define GetPanelContrastReg(gccolor)      ReadTW88(0x71+gccolor)
 256      =1  #define SetPanelContrastReg(sccolor, cval)    WriteTW88(0x71+sccolor,cval)
 257      =1  
 258      =1  #define GetPanelBrightnessReg(gbcolor)      ReadTW88(0x74+gbcolor);
 259      =1  #define SetPanelBrightnessReg(sbcolor, bval)  WriteTW88(0x74+sbcolor,bval);
 260      =1  
 261      =1  #define SetDTVBrightnessReg(bval)       WriteTW88(0x74,bval);
 262      =1  
 263      =1  #define GetPanelSaturationReg(gbcolor)      ReadTW88(0x72+gbcolor);
 264      =1  #define SetPanelSaturationReg(sbcolor, bval)  WriteTW88(0x72+sbcolor,bval);
 265      =1  
 266      =1  #define SetPanelSharpnessReg(bval)        WriteTW88(0x78,((bval&0x07)|0x38) );
 267      =1  
 268      =1  #define SetPanelHueReg(bval)          WriteTW88(0x70, (ReadTW88(0x70) & 0xc0 | (bval)) );
 269      =1  
 270      =1  #define GetVideoContrastReg()         ReadDecoder(CONTRAST)
 271      =1  #define SetVideoContrastReg(vcval)        WriteDecoder(CONTRAST, vcval)
 272      =1  
 273      =1  #define GetVideoBrightnessReg()         ReadDecoder(BRIGHT)
 274      =1  #define SetVideoBrightnessReg(vbval)      WriteDecoder(BRIGHT, vbval )
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 22  

 275      =1  
 276      =1  #define GetVideoSaturationReg(gvstype)      ReadDecoder(SAT_U+gvstype)
 277      =1  #define SetVideoSaturationReg(svstype, vsval) WriteDecoder(SAT_U+svstype, vsval)
 278      =1  
 279      =1  #define GetVideoHueReg()            ReadDecoder(HUE)
 280      =1  #define SetVideoHueReg(vhval)         WriteDecoder(HUE, vhval )
 281      =1  
 282      =1  #define GetVideoSharpnessRegDef         (ReadDecoder(SHARPNESS) & 0x0f) 
 283      =1  
 284      =1  #define GetVideoSharpnessReg()          GetVideoSharpnessRegDef
 285      =1  //#define SetVideoSharpnessReg(vshval)      WriteDecoder(SHARPNESS, vshval )
 286      =1  #define SetVideoSharpnessReg(vshval)      WriteDecoder(SHARPNESS, ((ReadDecoder(SHARPNESS) & 0xf0) | (vshval 
             -& 0x0f) ) );
 287      =1  
 288      =1  #ifdef TW9908
           =1 #define SetVideoVPeakingReg(vshval)
           =1 #else
 291      =1  #define SetVideoVPeakingReg(vshval)       WriteDecoder(V_PEAKING, ((ReadDecoder(V_PEAKING) & 0xf8) | (vshval 
             -& 0x07) ) );
 292      =1  #endif
 293      =1  
 294      =1  #define SetVideoHfilterReg(val)         WriteDecoder(HFILTER, ((ReadDecoder(HFILTER) & 0xf8) | (val & 0x07) )|
             -0x08 );
 295      =1  //----------------------------------------------------------------------------------
 296      =1  //color type
 297      =1  #define RED   0
 298      =1  #define GREEN 1
 299      =1  #define BLUE  2
 300      =1  #define WHITE 3
 301      =1  //saturation type
 302      =1  #define U_SAT 0
 303      =1  #define V_SAT 1
 304      =1  
 305      =1  //Alpha Blending Level
 306      =1  #define _0    0
 307      =1  #define _25   0x12
 308      =1  #define _37_5 0x13
 309      =1  #define _50   0x14
 310      =1  #define _100  0x18
 311      =1  
 312      =1  BYTE GetKey(BYTE repeat);
 313      =1  
 314      =1  /*
 315      =1  BYTE Mapping( int fromValue, struct RegisterInfo fromRange,
 316      =1                                   int * toValue, struct RegisterInfo toRange );
 317      =1  */
 318      =1  BYTE Mapping1( int fromValue, CODE_P struct RegisterInfo *fromRange,
 319      =1                                   int * toValue, CODE_P struct RegisterInfo *toRange );
 320      =1  #ifdef KEILC
 321      =1  #define Mapping2( A, B, C, D )      Mapping1( A, B, C, D )
 322      =1  #define Mapping3( A, B, C, D )      Mapping1( A, B, C, D )
 323      =1  #else
           =1 BYTE Mapping2( int fromValue, IDATA_P struct RegisterInfo *fromRange,
           =1                                  int * toValue, CODE_P struct RegisterInfo *toRange );
           =1 BYTE Mapping3( int fromValue, CODE_P struct RegisterInfo *fromRange,
           =1                                  int * toValue, IDATA_P struct RegisterInfo *toRange );
           =1 #endif
 329      =1  
 330      =1  BYTE GetAttributesFromNTSCSettings(BYTE index);
 331      =1  
 332      =1  #endif  // __TW88__
 333      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 23  

  16          #include "osdbasic.h"
   1      =1  //osd_basic.h
   2      =1  //LJY11012001
   3      =1  #ifndef __OSD_BASIC__
   4      =1  #define __OSD_BASIC__
   5      =1  
   6      =1  // osd_basic.h
   7      =1  // char code
   8      =1  //#include "apilib.h"
   9      =1  
  10      =1  //ljy052903
  11      =1  //definition for internal OSD
  12      =1  #define FONT_WIDTH_TW88     12
  13      =1  #define FONT_HEIGHT_TW88    18
  14      =1  #define PIXS_PER_XSTEP_TW88   8
  15      =1  #define LINES_PER_YSTEP_TW88  4
  16      =1  #define MAX_OSDWINDOW_TW88    8
  17      =1  
  18      =1  // Using TW88 OSD for Menu
  19      =1  #define FONT_WIDTH      12
  20      =1  #define FONT_HEIGHT     18
  21      =1  #define PIXS_PER_XSTEP    8
  22      =1  #define LINES_PER_YSTEP   4
  23      =1  #define MAX_OSDWINDOW   4
  24      =1  
  25      =1  #define MAX_FONT_BYTES    27
  26      =1  #define RAMFONT   0xFE
  27      =1  #define ROMFONT   0xFF
  28      =1  #define NO_UDFONT     226 
  29      =1  
  30      =1  #define FONT_ROM  1
  31      =1  #define FONT_RAM  2
  32      =1  
  33      =1  
  34      =1  /////////////////////////////////
  35      =1  // Old Registers...
  36      =1  /*
  37      =1    #define TW88_WIN1ATTR   0x76
  38      =1    #define TW88_WIN1XSTART   0x77
  39      =1    #define TW88_WIN1YSTART   0x78
  40      =1    #define TW88_WIN1WIDTH    0x79
  41      =1    #define TW88_WIN1HEIGHT   0x7a
  42      =1    #define TW88_WIN1BRDATTR  0x7b
  43      =1    #define TW88_WIN1BRDWIDTH 0x7c
  44      =1    #define TW88_WIN1BRDHEIGHT  0x7d
  45      =1    #define TW88_WIN1XSPACE   0x7e    // between characters.
  46      =1    #define TW88_WIN1YSPACE   0x7f
  47      =1    #define TW88_WIN1SADDR    0x80    // starting address of OSD ram for Windows 1
  48      =1  */
  49      =1  /////////////////////////////////
  50      =1  
  51      =1  // OSD
  52      =1  #define TW88_ENABLERAM    0x94  // TW8804C
  53      =1  #define TW88_FONTRAMADDR  0x99  // TW8804C
  54      =1  #define TW88_FONTRAMDATA  0x9a  // TW8804C
  55      =1  #define TW88_OSDRAMADDRHI 0x95  // TW8804C
  56      =1  #define TW88_OSDRAMADDRLO 0x96  // TW8804C
  57      =1  #define TW88_OSDRAMDATAHI 0x97  // TW8804C
  58      =1  #define TW88_OSDRAMDATALO 0x98  // TW8804C
  59      =1  #define TW88_MULTISTART   0x9b  // TW8804C
  60      =1  #define TW88_OSDLOCKUPSEL 0x9c
  61      =1  #define TW88_WINNUM     0x9e  // TW8804C
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 24  

  62      =1  #define TW88_WINATTR    0x9f  //
  63      =1  #define TW88_WINXSTART    0xa1  //
  64      =1  #define TW88_WINYSTART    0xa2  //
  65      =1  #define TW88_WINSTART_HI  0xa0  //
  66      =1  #define TW88_WINWIDTH   0xa3  //
  67      =1  #define TW88_WINHEIGHT    0xa4  //
  68      =1  #define TW88_WINBRDATTR   0xa5  //
  69      =1  #define TW88_WINBRDWIDTH  0xa6  //
  70      =1  #define TW88_WINBRDHEIGHT 0xa7  //
  71      =1  #define TW88_WINSPACE   0xa8  // between characters.
  72      =1  #define TW88_WINZOOM    0xa9  //
  73      =1  #define TW88_WINSADDRHI   0xa9  // starting address of OSD ram for Windows 1
  74      =1  #define TW88_WINSADDRLO   0xaa  // starting address of OSD ram for Windows 1
  75      =1  
  76      =1  #define TW88_WINSHADOW    0xab  //
  77      =1  #define TW88_WINBLENDING  0xac  //
  78      =1  #define TW88_WINCHEFFECT  0xad  //
  79      =1  
  80      =1  
  81      =1  //Attributes for OSD
  82      =1  #define WINZOOMx1     0x01
  83      =1  #define WINZOOMx2     0x02
  84      =1  #define WINZOOMx3     0x03
  85      =1  #define WINZOOMx4     0x04
  86      =1  #define SHOW        0x08  
  87      =1  
  88      =1  #define EXTENDED_COLOR    0x80
  89      =1  #define BG_COLOR_BLACK    0x00  //For background color of window, border, and char. 
  90      =1  #define BG_COLOR_RED    0x40  
  91      =1  #define BG_COLOR_GREEN    0x20
  92      =1  #define BG_COLOR_YELLOW   0x60
  93      =1  #define BG_COLOR_BLUE   0x10
  94      =1  #define BG_COLOR_MAGENTA  0x50
  95      =1  #define BG_COLOR_CYAN   0x30
  96      =1  #define BG_COLOR_WHITE    0x70
  97      =1  #define BG_COLOR_TRANS    0x80  
  98      =1  #define BG_COLOR_MASK   0xf0  
  99      =1  
 100      =1  #define CH_COLOR_BLACK    0x00  //For color of char.
 101      =1  #define CH_COLOR_RED    0x04  
 102      =1  #define CH_COLOR_GREEN    0x02
 103      =1  #define CH_COLOR_YELLOW   0x06
 104      =1  #define CH_COLOR_BLUE   0x01
 105      =1  #define CH_COLOR_MAGENTA  0x05
 106      =1  #define CH_COLOR_CYAN   0x03
 107      =1  #define CH_COLOR_WHITE    0x07
 108      =1  #define CH_BLINK      0x08  
 109      =1  #define CH_COLOR_MASK   0x0f  
 110      =1  
 111      =1  #define CL_BLACK      0x00  //For color of char.
 112      =1  #define CL_BLUE       0x01
 113      =1  #define CL_GREEN      0x02
 114      =1  #define CL_CYAN       0x03
 115      =1  #define CL_RED        0x04  
 116      =1  #define CL_MAGENTA      0x05
 117      =1  #define CL_YELLOW     0x06
 118      =1  #define CL_WHITE      0x07
 119      =1  #define CL_BLINK      0x08  
 120      =1  
 121      =1  // 0x76*(WindowNo*0x0b)
 122      =1  #define WINDOW_DISABLE    0x00
 123      =1  #define WINDOW_ENABLE   0x01
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 25  

 124      =1  #define WINDOW_3D_ENABLE    0x04
 125      =1  #define WINDOW_3D_BOTTOM    0x08
 126      =1  #define WINDOW_3D_TOP     0x00
 127      =1  #define WINDOW_TRANS_ENABLE 0x80
 128      =1  
 129      =1  #define WINBDCOLOR_ENABLE 0x80
 130      =1  #define WINBDCOLOR_EXTENT 0x80
 131      =1  
 132      =1  
 133      =1  #define WINBLENDING_DISABLE 0x00
 134      =1  #define WINBLENDING_BACK    0x10
 135      =1  #define WINBLENDING_FORE    0x20
 136      =1  #define WINBLENDING_ALL     0x30
 137      =1  
 138      =1  #define WINSHADOW_ENABLE  0x80
 139      =1  // 0xc8*WindowNo
 140      =1  #define WIN_MULTICOLOR_ENABLE 0x20
 141      =1  #define WIN_CH_EFFECT_ENABLE  0x10
 142      =1  #define WIN_CH_EFFECT_SHADOW  0x08
 143      =1  
 144      =1  
 145      =1  
 146      =1  ///////// TW8804C /////////////
 147      =1  // Window Number
 148      =1  #define WINNUM1       1
 149      =1  #define WINNUM2       2
 150      =1  #define WINNUM3       3
 151      =1  #define WINNUM4       4
 152      =1  
 153      =1  // Index 0x9f Defination
 154      =1  #define WIN_BG_COLOR_EX   0x80
 155      =1  #define WIN_BG_COLOR_EX0  0x00
 156      =1  #define WIN_3D_TYPE     0x08
 157      =1  #define WIN_3D_TYPE0    0x00
 158      =1  #define WIN_3D_EN     0x04
 159      =1  #define WIN_3D_EN0      0x00
 160      =1  #define WIN_3D_LEVEL    0x02
 161      =1  #define WIN_EN        0x01
 162      =1  #define WIN_EN0       0x00
 163      =1  
 164      =1  // Index 0xa5 Defination
 165      =1  #define WIN_BD_EN     0x80
 166      =1  #define WIN_BD_EN0      0x00
 167      =1  #define WIN_BD_WIDTH(a)   a
 168      =1  
 169      =1  // Index 0xa6 Defination
 170      =1  #define WIN_BD_COLOR_EX   0x80
 171      =1  #define WIN_BD_COLOR_EX0  0x00
 172      =1  #define WIN_H_BD_W(a)   a
 173      =1  
 174      =1  // Index 0xa7 Defination
 175      =1  #define WIN_V_BD_W(a)   a
 176      =1  
 177      =1  // Index 0xa8
 178      =1  #define WIN_CH_VSPACE(a)  (a<<4)
 179      =1  #define WIN_CH_HSPACE(a)  a
 180      =1  
 181      =1  // Index 0xa9 Defination
 182      =1  #define WIN_VZOOM(a)    (a-1)
 183      =1  #define WIN_HZOOM(a)    (a-1)
 184      =1  #define WIN_SADDR(a)    a
 185      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 26  

 186      =1  // Index 0xab
 187      =1  #define WIN_SHADOW_EN   0x80
 188      =1  #define WIN_SHADOW_EN0    0x00
 189      =1  #define WIN_SHADOW_W(a)   a
 190      =1  
 191      =1  // ad
 192      =1  #define WIN_SHADOW_COLOR_EX   0x80
 193      =1  #define WIN_SHADOW_COLOR_EX0  0x00
 194      =1  #define WIN_MULTI_EN      0x40
 195      =1  #define WIN_MULTI_EN0     0x00
 196      =1  #define WIN_V_EXT_EN      0x20
 197      =1  #define WIN_V_EXT_EN0     0x00
 198      =1  #define WIN_CH_BDSH_SEL(a)    a
 199      =1  #define SEL_BORDER        0
 200      =1  #define SEL_SHADOW        1
 201      =1  #define WIN_CH_BDSH_COLOR_EX  0x08
 202      =1  #define WIN_CH_BDSH_COLOR_EX0 0x00
 203      =1  
 204      =1  #define OSD_Win_Num(a)      0x9e, a-1
 205      =1  #define OSD_Win_Start_Addr    0xa0
 206      =1  #define OSD_Win_Attr(a)       a
 207      =1  #define OSD_Win_Start(h,v)       (BYTE)(((WORD)h>>8) | (((WORD)v>>8)<<4)),(BYTE)h, (BYTE)v
 208      =1  #define OSD_Win_Width(a)      a
 209      =1  #define OSD_Win_Height(a)     a
 210      =1  #define OSD_Win_Border(a)     a
 211      =1  #define OSD_Win_HBorder(a)      a
 212      =1  #define OSD_Win_VBorder(a)      a
 213      =1  #define OSD_Win_CH_Space(a)     a
 214      =1  #define OSD_Win_ZM_SAddr(h,v,a)   ((h<<6)|(v<<4)|(a>>8)), (BYTE)a
 215      =1  #define OSD_Win_Shadow(a)     a
 216      =1  #define OSD_Win_Blending(a)     a
 217      =1  #define OSD_Win_CH_BorderShadow(a)  a
 218      =1  
 219      =1  
 220      =1  #define SetOSDWindowNum(winno)    WriteTW88(TW88_WINNUM, winno-1)
 221      =1  
 222      =1  //#define  OSD_Window_Attr(Trans_en,Color,3D_Type,3D_en,W_en)       (((( Trans_en | Color ) | 3D_Type) | 3
             -D_en) | W_en)
 223      =1  #define  OSD_Window_Attr(a,b,c,d,e)                 (((( a | b ) | c) | d) | e)
 224      =1  #define  OSD_WShadow_Attr(W_Shadow_en,Color,Width)          W_Shadow_en | Color | Width
 225      =1  //#define  OSD_Blending(en,level)                   en | (level & 0x0f)
 226      =1  //#define  OSD_Ch_Effect(Multi, Effect_En, ShadowBorder, Color)   Multi | Effect_En | ShadowBorder | Color 
             - 
 227      =1  
 228      =1  
 229      =1  struct OSDStrInfo 
 230      =1  {
 231      =1    BYTE  cnt;
 232      =1    WORD  addr;
 233      =1    BYTE  attr;
 234      =1    DWORD str;
 235      =1  };
 236      =1  /*
 237      =1  struct BarInfo {
 238      =1    struct RegisterInfo BarCnt;
 239      =1    BYTE  winno;
 240      =1    BYTE  xoff;
 241      =1    BYTE  yoff;
 242      =1    BYTE  color;
 243      =1    int   bar_cnt;
 244      =1  };
 245      =1  */
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 27  

 246      =1  struct FontData {
 247      =1    BYTE  font[27];
 248      =1  } ;
 249      =1  
 250      =1  //====================================================================
 251      =1  //  Internal OSD Function
 252      =1  void CopyCharToOSDRAM_TW88(BYTE Addr, BYTE attr, BYTE ch);
 253      =1  void CopyUDCharToOSDRAM_TW88(BYTE Addr, BYTE attr, BYTE ch);
 254      =1  //BYTE GetOSDWindowWidth_TW88(BYTE winno);
 255      =1  WORD GetOSDWindowSA_TW88(BYTE winno);
 256      =1  void SetOSDWindowX_TW88(BYTE winno, BYTE x);
 257      =1  void SetOSDWindowY_TW88(BYTE winno, BYTE y);
 258      =1  void SetOSDWindowWidth_TW88(BYTE winno, BYTE w);
 259      =1  void SetOSDWindowSA_TW88(BYTE winno, WORD sa);
 260      =1  
 261      =1  void SetOSDItalicsAndUnderline(BYTE italics, BYTE underline);
 262      =1  
 263      =1  void SetOSDHBorderWidth_TW88(BYTE winno, BYTE w);
 264      =1  //BYTE GetOSDWindowColor_TW88(BYTE winno);
 265      =1  void SetOSDWindowColor_TW88(BYTE CCWin, BYTE color);
 266      =1  void EnableOSDRAMAndChangeFont(BYTE type);
 267      =1  void WriteCharToOSDRAM(WORD addr, BYTE ch, BYTE attr);
 268      =1  
 269      =1  
 270      =1  void ShowOSDWindowAll(BYTE on);
 271      =1  void ShowOSDWindow_TW88(BYTE winno, BYTE onoff);
 272      =1  void ClearOSD_TW88(void);
 273      =1  //void CreateOSDWindow_TW88(BYTE winno, BYTE x, BYTE y, BYTE w, BYTE h, WORD sa, BYTE attr);
 274      =1  /*not yet!!
 275      =1  //ljy012304...CC_ADJUST_POS
 276      =1  void SetOSDWindowXS_TW88(BYTE winno, BYTE xs);
 277      =1  void SetOSDWindowYS_TW88(BYTE winno, BYTE ys);
 278      =1  */
 279      =1  
 280      =1  //====================================================================
 281      =1  //  OSDMenu Functions
 282      =1  
 283      =1  //--------------------------------------------------------------------
 284      =1  //  Functions used in only Menu
 285      =1  #define   CONVERT_CODE      0x80
 286      =1  
 287      =1  void InitOSDWindow(BYTE *ptr);
 288      =1  
 289      =1  WORD GetOSDWindowX(BYTE winno);
 290      =1  WORD GetOSDWindowY(BYTE winno);
 291      =1  BYTE CreateOSDWindowOutline(BYTE winno, BYTE w, BYTE color);
 292      =1  void CreateOSDMenuWindow(BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE);
 293      =1  void ClearOSDLine(BYTE winno, BYTE sx, BYTE sy, BYTE cnt, BYTE attr);
 294      =1  void WriteStringToAddr(WORD addr, BYTE *str, BYTE cnt);
 295      =1  void DrawAttrString(WORD addr, BYTE *str, BYTE cnt);
 296      =1  void DrawAttrCnt(WORD addr, BYTE color, BYTE cnt);
 297      =1  void ClearDataCnt(WORD, BYTE);
 298      =1  #define   SetOSDWindowX(A, B)       SetOSDWindowX_TW88(A, B)
 299      =1  #define   SetOSDWindowY(A, B)       SetOSDWindowY_TW88(A, B)
 300      =1  
 301      =1  //--------------------------------------------------------------------
 302      =1  //  Functions used in Menu and others
 303      =1  #define   ShowOSDWindow(A, B)       ShowOSDWindow_TW88(A, B)
 304      =1  #define   ClearOSD()              ClearOSD_TW88()
 305      =1  
 306      =1  //================================================================
 307      =1  //  Font
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 28  

 308      =1  void DownloadUDFont(void);
 309      =1  #ifdef Hs_debug
 310      =1  void DisplayROMFont(BYTE);
 311      =1  void DisplayRAMFont(BYTE);
 312      =1  #endif
 313      =1  void DownloadFont(BYTE cod, CODE_P BYTE *fontdata);
 314      =1  //void DisplayGrid( void );
 315      =1  //void DisplayCone( void );
 316      =1  //void DisplayJapanese( void );
 317      =1  void TestRAMFont( void );
 318      =1  #ifdef BANKING
           =1 void DisplayMGrid( BYTE );
           =1 void DisplayMessage( void );
           =1 void DisplayChinese( void );
           =1 void DisplayJapanese( void );
           =1 void DisplayKorean( void );
           =1 void DisplayGridBank0( BYTE n );
           =1 void DisplayGridBank1( BYTE n );
           =1 #endif
 327      =1  
 328      =1  //================================================================
 329      =1  //  OSD COLOR
 330      =1  void Change_OSDColorLookup(void);
 331      =1  void Reset_OSDColorLookup(void);
 332      =1  
 333      =1  //====================================================================
 334      =1  //        Conversion
 335      =1  //====================================================================
 336      =1  BYTE utoa(WORD value, BYTE *str, BYTE radix);
 337      =1  BYTE ltoa_K(long value, BYTE *str, BYTE);
 338      =1  BYTE strlen( BYTE *str );
 339      =1  
 340      =1  #define CStrlen(A)        strlen(A)
 341      =1  
 342      =1  void WaitEndofDisplayArea(void);
 343      =1  
 344      =1  #endif  // __OSD_BASIC__
 345      =1  
  17          #include "dispinfo.h"
   1      =1  #ifndef __DISPINFO__
   2      =1  #define __DISPINFO__
   3      =1  //==================================================================
   4      =1  //        Display Information
   5      =1  //==================================================================
   6      =1  #if (defined WQVGA) && (defined ANALOG_7INCH)
           =1 #define   INPUTINFO_ZOOM    WINZOOMx1
           =1 #define   LOGO_ZOOM     WINZOOMx3
           =1 
           =1 #else // (defined WQVGA) && (defined SHARP_LQ043T3DX02)
  11      =1  
  12      =1    #ifdef AWT_ML072S
  13      =1    #define   INPUTINFO_ZOOM    WINZOOMx4
  14      =1    #else
           =1   #define   INPUTINFO_ZOOM    WINZOOMx2
           =1   #endif
  17      =1  #define   LOGO_ZOOM     WINZOOMx2
  18      =1  #endif
  19      =1  //#define   VOL_ZOOM      WINZOOMx4
  20      =1  #define   MUTE_ZOOM     WINZOOMx3
  21      =1  #define   TVCHN_ZOOM      WINZOOMx4
  22      =1  #define   RATINGINFO_ZOOM   WINZOOMx3
  23      =1  #define     SCANTV_ZOOM     WINZOOMx2   //ljy012304
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 29  

  24      =1  #define   PCINFO_ZOOM     WINZOOMx2
  25      =1  #define     BAR_ZOOM      WINZOOMx2
  26      =1  
  27      =1  
  28      =1  #define DVRStatus_OSDWIN  4 
  29      =1  #define DVRStatus_ADDR  180
  30      =1  
  31      =1  extern  BYTE  DisplayedOSD;
  32      =1  
  33      =1  
  34      =1  void ClearDisplayedOSD( BYTE newd );
  35      =1  void SetDisplayedOSD( BYTE newd );
  36      =1  BYTE GetDisplayedOSD(void);
  37      =1  void ClearOSDInfo(void);
  38      =1  
  39      =1  void DisplayInput(void);
  40      =1  BYTE ClearInput(void);
  41      =1  BYTE ClearInput2s(void);
  42      =1  
  43      =1  //void DisplayLogo(void);
  44      =1  
  45      =1  void ClearLogo(void);
  46      =1  
  47      =1  void DisplayPCInfo(BYTE CODE *ptr);
  48      =1  void ClearPCInfo(void);
  49      =1  void DisplayAutoAdjust(void);
  50      =1  void ClearAutoAdjust(void);
  51      =1  
  52      =1  
  53      =1  void DisplayVol(void);
  54      =1  #if 0
           =1 void DisplayBrightness(void);
           =1 #endif
  57      =1  #if 0
           =1 void DisplayMuteInfo(void);
           =1 #endif
  60      =1  void ClearMuteInfo(void);
  61      =1  BYTE CheckAndClearOSD(void);
  62      =1  BYTE ClearVlossOsd(void);
  63      =1  #ifdef AWT_ML072S
  64      =1  void VlossHandler(void);
  65      =1  void Check_Vloss(void);
  66      =1  #endif
  67      =1  //==================================================================
  68      =1  //            TV Info
  69      =1  //==================================================================
  70      =1  
  71      =1  BYTE ClearTVInfo(void);
  72      =1  
  73      =1  #endif  // __DISPINFO__
  18          #include "measure.h"
   1      =1  #ifndef __MEASURE__
   2      =1  #define __MEASURE__
   3      =1  
   4      =1  #define EE_DOS        0
   5      =1  
   6      =1  #define EE_SP1        1
   7      =1  #define EE_SP2        2
   8      =1  #define EE_SP3        3
   9      =1  
  10      =1  #define EE_VGA_60     4
  11      =1  #define EE_VGA_66     5
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 30  

  12      =1  #define EE_VGA_70     6
  13      =1  #define EE_VGA_72     7
  14      =1  #define EE_VGA_75     8
  15      =1  #define EE_VGA_85     9
  16      =1  
  17      =1  #define EE_SVGA_56      10
  18      =1  #define EE_SVGA_60      11
  19      =1  #define EE_SVGA_70      12
  20      =1  #define EE_SVGA_72      13
  21      =1  #define EE_SVGA_75      14
  22      =1  #define EE_SVGA_85      15
  23      =1  
  24      =1  #define EE_832_75     16
  25      =1  
  26      =1  #define EE_XGA_60     17
  27      =1  #define EE_XGA_70     18
  28      =1  #define EE_XGA_72     19
  29      =1  #define EE_XGA_75     20
  30      =1  #define EE_XGA_85     21
  31      =1  
  32      =1  #define EE_1152_60      22
  33      =1  #define EE_1152_70      23
  34      =1  #define EE_1152_75      24
  35      =1  
  36      =1  #define EE_SXGA_60      25
  37      =1  #define EE_SXGA_70      26
  38      =1  #define EE_SXGA_75      27
  39      =1  
  40      =1  #define EE_RGB_480P     28
  41      =1  #define EE_RGB_720P     29
  42      =1  #define EE_RGB_720P50   30
  43      =1  #define EE_RGB_1080I    31
  44      =1  #define EE_RGB_1080I50A   32
  45      =1  #define EE_RGB_1080I50B   33
  46      =1  #define EE_RGB_480I     34
  47      =1  #define EE_RGB_576I     35
  48      =1  #define EE_RGB_576P     36
  49      =1  
  50      =1  #define EE_YPbPr_480P   37
  51      =1  #define EE_YPbPr_720P   38
  52      =1  #define EE_YPbPr_720P50   39
  53      =1  #define EE_YPbPr_1080I    40
  54      =1  #define EE_YPbPr_1080I50A 41
  55      =1  #define EE_YPbPr_1080I50B 42
  56      =1  #define EE_YPbPr_480I   43
  57      =1  #define EE_YPbPr_576I   44
  58      =1  #define EE_YPbPr_576P   45
  59      =1  
  60      =1  #define EE_PC_MAX     46
  61      =1  
  62      =1  #define EE_PC_NO_SIGNAL   0xfe
  63      =1  #define EE_PC_UNKNOWN   0xff
  64      =1  
  65      =1  struct _PCMDATA {
  66      =1    CODE_P BYTE  Support;
  67      =1    CODE_P WORD  HAN;
  68      =1    CODE_P WORD  VAN;
  69      =1    CODE_P WORD  IVF;
  70      =1    CODE_P WORD  CLOCK;
  71      =1    CODE_P WORD  low;
  72      =1    CODE_P WORD  high;
  73      =1    CODE_P WORD  Hstart;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 31  

  74      =1    CODE_P WORD  Vstart;
  75      =1    CODE_P WORD  IPF;   // 0.1MHz
  76      =1    CODE_P WORD  PPF;   // 0.1MHz
  77      =1    CODE_P BYTE  VBack;
  78      =1  };
  79      =1  #ifndef AUTOCALC_PC
           =1 
           =1 #ifdef SUPPORT_DTV
           =1 struct _DTVMDATA {
           =1   CODE_P BYTE Reg62;
           =1   CODE_P BYTE RegBC;
           =1   CODE_P BYTE RegBD;
           =1   CODE_P BYTE RegBE;
           =1   CODE_P WORD PHP;
           =1 };
           =1 #endif
           =1 #endif
  91      =1  #if defined XGA
           =1   #define MAX_PPF    90000000
           =1 #elif defined SXGA
           =1   #define MAX_PPF   135000000
           =1 #elif defined WXGA
           =1   #define MAX_PPF    90000000
           =1 #elif defined WVGA
  98      =1    #define MAX_PPF    90000000
  99      =1  #elif defined VGA
           =1   #define MAX_PPF    50000000
           =1 #elif defined SVGA
           =1   #define MAX_PPF    80000000
           =1 #elif defined QVGA
           =1   #define MAX_PPF    30000000
           =1 #elif defined WQVGA
           =1   #define MAX_PPF    30000000
           =1 #endif
 108      =1  
 109      =1  extern BYTE cLastSyncLoss;
 110      =1  extern BYTE PcMode;
 111      =1  
 112      =1  void CompLT170E2(void);
 113      =1  
 114      =1  WORD gap(WORD a, WORD b);
 115      =1  
 116      =1  //===================================================================
 117      =1  WORD GetHpnVpn(BYTE);
 118      =1  
 119      =1  WORD ConvertBasedOnInput(WORD dat);
 120      =1  
 121      =1  BYTE IsDTVInput(void);
 122      =1  
 123      =1  void SetVValueForPanel(WORD vstart);
 124      =1  BYTE SetHValueForPanel(void);
 125      =1  BYTE GetActiveRegion(void);
 126      =1  
 127      =1  BYTE DetectAndSetForVGAInput(BYTE);
 128      =1  #ifdef SUPPORT_DTV
           =1 BYTE DetectAndSetForDTVInput(BYTE);
           =1 #endif
 131      =1  void CheckPCinput(void);
 132      =1  void CheckDTVinput(void);
 133      =1  
 134      =1  WORD GetCoarseValue(void);
 135      =1  BYTE GetPhaseValue(void);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 32  

 136      =1  WORD SetPCCoarseValue(BYTE val);
 137      =1  BYTE SetPhaseValue(BYTE val);
 138      =1  
 139      =1  void DisplayResultAndSetActiveRange(void);
 140      =1  
 141      =1  //=============================================================================
 142      =1  //                    PC Screen Position Move Functions
 143      =1  //=============================================================================
 144      =1  void MoveActiveVpos(BYTE val);    // Up/Down
 145      =1  void MoveActiveHpos(BYTE val);    // Left/Right
 146      =1  
 147      =1  BYTE GetVPosition(void);
 148      =1  BYTE SetVPosition(BYTE val);
 149      =1  BYTE GetHPosition(void);
 150      =1  BYTE SetHPosition(BYTE val);
 151      =1  
 152      =1  void ResetPCValue(void);
 153      =1  
 154      =1  CODE_P BYTE *GetPCInputSourceName(void);
 155      =1  BYTE AutoAdjust(void);
 156      =1  
 157      =1  #endif // __MEASURE__
  19          #include "debug.h"
   1      =1  #ifndef __DEBUG__
   2      =1  #define __DEBUG__
   3      =1  
   4      =1  #define DEBUG_ERR 1
   5      =1  #define DEBUG_WARN  2
   6      =1  #define DEBUG_INFO  3
   7      =1  #define DEBUG_BREAK 4
   8      =1  
   9      =1  #ifdef DEBUG_PAUSE
           =1 #define Pause(a)  { Printf("\r\n"); Printf(a); while(!RS_ready()); RS_rx(); }
           =1 #endif
  12      =1  //#define BURSTLOCK 7
  13      =1  
  14      =1  void DebugWindowControl (void) ;
  15      =1  void Draw_Debug_Char(void);
  16      =1  void DebugWindowCursor( BYTE flag ) ;
  17      =1  void DebugWindowData( BYTE flag ) ;
  18      =1  void Debug_Write(void);
  19      =1  void Debug_Read(void);
  20      =1  
  21      =1  
  22      =1  
  23      =1  #endif  // __DEBUG__
  24      =1  
  25      =1  #ifdef CHIP_MANUAL_TEST
           =1 BYTE DelaynCheck(void);
           =1 void ChipManualTest(void);
           =1 
           =1 #endif
  20          #include "printf.h"
   1      =1  #ifndef __PRINTF__
   2      =1  #define __PRINTF__
   3      =1  
   4      =1  #define _outchar(c) while(1) { if( !RS_Xbusy ) { SBUF = c; RS_Xbusy=1; break; } }
   5      =1  #define Putch(c) _outchar(c)
   6      =1  
   7      =1  #ifdef SERIAL
   8      =1  
   9      =1   void Printf ( const char CODE_P *fmt, ... );
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 33  

  10      =1   void Puts ( CODE_P char *ptr );
  11      =1  
  12      =1  #define TW2835Cmd(a)   Puts ( a )
  13      =1  
  14      =1  #else
           =1 
           =1  #undef  DEBUG
           =1  #define Printf(a,b)  //
           =1  #define Puts(a)      //
           =1 
           =1 #endif
  21      =1  
  22      =1  
  23      =1  #ifndef DEBUG
  24      =1  
  25      =1   #define dPuts(a)   //
  26      =1   #define wPuts(a)   //
  27      =1   #define ePuts(a)   //
  28      =1  
  29      =1  #else
           =1 
           =1  void dPrintf( const char CODE_P *fmt, ... );
           =1  void wPrintf( const char CODE_P *fmt, ... );
           =1  void ePrintf( const char CODE_P *fmt, ... );
           =1 
           =1  void dPuts( CODE_P char *ptr );
           =1  void wPuts( CODE_P char *ptr );
           =1  void ePuts( CODE_P char *ptr );
           =1 
           =1 #endif  // DEBUG
  40      =1  
  41      =1  BYTE Getch(void);
  42      =1  BYTE Getche(void);
  43      =1  
  44      =1  
  45      =1  #endif  //__PRINTF__
  21          #include "udfont.h"
   1      =1  //udfont.h
   2      =1  #define COLORFONT_START 0x60
   3      =1  //#define MAX_FONT_RAM_CHARS  0xa7 //174
   4      =1  #define MAX_FONT_RAM_CHARS  0xC6 //6Kbytes for RAM
   5      =1  code unsigned char RAMFONTDATA[][27];
   6      =1  code unsigned char OSD_Color_LookUp_Data_Table[][8];
   7      =1  
   8      =1  
  22          #include "regmap.h"
   1      =1  #ifndef __REGMAP__
   2      =1  #define __REGMAP__
   3      =1  
   4      =1  //-----------------------------------------------------------------------------
   5      =1  //        Individual Decoder Registers 
   6      =1  //-----------------------------------------------------------------------------
   7      =1  
   8      =1  #define MCU_STOP_MODE 0xc8  // bit 7 is mcu stop, bit5 is MCU debug
   9      =1  
  10      =1  #define LAD0      0xc9  // Low speed AD channel 0
  11      =1  #define LAD1      0xca  // Low speed AD channel 1
  12      =1  
  13      =1  #define REG_PAGE    0xff
  14      =1  #define STATUS0     0xd0
  15      =1  #define STATUS1     0xd1
  16      =1  #define IRQ_EN1     0xd2
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 34  

  17      =1  #define IRQ_EN0     0xd3
  18      =1  
  19      =1  //-----------------------------------------------------------------------------
  20      =1  //        Individual Decoder Registers 
  21      =1  //-----------------------------------------------------------------------------
  22      =1  
  23      =1  #define DECODERADDRESS  TW88I2CAddress
  24      =1  
  25      =1  #define CVFMT     0x1e  // Component Video Format
  26      =1  #define FBSHIFT     0x38  // RGB Anti-Alias Filter/FB Shift Level
  27      =1  #define SHUE      0x3e  // RGB Hue
  28      =1  #define SCONTRAST   0x3b  // RGB Contrast
  29      =1  #define SBRIGHT     0x3a  // RGB Brightness
  30      =1  #define SCbGAIN     0x3c  // RGB Cb Gain
  31      =1  #define SCrGAIN     0x3d  // RGB Cb Gain
  32      =1  #define RGBCONTROL    0x36  // RGB Powerdown..
  33      =1  #define RGBMISC     0x39
  34      =1  #define FBCONTRL    0x3F
  35      =1  
  36      =1  //#define OSD_ADJ     0xce
  37      =1  #define PNLSHARPNESS  0x78  // Sharpness Control
  38      =1  #define OSDWINSTATUS  0x95
  39      =1  //-----------------------------------------------------------------------------
  40      =1  //        Common Registers
  41      =1  //-----------------------------------------------------------------------------
  42      =1  #define CSTATUS     0x01  // Chip Status
  43      =1  #define INFORM      0x02  // Input Format
  44      =1  #define ACNTL     0x06  // Analog Control
  45      =1  #define CROP_HI     0x07  // Cropping High
  46      =1  #define VDELAY_LO   0x08  // Vertical Delay Low
  47      =1  #define VACTIVE_LO    0x09  // Vertical Active Low
  48      =1  #define HDELAY_LO   0x0a  // Horizontal Delay Low
  49      =1  #define HACTIVE_LO    0x0b  // Horizontal Active Low
  50      =1  #define CNTRL1      0x0c  // Control 1
  51      =1  
  52      =1  #define BRIGHT      0x10  // Brightness Control
  53      =1  #define CONTRAST    0x11  // Contrast Control
  54      =1  #define SHARPNESS   0x12  // Sharpness Control
  55      =1  #define SAT_U     0x13  // Chroma(U) Gain
  56      =1  #define SAT_V     0x14  // Chroma(V) Gain
  57      =1  #define HUE       0x15  // Hue Conrol
  58      =1  #define V_PEAKING   0x17  // Vertical Peaking
  59      =1  
  60      =1  #define CC_STATUS   0x1a  // CC/EDS Status
  61      =1  #define CC_DATA     0x1b  // CC/EDS Data
  62      =1  #define SDT       0x1c  // Standard Selection
  63      =1  #define SDTR      0x1d  // Standard Recognition
  64      =1  
  65      =1  #define V_CONTROL2    0x29  // Vertical Control II
  66      =1  #define HFILTER     0x2c
  67      =1  #define MISC1     0x2d  // Miscellaneous Control 1
  68      =1  #define MISC2     0x2e  // Miscellaneous Control 2
  69      =1  #define MISC3     0x2f  // Miscellaneous Control 2
  70      =1  
  71      =1  #define VBI_CNTL2   0x34  // VBI control 2 - WSSEN
  72      =1  #define CC_ODDLINE    0x35  // CC Odd Line
  73      =1  
  74      =1  #define LADC0     0xc9  //LADC Channel 0 Input Value 
  75      =1  #define LADC1     0xca  //LADC Channel 1 Input Value 
  76      =1  
  77      =1  #define WriteDecoder(index, val)    WriteTW88( index, val )
  78      =1  #define ReadDecoder(index)        ReadTW88( index )
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 35  

  79      =1  
  80      =1  #endif // __REGMAP__
  81      =1  
  23          #include "externs.h"
   1      =1  //
   2      =1  //Externs.h : Register declaration
   3      =1  //
   4      =1  #ifdef INTERNAL_MCU
           =1 extern xdata BYTE REG00, REG01, REG02, REG03, REG04, REG05, REG06, REG07, REG08, REG09, REG0a, REG0b, REG0
             -c, REG0d, REG0e, REG0f,
           =1       REG10, REG11, REG12, REG13, REG14, REG15, REG16, REG17, REG18, REG19, REG1a, REG1b, REG1c, REG1d, REG1
             -e, REG1f,
           =1       REG20, REG21, REG22, REG23, REG24, REG25, REG26, REG27, REG28, REG29, REG2a, REG2b, REG2c, REG2d, REG2
             -e, REG2f,
           =1       REG30, REG31, REG32, REG33, REG34, REG35, REG36, REG37, REG38, REG39, REG3a, REG3b, REG3c, REG3d, REG3
             -e, REG3f,
           =1       REG40, REG41, REG42, REG43, REG44, REG45, REG46, REG47, REG48, REG49, REG4a, REG4b, REG4c, REG4d, REG4
             -e, REG4f,
           =1       REG50, REG51, REG52, REG53, REG54, REG55, REG56, REG57, REG58, REG59, REG5a, REG5b, REG5c, REG5d, REG5
             -e, REG5f,
           =1       REG60, REG61, REG62, REG63, REG64, REG65, REG66, REG67, REG68, REG69, REG6a, REG6b, REG6c, REG6d, REG6
             -e, REG6f,
           =1       REG70, REG71, REG72, REG73, REG74, REG75, REG76, REG77, REG78, REG79, REG7a, REG7b, REG7c, REG7d, REG7
             -e, REG7f,
           =1       REG80, REG81, REG82, REG83, REG84, REG85, REG86, REG87, REG88, REG89, REG8a, REG8b, REG8c, REG8d, REG8
             -e, REG8f,
           =1       REG90, REG91, REG92, REG93, REG94, REG95, REG96, REG97, REG98, REG99, REG9a, REG9b, REG9c, REG9d, REG9
             -e, REG9f,
           =1       REGa0, REGa1, REGa2, REGa3, REGa4, REGa5, REGa6, REGa7, REGa8, REGa9, REGaa, REGab, REGac, REGad, REGa
             -e, REGaf,
           =1       REGb0, REGb1, REGb2, REGb3, REGb4, REGb5, REGb6, REGb7, REGb8, REGb9, REGba, REGbb, REGbc, REGbd, REGb
             -e, REGbf,
           =1       REGc0, REGc1, REGc2, REGc3, REGc4, REGc5, REGc6, REGc7, REGc8, REGc9, REGca, REGcb, REGcc, REGcd, REGc
             -e, REGcf,
           =1       REGd0, REGd1, REGd2, REGd3, REGd4, REGd5, REGd6, REGd7, REGd8, REGd9, REGda, REGdb, REGdc, REGdd, REGd
             -e, REGdf,
           =1       REGe0, REGe1, REGe2, REGe3, REGe4, REGe5, REGe6, REGe7, REGe8, REGe9, REGea, REGeb, REGec, REGed, REGe
             -e, REGef,
           =1       REGf0, REGf1, REGf2, REGf3, REGf4, REGf5, REGf6, REGf7, REGf8, REGf9, REGfa, REGfb, REGfc, REGfd, REGf
             -e, REGff;
           =1 
           =1 #endif  // internal MCU only variables
  23      =1  
  24          #include "CPU.h"
   1      =1  #ifndef __CPU__
   2      =1  #define __CPU__
   3      =1  
   4      =1  /*
   5      =1  #ifdef INTERNAL_MCU
   6      =1  #define I2C_SCL   P2_0
   7      =1  #else
   8      =1  #define I2C_SCL   P1_0
   9      =1  #endif
  10      =1  #define I2C_SDA   P1_1
  11      =1  */
  12      =1  #define I2C_SCL     P1_0
  13      =1  #define I2C_SDA     P1_1
  14      =1  #ifdef SUPPORT_SDCARD  //ryan@20170824 
           =1 #define BUF_MAX     8
           =1 #define DVR_BUF_MAX   30
           =1 #else
  18      =1  #define BUF_MAX     20
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 36  

  19      =1  #define DVR_BUF_MAX   8
  20      =1  #endif
  21      =1  
  22      =1  #ifdef REMO_RC5
           =1 #define EnableRemoconInt()  { RemoDataReady = 0;  EX0 = 1;}
           =1 #endif
  25      =1  void  InitCPU(void);
  26      =1  void  InitVars(void);
  27      =1  void  InitTechwell(void);
  28      =1  void  main_init (void);
  29      =1  void  PowerDown( void );
  30      =1  #if 0
           =1 BYTE  OKSleepTime(void);
           =1 #endif
  33      =1  #ifdef REMO_RC5
           =1 void  InitForRemo(void);
           =1 #endif
  36      =1  void  PowerLED(BYTE flag);
  37      =1  void    Wait_ms(WORD Tms);
  38      =1  BYTE    TW2835Command(char,char,char,char,char);
  39      =1  
  40      =1  #ifdef Monitor_debug
  41      =1  BYTE RS_rx(void);
  42      =1  #endif
  43      =1  
  44      =1  #endif
  45      =1  
  25          
  26          #include "panel.h"
   1      =1  //PanelConfig
   2      =1  
   3      =1    #if   defined SXGA
           =1             #define PHR_ 1280
           =1             #define PVR_ 1024
           =1   #elif defined XGA 
           =1             #define PHR_ 1024
           =1             #define PVR_ 768
           =1   #elif defined SVGA
           =1             #define PHR_ 800
           =1             #define PVR_ 600
           =1   #elif defined VGA
           =1             #define PHR_ 640
           =1             #define PVR_ 480
           =1   #elif defined QVGA
           =1             #define PHR_ 320
           =1             #define PVR_ 240
           =1   #elif defined WXGA
           =1             #define PHR_ 1280 //1366
           =1             #define PVR_ 768
           =1   #elif defined WSVGA
           =1             #define PHR_ 1024
           =1             #define PVR_ 600
           =1   #elif defined WVGA
  25      =1              #define PHR_ 800
  26      =1              #define PVR_ 480//600
  27      =1    #elif defined WQVGA
           =1         //    #define PHR_ 960 //480
           =1         //    #define PVR_ 237
           =1             #define PHR_ 480 //480
           =1             #define PVR_ 240
           =1   #endif
  33      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 37  

  34      =1   
  35      =1  
  36      =1  /*
  37      =1  #define ACTIVE_LOW      0
  38      =1  #define ACTIVE_HIGH     1
  39      =1  
  40      =1  CODE struct PanelConfig {
  41      =1    unsigned    x_res,          y_res;
  42      =1    unsigned char h_sync_min_pulse_width, v_sync_min_pulse_width;
  43      =1    unsigned    h_min_back_porch;
  44      =1    unsigned char h_sync_polarity,    v_sync_polarity;
  45      =1    unsigned    dot_clock,        max_clock;      // in unit Mhz*10
  46      =1    unsigned char pixs_per_clock;
  47      =1    unsigned char DE_only;
  48      =1  } PanelConfig=
  49      =1    {
  50      =1    //----------------------------------------------------
  51      =1    #ifdef WXGA
  52      =1    //LG  LM171W01 WXGA
  53      =1    1280,     768,
  54      =1    8,        1,
  55      =1    8,
  56      =1    ACTIVE_LOW,   ACTIVE_LOW,
  57      =1    #ifdef DOUBLE_PIXEL
  58      =1    320,      470,
  59      =1    2,
  60      =1    #else
  61      =1    650,      950,          //65Mhz
  62      =1    1,
  63      =1    #endif
  64      =1    0
  65      =1    //----------------------------------------------------
  66      =1    #elif defined XGA
  67      =1    //Samsung  LT150x1-151 XGA
  68      =1    1024,     768,
  69      =1    68,       1,
  70      =1    80,
  71      =1    ACTIVE_LOW,   ACTIVE_LOW,
  72      =1    #ifdef DOUBLE_PIXEL
  73      =1    325,      400,          //32.5Mhz
  74      =1    2,
  75      =1    #else
  76      =1    650,      800,
  77      =1    1,
  78      =1    #endif
  79      =1    0
  80      =1    //----------------------------------------------------
  81      =1    #elif defined SXGA
  82      =1    //Samsung  LT170E2-131  SXGA
  83      =1    1280,     1024,
  84      =1    1,        1,
  85      =1    1,
  86      =1    ACTIVE_LOW,   ACTIVE_LOW,
  87      =1    #ifdef DOUBLE_PIXEL
  88      =1    540,      540,          //54.5Mhz
  89      =1    2,
  90      =1    #else
  91      =1    1080,     1080,
  92      =1    1,
  93      =1    #endif
  94      =1    0
  95      =1    //----------------------------------------------------
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 38  

  96      =1    #elif defined WSVGA           // Thosiba
  97      =1    1024,     600,
  98      =1    8,        3,
  99      =1    1,//80,       
 100      =1    ACTIVE_LOW,   ACTIVE_LOW,
 101      =1    #ifdef DOUBLE_PIXEL
 102      =1    325,      450,
 103      =1    2,
 104      =1    #else
 105      =1    500,      550,          //50Mhz
 106      =1    1,
 107      =1    #endif
 108      =1    0
 109      =1    //----------------------------------------------------
 110      =1  
 111      =1    #elif defined SVGA
 112      =1    //NEC NL8060AC26-11 SVGA
 113      =1    800,      600,
 114      =1    2,        1,
 115      =1    13,
 116      =1    ACTIVE_LOW,   ACTIVE_LOW,
 117      =1    #ifdef DOUBLE_PIXEL
 118      =1    384,      500,          //38.4MHz
 119      =1    2,
 120      =1    #else
 121      =1    670,      1000,
 122      =1    1,
 123      =1    #endif
 124      =1    0
 125      =1    //----------------------------------------------------
 126      =1    #elif defined VGA
 127      =1    //NEC NL6448AC33  VGA         // OK with SetPanelRegisters
 128      =1    640,      480,
 129      =1    10,       1,
 130      =1    4,
 131      =1    ACTIVE_LOW,   ACTIVE_LOW,
 132      =1    #ifdef DOUBLE_PIXEL
 133      =1    130,      150,          //25.2MHz
 134      =1    2,
 135      =1    #else
 136      =1    250,      300,
 137      =1    1,
 138      =1    #endif
 139      =1    0
 140      =1    //----------------------------------------------------
 141      =1  
 142      =1    #elif defined WVGA
 143      =1    // Panasonic  EDTCB27QBF WVGA
 144      =1    800,      480,
 145      =1    4,        1,
 146      =1    7,
 147      =1    ACTIVE_LOW,   ACTIVE_LOW,
 148      =1    #ifdef DOUBLE_PIXEL
 149      =1    166,      200,          //33.2MHz
 150      =1    2,
 151      =1    #else
 152      =1    332,      360,          //33.2MHz
 153      =1    1,
 154      =1    #endif
 155      =1    0
 156      =1  
 157      =1    //----------------------------------------------------
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 39  

 158      =1    #else
 159      =1    // Default : XGA panel
 160      =1    // Samsung  LT150x1-151 XGA
 161      =1    1024,     768,
 162      =1    68,       1,
 163      =1    80,
 164      =1    ACTIVE_LOW,   ACTIVE_LOW,
 165      =1    #ifdef DOUBLE_PIXEL
 166      =1    325,      400,          //32.5Mhz
 167      =1    2,
 168      =1    #else
 169      =1    650,      800,          //32.5Mhz
 170      =1    1,
 171      =1    #endif
 172      =1    0
 173      =1    #endif
 174      =1    };
 175      =1  
 176      =1  */
  27          #include "osdmenu.h"
   1      =1  //osdmenu.h
   2      =1  //LJY10292001
   3      =1  #ifndef __OSDMENU__
   4      =1  #define __OSDMENU__
   5      =1  
   6      =1  //=======================================================================
   7      =1  // 
   8      =1  //BYTE GetOSDDuration(void);
   9      =1  
  10      =1  void ResetVideoValue(void);
  11      =1  //#if defined( SUPPORT_PC ) || defined( SUPPORT_DTV )
  12      =1  //void ResetPCValue(void);
  13      =1  //#endif
  14      =1  BYTE GetOSDMenuLevel( void );
  15      =1  
  16      =1  void DrawMenulist(BYTE);
  17      =1  void Display_EnterPin(void);
  18      =1  void OSDHighMenu_sub(void);
  19      =1  void ResetOSDValue(void);
  20      =1  #ifdef E_Wintek
           =1 void ResetUESROSDValue(void);
           =1 #endif
  23      =1  //BYTE OnChangingValue(void);
  24      =1  //Not used yet *******************BYTE OnChangingTime(void);
  25      =1  
  26      =1  //WORD GetOSDclock(void);
  27      =1  
  28      =1  #ifdef HS_NEWOSDMENU
           =1 void InitOSDMenu(BYTE OSD_ID);
           =1 void OpenOSDMenu(BYTE OSD_ID);
           =1 #else
  32      =1  void InitOSDMenu(void);
  33      =1  void OpenOSDMenu(void);
  34      =1  #endif
  35      =1  BYTE CloseOSDMenu(void);
  36      =1  
  37      =1  void OpenFORMATMenu(void);
  38      =1  void OSDHighMenu(void);
  39      =1  void OSDSelect(void);
  40      =1  void OSDCursorMove(BYTE flag );
  41      =1  void OSDLeftRight(BYTE flag );
  42      =1  void OSDValueUpDn(BYTE flag);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 40  

  43      =1  WORD SetItemValue( BYTE id, BYTE flag );
  44      =1  BYTE DoAction(BYTE id);
  45      =1  
  46      =1  BYTE SaveValue1(void);
  47      =1  void ClearValueWin(void);
  48      =1  
  49      =1  void OSDNumber( BYTE num );
  50      =1  
  51      =1  void Set4WideScreen(BYTE id);
  52      =1  
  53      =1  void SetRGBContrast( BYTE id, BYTE val );
  54      =1  BYTE SetPCColorTemp(BYTE flag);
  55      =1  void ResetPanelAttributeValue(void);
  56      =1  WORD GetItemValue( BYTE);
  57      =1  void DisplayViewBar( WORD,BYTE);
  58      =1  void DrawNum(WORD, CODE_P struct NumType *, WORD);
  59      =1  void DrawStringByLang( WORD, CODE_P struct EnumType *, WORD);
  60      =1  
  61      =1  void DisplayVolumebar(BYTE val);
  62      =1  BYTE GetOSDLang(void);
  63      =1  void InitOSDMenuXY(void);
  64      =1  
  65      =1  void Display_TVGuide_Window(void);
  66      =1  void Display_TVGuide_Status(void);
  67      =1  
  68      =1  void ChangeVchip_LevelCursor(BYTE);
  69      =1  void ChangeVchip_ContentCursor(BYTE);
  70      =1  void Select_VchipLevel(void);
  71      =1  void SetVideoMode(BYTE mode);
  72      =1  BYTE GetVideoDatawithOffset(BYTE offset);
  73      =1  void SetVideoContrast(BYTE newv);
  74      =1  void SetVideoBrightness(BYTE newv);
  75      =1  void SetVideoHue(BYTE newv) ;
  76      =1  void SetVideoSaturation(BYTE svtype, BYTE newv) ;
  77      =1  BYTE SetVideoSharpness(BYTE flag) ;
  78      =1  void SetVideoBacklight(BYTE newv) ;
  79      =1  //------------------------------------------------andy awt 981013
  80      =1  //void DaySelect(BYTE);
  81      =1  void CAMOutDSel(BYTE val);
  82      =1  void DVRAodioSel(BYTE  val);
  83      =1  
  84      =1  //------------------------------------------------andy awt 981013
  85      =1  
  86      =1  void DisplayLineOSD(void);  // OSD Line display Demo
  87      =1  #ifdef CENEC_OSDMENU_ACCM8
           =1 BYTE ChkOSDMENU_TOPWIN(void);  //Weylis 080930
           =1 BYTE ChkOSDMENU_WINDOW(void);
           =1 BYTE ChkOSDMENU(void);
           =1 #endif
  92      =1  
  93      =1  #ifdef AWT_ADD_TRIGGER_DELAY_FUN  //Pinchi 20150209 add
  94      =1  void AWT_DisplayViewBar(WORD addr , BYTE val);
  95      =1  #endif
  96      =1  struct MenuType {
  97      =1    BYTE  width,  height;
  98      =1    BYTE  TitleColor; 
  99      =1    BYTE  CursorColor;
 100      =1  };
 101      =1  
 102      =1  struct NumType {
 103      =1    BYTE  PrePostCharLen;   // high nibble(pre) / low nibble(post)
 104      =1    BYTE  PrePostChar[4];
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 41  

 105      =1  };
 106      =1  
 107      =1  struct NumberStringType {
 108      =1    BYTE  x, y;
 109      =1    BYTE    width;
 110      =1    BYTE  BackColor;
 111      =1    BYTE  Radix;
 112      =1    BYTE  NumColor;
 113      =1    BYTE    MaxLen;       // maximum length of string
 114      =1    BYTE  PrePostCharLen;   // high nibble(pre) / low nibble(post)
 115      =1    BYTE  PrePostChar[3];
 116      =1  };
 117      =1  
 118      =1  struct TimeType {
 119      =1    BYTE  x, y;
 120      =1    BYTE    width;
 121      =1    BYTE  BackColor;
 122      =1    BYTE  Format;       //_24H_TIME
 123      =1    BYTE  TimeColor;
 124      =1    BYTE    CursorColor;
 125      =1  };
 126      =1  
 127      =1  struct EnumType {
 128      =1    BYTE    Sz;//size
 129      =1    BYTE    ByLang;
 130      =1    BYTE  Str[15];      // doesn't matter the size !!!
 131      =1  };
 132      =1  
 133      =1  #define ICON_CH_SZ    2
 134      =1  //#define BAR_NUM_SZ    4
 135      =1  #define ICON_BUF_SZ   2
 136      =1  struct DefineMenu {
 137      =1    //WORD            Icon[ICON_BUF_SZ];  
 138      =1    BYTE        CODE  *Icon;
 139      =1    BYTE            **Desc;       
 140      =1    BYTE            PreFnId, 
 141      =1                  PostFnId;
 142      =1  //  void    (*CalltoFunction)(void);            // Un/Dn/Sel Function
 143      =1    BYTE            IconColor;      //NIL: not to display icon
 144      =1    BYTE            DescColor;      //NIL: not to display desc. (IconColor==NIL && DescColor==NIL)->Last Item
 145      =1    struct DefineMenu CODE  *Child;
 146      =1    BYTE            Type;       // MENU, CHOICEMENU, BAR, NUMBER, TIME, ACTION, ENUM_STRING
 147      =1    BYTE            ActiveWithCursor;
 148      =1    BYTE            Id;
 149      =1    BYTE        CODE  *TypeData;  //MenuType, BarType, NumType,,,
 150      =1  } ;
 151      =1  
 152      =1  struct PictureInfo {
 153      =1  
 154      =1    BYTE Register_Addr;
 155      =1    BYTE EEPROM_Addr;
 156      =1    struct RegisterInfo   CODE  *Control_Range;
 157      =1  };
 158      =1  
 159      =1  
 160      =1  //-------------------------------------------------------------------
 161      =1  // OSD Window Information
 162      =1  //-------------------------------------------------------------------
 163      =1  // Window Number
 164      =1  #define OSDCURSORWINDOW     1
 165      =1  #define OSDMENUWINDOW       OSDCURSORWINDOW+1
 166      =1  #define OSDMENU_TOPWIN      OSDCURSORWINDOW+2
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 42  

 167      =1  #define OSDMENU_TITLEWIN    OSDCURSORWINDOW+3
 168      =1  #define OSDBARWINDOW      OSDCURSORWINDOW
 169      =1  
 170      =1  #define TECHWELLOGO_OSDWIN    1 
 171      =1  #define TVINFO_OSDWIN       2 
 172      =1  #define FONTTEST_OSDWIN     2 
 173      =1  #define INPUTINFO_OSDWIN    3  
 174      =1  #define RATINGINFO_OSDWIN     1 
 175      =1  #define PCINFO_OSDWIN       3
 176      =1  #define VLOSSINFO_OSDWIN    4
 177      =1  
 178      =1  //-------------OSDMENU_TITLEWIN------------------------------------------------------
 179      =1  // Window Start address
 180      =1  #define OSDMENU_MAINADDR  0
 181      =1  //#define OSDMENU_SUBADDR     OSDMENU_MAINADDR+15    //25*9:196
 182      =1  //#define OSDMENU_SUBADDR     OSDMENU_MAINADDR+HS_WIDTH //0+40   //25*9:196
 183      =1  //#define OSDMENU_SUBADDR     OSDMENU_MAINADDR+10 //0+40   //25*9:196
 184      =1  #define OSDMENU_SUBADDR     OSDMENU_MAINADDR + 14 //0+40   //25*9:196  // Weylis 121008 清除 Icon 後面
 185      =1  
 186      =1  #define OSDMENU_BARADDR   200 //OSDMENU_SUBADDR+225    //256   //25x2:50
 187      =1  
 188      =1  #ifdef WQVGA
           =1 #define INPUTINFO1_ADDR   INPUTINFO_ADDR+17 //17x3:51
           =1 #else
 191      =1  #define INPUTINFO1_ADDR   INPUTINFO_ADDR+34 //17x2:51
 192      =1  #endif
 193      =1  
 194      =1  #define MUTEINFO_ADDR     INPUTINFO1_ADDR+51  // 4x1:4
 195      =1  #define TVCHINFO_ADDR     MUTEINFO_ADDR//324  // 3X1:3
 196      =1  #define LOGO_ADDR     0
 197      =1  #ifdef AWT_ML072S
 198      =1  #define RATINGINFO_ADDR   (34)  //addr:210(8x1:8)
 199      =1  #else
           =1 #define RATINGINFO_ADDR   0 //addr:210(8x1:8)
           =1 #endif
 202      =1  #define PCMEASUREINFO_ADDR  OSDMENU_BARADDR //10x1
 203      =1  #ifdef QUAD
           =1 #define INPUTINFO_ADDR    160 // 9x1:9
           =1 #else
 206      =1  #define INPUTINFO_ADDR    0///24  // 9x1:9
 207      =1    #ifdef AWT_ML072S
 208      =1    #define INPUTINFO_MIRROR_ADDR 0//83 //william-v1.0-970804
 209      =1    #else
           =1   #define INPUTINFO_MIRROR_ADDR 73//83  //william-v1.0-970804
           =1   #endif
 212      =1  #define INPUTINFO_WIDTH   40  // 9x1:9    //william-v1.0-971111
 213      =1  #endif
 214      =1  #define OSD_VLOSS_ADDR  33 
 215      =1  
 216      =1  
 217      =1  //--------------------------------------------------------------------
 218      =1  // OSD Menu Position Range
 219      =1  #if ((defined WQVGA) && (defined ANALOG_7INCH)) || ((defined QVGA) && (defined SHARP_LQ050Q5DR01))
           =1   #define OSD_PHR_ PHR_/2
           =1 #else
 222      =1    #define OSD_PHR_ PHR_
 223      =1  #endif
 224      =1  
 225      =1  #define OSDHSTART_MAX (OSD_PHR_-(12+1)*25 - 56*2 -4)  //PHR - (pixelsize +Hspace)*MenuWidth - Hborder*2 - 
             -outlinewidth*2
 226      =1  #define OSDVSTART_MAX (PVR_-(18+11)*9 - 5*2 ) //  PVR - (Linesize+Vspace)*MENU_HEIGHT - Vborder*2  - outli
             -newidth*2
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 43  

 227      =1  
 228      =1  #define OSDHSTART_MAX_A (OSD_PHR_-(12+2)*25 - 56*2 -8) //OSDHSTART_MAX  //PHR - (pixelsize +Hspace)*MenuWi
             -dth - Hborder*2 - outlinewidth*2
 229      =1  #define OSDVSTART_MAX_A OSDVSTART_MAX  //  PVR - (Linesize+Vspace)*MENU_HEIGHT - Vborder*2  - outlinewidth*
             -2
 230      =1  
 231      =1  #define OSDMENUX_MIN 1//0
 232      =1  #define OSDMENUX_MAX (OSDHSTART_MAX>>3)
 233      =1  #define OSDMENUX_50  (OSDHSTART_MAX>>4)
 234      =1  
 235      =1  #define OSDMENUY_MIN 2//0
 236      =1  #define OSDMENUY_MAX (OSDVSTART_MAX>>2)
 237      =1  #define OSDMENUY_50  (OSDVSTART_MAX>>3)
 238      =1  
 239      =1  #ifdef HS_NEWOSDMENU  //Weylis -@121008
           =1 // HS OSD Style
           =1 #define HS_WIDTH      40
           =1 #define HS_CHSPACE      14
           =1 //#define HS_CHSPACE      18
           =1 #define HS_ICONSPACE    1
           =1 #define HS_ICONSADDR    0
           =1 //#define HS_ICONSPACE    2
           =1 //#define HS_ICONSADDR    8
           =1 #endif
 249      =1  
 250      =1  //--------------------------------------------------------------------
 251      =1  // OSD Menu Width, Height 
 252      =1  #ifdef E_Wintek
           =1 #define ICON_HIGH       0x14
           =1 #else
 255      =1  #define ICON_HIGH       0x0a
 256      =1  #endif
 257      =1  
 258      =1  #define TOTAL_MAX_HIGHT     9
 259      =1  #define TOTAL_TOP_HEIGHT    5 // Include blank line!
 260      =1  #define TOPMENU_WIDTH     2
 261      =1  #define TOPMENU_HEIGHT      4 
 262      =1  
 263      =1  #if (defined QVGA) && (defined SHARP_LQ050Q5DR01)
           =1 #define MENU_WIDTH        17 //23//25 
           =1 #define TITLE_MAX_DESC      17 //25 //
           =1 #define BAR_LENGTH        0
           =1 #else
 268      =1  //#define MENU_WIDTH        23  //23//25 
 269      =1  //#define MENU_WIDTH        26  //ryan@20170821
 270      =1  #ifdef AWT_ML072S
 271      =1  #define MENU_WIDTH        19  
 272      =1  #else
           =1 #define MENU_WIDTH        24  //ryan@20170821
           =1 #endif
 275      =1  
 276      =1  #define TITLE_MAX_DESC      23  //25  //
 277      =1  #define BAR_LENGTH        5  //8
 278      =1  #endif
 279      =1  
 280      =1  #ifdef TW8816
 281      =1  #define MENU_HEIGHT       8  //6 
 282      =1  #else
           =1 #define MENU_HEIGHT       7  //6 
           =1 #endif
 285      =1  //#define BARNUM_LENGTH       8  //11
 286      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 44  

 287      =1  #ifdef AWT_ML072S
 288      =1  #define BARNUM_LENGTH       4//ryan@20170821
 289      =1  #else
           =1 #define BARNUM_LENGTH       9//ryan@20170821
           =1 #endif
 292      =1  
 293      =1  
 294      =1  #ifdef REFERENCE
           =1 #define BACK_COLOR        BG_COLOR_CYAN
           =1 #define DEFAULT_COLOR     BG_COLOR_CYAN   | CH_COLOR_WHITE
           =1 //#define ACTIVE_COLOR      BG_COLOR_YELLOW | CH_COLOR_WHITE
           =1 #define TITLE_BACK_COLOR    BG_COLOR_MAGENTA
           =1 #define TITLE_COLOR       TITLE_BACK_COLOR | CH_COLOR_YELLOW
           =1 #define COMMENT_COLOR     TITLE_BACK_COLOR | CH_COLOR_WHITE
           =1 #define CURSOR_COLOR      BG_COLOR_YELLOW | CH_COLOR_BLUE
           =1 #define OSD_INFO_COLOR      DEFAULT_COLOR
           =1 #define BAR_COLOR       DEFAULT_COLOR 
           =1 #define BAR_NUM_COLOR     DEFAULT_COLOR
           =1 #define NUM_COLOR       DEFAULT_COLOR
           =1 #define OSDMENU_OUTLINE_COLOR BG_COLOR_BLUE
           =1 #else
 308      =1  #define BACK_COLOR        BG_COLOR_CYAN
 309      =1  
 310      =1  #define DEFAULT_COLOR     BG_COLOR_CYAN | CH_COLOR_GREEN//ryan@20170828
 311      =1  
 312      =1  //#define ACTIVE_COLOR      BG_COLOR_YELLOW | CH_COLOR_WHITE
 313      =1  #define TITLE_BACK_COLOR    BG_COLOR_BLUE
 314      =1  #define TITLE_COLOR       TITLE_BACK_COLOR | CH_COLOR_YELLOW
 315      =1  #define COMMENT_COLOR     TITLE_BACK_COLOR | CH_COLOR_WHITE
 316      =1  #define CURSOR_COLOR      BG_COLOR_YELLOW  | CH_COLOR_BLUE
 317      =1  #define OSD_INFO_COLOR      BG_COLOR_CYAN    | CH_COLOR_GREEN
 318      =1  #define BAR_COLOR       DEFAULT_COLOR
 319      =1  #define BAR_NUM_COLOR     DEFAULT_COLOR
 320      =1  #define NUM_COLOR       DEFAULT_COLOR
 321      =1  #define VER_COLOR         BG_COLOR_CYAN   | CH_COLOR_YELLOW   /// V1.1 03/07/07 simonsung
 322      =1  #define OSDMENU_OUTLINE_COLOR   BG_COLOR_CYAN
 323      =1  #define OSD_VLOSS_COLOR     BG_COLOR_CYAN    | CH_COLOR_WHITE
 324      =1  
 325      =1  #endif
 326      =1  
 327      =1  #ifdef HS_NEWOSDMENU
           =1 #define COMMENT1_COLOR      BG_COLOR_CYAN | CH_COLOR_RED
           =1 #endif
 330      =1  
 331      =1  #define Trigger_COLOR       BG_COLOR_CYAN|CH_COLOR_RED      //william-v1.1-970827
 332      =1  #define Mirror_COLOR      BG_COLOR_CYAN|CH_COLOR_YELLOW     //william-v1.1-970827
 333      =1  #ifndef AWT_ML072S
           =1 #define Jump_COLOR        BG_COLOR_CYAN|CH_COLOR_GREEN      //william-v1.1-970827
           =1 #else
 336      =1  #define Jump_COLOR        BG_COLOR_CYAN|CH_COLOR_BLUE     //william-v1.1-970827
 337      =1  #endif
 338      =1  #define Gauge_COLOR1      BG_COLOR_BLACK|CH_COLOR_GREEN 
 339      =1  #define Gauge_COLOR2      BG_COLOR_BLACK|CH_COLOR_YELLOW  
 340      =1  #define Gauge_COLOR3      BG_COLOR_BLACK|CH_COLOR_RED
 341      =1  
 342      =1  //DisplayedOSD
 343      =1  //    new   | MENU  TVINFO    CC    INPUTINFO   PCINFO    RATINGINFO
 344      =1  //  current   |
 345      =1  //============|=========================================================================
 346      =1  //  MENU    |     TVINFO    --    INPUTINFO   PCINFO    MENU + RATINGINFO 
 347      =1  //        |            
 348      =1  //------------|-------------------------------------------------------------------------
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 45  

 349      =1  //  TVINFO    | MENU  TVINFO    --    INPUTINFO   PCINFO    TVINFO+RATING
 350      =1  //------------|-------------------------------------------------------------------------
 351      =1  //  CC      | MENU->  TVINFO->      INPUTINFO->   PCINFO    RATINGINFO
 352      =1  //        |  CC    CC          CC            
 353      =1  //------------|-------------------------------------------------------------------------
 354      =1  //  INPUTINFO | MENU  TVINFO    --    INPUTINFO   PCINFO    --
 355      =1  //------------|-------------------------------------------------------------------------
 356      =1  //  PCINFO    | MENU  x     x   INPUTINFO   PCINFO    x
 357      =1  //------------|-------------------------------------------------------------------------
 358      =1  //  RATINGINFO| MENU  TVINFO     RATING   INPUTINFO   x     RATINGINFO
 359      =1  //                  
 360      =1  
 361      =1  //=======================================================================================
 362      =1  // OSD Menu Constant define.
 363      =1  //=======================================================================================
 364      =1  //Time type
 365      =1  #define _24H_TIME   1
 366      =1  
 367      =1  //for previous, next, parent or child
 368      =1  #define YES       0xfe  
 369      =1  #define NO        0
 370      =1  
 371      =1  //#define OVERWRITE   0
 372      =1  //#define POPUP     1
 373      =1  
 374      =1  //CursorMove
 375      =1  #define VERT      0
 376      =1  #define HORI      1
 377      =1  
 378      =1  //Type of MenuItem
 379      =1  #define OSDMENU     1
 380      =1  #define CHOICEMENU    2
 381      =1  #define ACTION      3
 382      =1  #define BAR       4
 383      =1  #define NUMBER      5
 384      =1  #define CHOICE      6
 385      =1  #define ENUM_STRING   7 //YESNO     7
 386      =1  #define CHOICE1     8
 387      =1  #define TIME      9
 388      =1  #define NUMBER_STRING 10
 389      =1  #define TEXT_STR              11   // V1.1 02/28/07 simonsung
 390      =1  #define INFORMATION              12
 391      =1  #define TEXT_STR_exit 13
 392      =1  
 393      =1  #ifdef HTRV
           =1 #define GRAPH 16
           =1 #endif
 396      =1  
 397      =1  //Bar type
 398      =1  #define LEFT_FILLED   1
 399      =1  #define RIGHT_FILLED  2
 400      =1  #define NO_FILLED   3
 401      =1  
 402      =1  //OSDmenu up and down key
 403      =1  #define UP          1
 404      =1  #define DN          2
 405      =1  #define RIGHT       3
 406      =1  #define LEFT          4
 407      =1  
 408      =1  // Action Id
 409      =1  #define DISP_INFO     0x16
 410      =1  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 46  

 411      =1  #define INPUTSELECTION    0x2f
 412      =1  
 413      =1  #define CHANGE_TO_COMPOSITE     (0x20|CH_TW2835)      // Low nibble need to start from 1 
 414      =1  #define CHANGE_TO_SVIDEO      (0x20|SVIDEO)       // so that it match with COMPOSITE...
 415      =1  #define CHANGE_TO_COMPONENT     (0x20|COMPONENT)    
 416      =1  #define CHANGE_TO_DTV       (0x20|DTV)    
 417      =1  #define CHANGE_TO_TV        (0x20|TV)         
 418      =1  #define CHANGE_TO_PC        (0x20|PC)         
 419      =1  #define CHANGE_TO_DIGITALVGA    (0x20|DIGITALVGA)     
 420      =1  #define CHANGE_TO_SCART       (0x20|SCART)        
 421      =1  
 422      =1  #define OSDPOSITIONMODE     0x10
 423      =1  #define OSD_VPOS      0x11
 424      =1  #define OSD_HPOS      0x12
 425      =1  #define OSD_HALFTONE    0x13
 426      =1  #define OSD_DURATION    0x14
 427      =1  #define RESET_OSDVALUE    0x15
 428      =1  #define OSDLANG       0x16
 429      =1  
 430      =1  #define PANEL_CONTRAST    0x58
 431      =1  #define PANEL_BRIGHTNESS  0x59
 432      =1  #define PANEL_HUE     0x5a
 433      =1  #define PANEL_SHARPNESS   0x5b
 434      =1  #define PANEL_SATURATION  0x5c
 435      =1  
 436      =1  #define PC_VPOS       0x43
 437      =1  #define PC_HPOS       0x44
 438      =1  #define PC_HSIZE      0x4d
 439      =1  
 440      =1  #define PC_CLOCK      0x45
 441      =1  #define PC_PHASE      0x46
 442      =1  
 443      =1  #define AUTOADJUST      0x47
 444      =1  #define AUTOADJUST2     0x48
 445      =1  //#define SAVE_AUTOADJUST   0x49
 446      =1  #define RESET_AUTOADJUST  0x4a
 447      =1  
 448      =1  #define PCCOLORADJUST   0x4b
 449      =1  #define SAVE_COLORADJUST  0x4c
 450      =1  //#define RESET_COLORADJUST 0x4d
 451      =1  
 452      =1  #define RESET_PCVALUE   0x4e
 453      =1  #define CameraOSD     0x4f
 454      =1  
 455      =1  #define PC_COLOR_MODE   0x3f
 456      =1  #define PC_COLOR_TEMP   0x30
 457      =1  #define PC_COLOR_MODE1    0x31
 458      =1  #define PC_COLOR_MODE2    0x32
 459      =1  #define PC_COLOR_MODE3    0x33
 460      =1  #define PC_COLOR_USER   0x34
 461      =1  #define PC_COLOR_R      0x35
 462      =1  #define PC_COLOR_G      0x36
 463      =1  #define PC_COLOR_B      0x37
 464      =1  
 465      =1  #define VIDEO_MODE      0x90
 466      =1  #define VIDEO_MODE1     0x91
 467      =1  #define VIDEO_MODE2     0x92
 468      =1  #define VIDEO_MODE3     0x93
 469      =1  #define VIDEO_USER      0x94
 470      =1  #define VIDEO_CONTRAST    0x95
 471      =1  #define VIDEO_BRIGHTNESS  0x96
 472      =1  #define VIDEO_SATURATION  0x97
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 47  

 473      =1  #define VIDEO_HUE     0x99
 474      =1  #define VIDEO_SHARPNESS   0x9a
 475      =1  #define VIDEO_BACKLIGHT   0x9c    // add new value 
 476      =1  #define RESET_VIDEOVALUE  0x9b
 477      =1  #define RESET_DVRVALUE    0x9e
 478      =1  #define RESET_MonitorVALUE    0x70
 479      =1  
 480      =1  
 481      =1  #ifdef AWT_ADD_TRIGGER_DELAY_FUN  //Pinchi 20150209 add
 482      =1  #define TRIGGER_CamADelay 0xb2
 483      =1  #define TRIGGER_CamBDelay 0xb3
 484      =1  #define TRIGGER_CamCDelay 0xb4
 485      =1  #define TRIGGER_CamRDelay 0xb5
 486      =1  #endif
 487      =1  
 488      =1  #ifdef HTRV
           =1 #define RESET_GAUGESETUP  0x9d   
           =1 #define Gauge_VStart      0x7a   
           =1 #endif
 492      =1  
 493      =1  #ifdef E_Wintek
           =1 #define RESET_USERVALUE 0x9d
           =1 #endif
 496      =1  #define VIDEOPICTURE    0x9f
 497      =1  
 498      =1  #define INPUTSTD      0x6f
 499      =1  #define CHANGE_TO_AUTO    0x60
 500      =1  #define CHANGE_TO_NTSC    (0x60 | NTSC)
 501      =1  #define CHANGE_TO_PAL   (0x60 | PAL)
 502      =1  #define CHANGE_TO_SECAM   (0x60 | SECAM)
 503      =1  #define CHANGE_TO_NTSC4   (0x60 | NTSC4)
 504      =1  #define CHANGE_TO_PALM    (0x60 | PALM)
 505      =1  #define CHANGE_TO_PALN    (0x60 | PALN)
 506      =1  #define CHANGE_TO_PAL60   (0x60 | PAL60)
 507      =1  
 508      =1  #if 0
           =1 #define CLOSED_CAPTION    0x7f
           =1 #define CLOSEDCAP_OFF   0x70
           =1 #define CLOSEDCAP_CC1   0x71
           =1 #define CLOSEDCAP_CC2   0x72
           =1 #define CLOSEDCAP_CC3   0x73
           =1 #define CLOSEDCAP_CC4   0x74
           =1 #define CLOSEDCAP_T1    0x75
           =1 #define CLOSEDCAP_T2    0x76
           =1 #define CLOSEDCAP_T3    0x77
           =1 #define CLOSEDCAP_T4    0x78
           =1 
           =1 #define TV_GUIDE      0x8f
           =1 #define NO_VCHIP_LOCK   0
           =1 #define VCHIP_TV_Y      1
           =1 #define VCHIP_TV_Y7     2
           =1 #define VCHIP_TV_G      3
           =1 #define VCHIP_TV_PG     4
           =1 #define VCHIP_TV_14     5
           =1 #define VCHIP_TV_MA     6
           =1 #define PASSWORD      0x87
           =1 #define NEW_PASSWORD    0x88
           =1 #define CHK_PASSWORD    0x89
           =1 #define RET_CHK_PASSWORD  0x8a
           =1 #endif
 533      =1  
 534      =1  #define MPAA_RATING     0x9f
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 48  

 535      =1  #define NO_MPAA_RATING    0
 536      =1  #define MPAA_G        1
 537      =1  #define MPAA_PG       2
 538      =1  #define MPAA_PG_13      3
 539      =1  #define MPAA_R        4
 540      =1  #define MPAA_NC_17      5
 541      =1  #define MPAA_X        6
 542      =1  
 543      =1  #define TVINSTALL     0xa0
 544      =1  #define SCAN_CHANNEL    0xa1
 545      =1  #define AIR_CABLE_TV    0xa3
 546      =1  #define STORE_CLEAR_TVCHN 0xa4
 547      =1  #define MTS         0xa5
 548      =1  #define EDIT_CHANNEL    0xa6
 549      =1  #define MTS_STEREO      0//0x10
 550      =1  #define MTS_MONO      1//0x11
 551      =1  
 552      =1  #define AUDIO_VOLUME    0xb7
 553      =1  
 554      =1  #if 0 //andy AWT8.4 20090811
           =1 
           =1 #define AUDIO_BALANCE   0xb9
           =1 #define AUDIO_BASS      0xba
           =1 #define AUDIO_TREBLE    0xbb
           =1 
           =1 #define AUDIO_LOUDNESS    0xbc
           =1 #define AUDIO_EFFECT    0xbd
           =1 #define AUDIO_MUTE      0xbe
           =1 #endif
 564      =1  
 565      =1  #define DayChoice           0xb8
 566      =1  #define CAMOSDONOFF         0xb9
 567      =1  #define GAUGEChoice         0xba
 568      =1  #define OsdLockChoice       0xbb
 569      =1  #define PRIORITYChoice      0xcA
 570      =1  #define DVRDisplay    0xcc
 571      =1  
 572      =1  #define CAMAONOFF       0xc1
 573      =1  #define CAMBONOFF         0xc2
 574      =1  #define CAMCONOFF       0xc3
 575      =1  #define CAMRONOFF     0xc4
 576      =1  
 577      =1  #define IMAGEChoice         0xc5 
 578      =1  #define REARChoice          0xc6
 579      =1  #define JUMPChoice          0xc7
 580      =1  #define CAMOUTChoice        0xc8 
 581      =1  #define STIME_STEP        0xc9
 582      =1  #define TriggerVGA        0xcb
 583      =1  #define IMAGE_A_Choice         0xcd
 584      =1  #define IMAGE_B_Choice         0xce
 585      =1  #define IMAGE_C_Choice         0xcf
 586      =1  
 587      =1  #define DELAYCAMA       0xd0
 588      =1  #define DELAYCAMB            0xd1
 589      =1  #define DELAYCAMC       0xd2
 590      =1  #define DELAYCAMR         0xd3
 591      =1  #ifdef USE_CAMD
           =1 #define DELAYCAMD       0xd4
           =1 #endif
 594      =1  #define ReverseMode   0xd6
 595      =1  #ifdef AWT_ML072S //william @20130902 v1.0.1.2
 596      =1  #define JUMP_AV     0xd7
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 49  

 597      =1  #endif
 598      =1  #define MANUAL_TUNE_CHANNEL 0xab
 599      =1  #define FINE_TUNE_CHANNEL 0xac
 600      =1  #define STORE_PALCHANNEL  0xad
 601      =1  
 602      =1  //#define CLEAR_TVCHN     0xb0
 603      =1  //#define STORE_TVCHN     0xb1
 604      =1  
 605      =1  #define WIDESCREEN      0xc0
 606      =1  #define WIDESCREEN_NORMAL 0 
 607      =1  #define WIDESCREEN_WIDE   1 
 608      =1  #define WIDESCREEN_PANO   2
 609      =1  #define WIDESCREEN_FULL   3 
 610      =1  #define WIDESCREEN_ZOOM   4 
 611      =1  
 612      =1  //#define SYSTEM_CLOCK    0xd1
 613      =1  //#define SYSTEM_CLOCK_H    0xd2
 614      =1  //#define WAKEUP_TIME     0xd3
 615      =1  //#define WAKEUP_TIME_H   0xd4
 616      =1  //#define WAKEUP_PR     0xd5
 617      =1  //#define OFF_TIME      0xd6
 618      =1  //#define OFF_TIME_H      0xd7
 619      =1  //#define SLEEP_TIMER     0xd8
 620      =1  
 621      =1  #define Resolution      0xe0
 622      =1  #define FPS         0xe1
 623      =1  #define Quality       0xe2
 624      =1  #define RecordMode      0xe3
 625      =1  #define RecordLength      0xe4
 626      =1  #define PreAlarmLength    0xe5
 627      =1  #define PostAlarmLength   0xe6
 628      =1  #define Apply       0xe7
 629      =1  #if 0 //william-awt ml073q-20120313
           =1 #define ManualRecordStart 0xe8
           =1 #define ManualRecordStop  0xe9
           =1 #define Snapshot        0xea
           =1 #endif
 634      =1  #define FormatSD      0xeb
 635      =1  #define AudioRecord     0xec
 636      =1  #define FirmwareUpdate    0xed
 637      =1  #define ChangePassword    0xee
 638      =1  #define OverWrite     0xef
 639      =1  
 640      =1  #define UpdateConfig      0xd0
 641      =1  #define SDCardDetect      0xd5
 642      =1  
 643      =1  #define Year        0x20
 644      =1  #define Month       0x21
 645      =1  #define Day         0x22
 646      =1  #define Hour        0x23
 647      =1  #define Minute        0x24
 648      =1  
 649      =1  #define DaylightSaving        0x25
 650      =1  #define TimeBeginesMonth      0x26
 651      =1  #define TimeBeginesWeek       0x27
 652      =1  #define TimeBeginesTime       0x28
 653      =1  #define StandardTimeBeginesMonth  0x29
 654      =1  #define StandardTimeBeginesWeek   0x2a
 655      =1  #define StandardTimeBeginesTime   0x2b
 656      =1  #define TimeZone          0x2c
 657      =1  #define FirstNumber         0x2d
 658      =1  #define SecondNumber        0x2e
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 50  

 659      =1  #define ThridNumber         0x2f
 660      =1  #define FourthNumber        0x38
 661      =1  #define WIFIIPNumber        0x39
 662      =1  #define WIFIMACNumber       0x3a
 663      =1  #define GETWAYNumber        0x3b
 664      =1  
 665      =1  #define OSDLANGI      0xd9
 666      =1  #define OSDLANGII     OSDLANGI+1
 667      =1  #define OSDLANGIII      OSDLANGI+2
 668      =1  #define OSDLANGIV     OSDLANGI+3
 669      =1  
 670      =1  #define TOHIGHMENU      0xf1
 671      =1  #define MOVECURSOR2FIRST  0xf2
 672      =1  #define RESET_ALL     0xf3
 673      =1  #define EXITMENU      0xf4
 674      =1  #define DVRParamApply   0xf5
 675      =1  #define DATETIMEApply   0xf6
 676      =1  
 677      =1  #define CHOICE1_VAL     0xfc
 678      =1  #define CHOICE_VAL      0xfd
 679      =1  #define BAR_VAL       0xfe
 680      =1  #define NUM_VAL       0xff
 681      =1  
 682      =1  #define CAMNumberChoice     0xa3 
 683      =1  #define PelcoChoice         0xa4
 684      =1  #define Baud_rateChoice   0xa5
 685      =1  
 686      =1  
 687      =1  #endif  // __OSDMENU__
 688      =1  
  28          #include "HS_DVRProtocol.h"
   1      =1  
   2      =1  #ifndef _HS_DVRProtocol_
   3      =1  #define _HS_DVRProtocol_
   4      =1  
   5      =1  //==================================================
   6      =1  //
   7      =1  //==================================================
   8      =1  
   9      =1  #define bSetDVRParam  0x0001
  10      =1  #define bSetDVRDefault  0x0002
  11      =1  #define bSetDATETIME  0x0004
  12      =1  #define bGetDVRParam  0x0008
  13      =1  #define bGetDVRStatus 0x0010
  14      =1  #define bGetDATETIME  0x0020
  15      =1  #define bBOOKMARK   0x0040
  16      =1  #define bSetSystem    0x0080
  17      =1  #define bHalt_Start   0x0100
  18      =1  #define bSetFormatSD    0x0200  
  19      =1  #define bGetDVRVersion  0x0400  
  20      =1  #define bFW_Update_Start 0x0800
  21      =1  #define bUpdate_CONFIG  0x1000
  22      =1  #define bDoorClose    0x2000
  23      =1  #define bDoorOpen     0x4000
  24      =1  
  25      =1  
  26      =1  enum HS_DvrCommand
  27      =1  {
  28      =1    CMD_NULL,
  29      =1    SetDVRParam,  // 1
  30      =1    SetDVRDefault,
  31      =1    SetDATETIME,
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 51  

  32      =1    GetDVRParam,
  33      =1    GetDVRStatus,
  34      =1    GetDATETIME, 
  35      =1    SetFormatSD, 
  36      =1    SendAlarm, 
  37      =1    GetDVRVersion=0x09, 
  38      =1    SendDVRStatus=0x14,
  39      =1    GetLCDMode=0x15,
  40      =1    SendDVRParam=0x16,
  41      =1    SendDVRParamDT=0x17,
  42      =1    SetFormatSDDone=0x18,
  43      =1    GetInformation=0x19,
  44      =1    SetSystem=0x1a,
  45      =1    GPSReset=0x1b,
  46      =1    Halt_Start=0xc8,
  47      =1    Halt_OK=0xc9,
  48      =1    FW_Update_Start=0xca,
  49      =1    FW_Update_OK=0xcb,
  50      =1    MANUALRECSTART=0xdc,
  51      =1    MANUALRECSTOP=0xdd,
  52      =1    SNAPSHOT=0xde,
  53      =1    BOOKMARK=0xdf,
  54      =1    Update_CONFIG=0xe0,
  55      =1    Update_CONFIG_OK=0xe1,
  56      =1    DoorOpen=0xe2,
  57      =1    DoorClose=0xe3,
  58      =1    CMD_UNKNOWN=0xff,
  59      =1    CMD_NUM
  60      =1  };
  61      =1  
  62      =1  //RS485 TX or RX define
  63      =1  enum
  64      =1  {
  65      =1    RS485_TX,   //RS485 Transmit  
  66      =1    RS485_RX    //Rs485 Receive
  67      =1  };
  68      =1  
  69      =1  enum
  70      =1  {
  71      =1    Baud_rate2400,    
  72      =1    Baud_rate4800,  
  73      =1    Baud_rate9600
  74      =1  };
  75      =1  
  76      =1  
  77      =1  //Camera Command ID define
  78      =1  enum
  79      =1  {
  80      =1  //  CAM_CLEAR,        //Clear 
  81      =1    CAM_ZOOM_OUT_START,     //Zoom Out  Start
  82      =1  //  CAM_ZOOM_OUT_END,     //Zoom Out  End
  83      =1    CAM_ZOOM_IN_START,      //Zoom In Start
  84      =1  //  CAM_ZOOM_IN_END,      //Zoom In End
  85      =1  //  CAM_IRIS_CLOSE_START,   //IRIS Close Start
  86      =1  //  CAM_IRIS_CLOSE_END,   //IRIS Close End
  87      =1  //  CAM_IRIS_OPEN_START,      //IRIS Open Start
  88      =1  //  CAM_IRIS_OPEN_END,      //IRIS Open End
  89      =1  //  CAM_FOCUS_FAR_START,    //Focus Far Start
  90      =1  //  CAM_FOCUS_FAR_END,    //Focus Far End
  91      =1  //  CAM_FOCUS_NEAR_START,   //Focus Near Start
  92      =1  //  CAM_FOCUS_NEAR_END,   //Focus Near End
  93      =1    CAM_SET,        //Set 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 52  

  94      =1    CAM_CALL,       //Call 
  95      =1  //  CAM_FOCUS_SPEED,    //Focus Speed
  96      =1  //  CAM_ZOOM_SPEED,   //Zoom Speed
  97      =1    CAM_PTZ_RIGHT,      //PTZ Right 
  98      =1    CAM_PTZ_LEFT,     //PTZ Left
  99      =1    CAM_PTZ_UP,     //PTZ Up
 100      =1    CAM_PTZ_DOWN,     //PTZ Down
 101      =1    CAM_MENU_ENTER,     //PTZ Down
 102      =1    CAM_Iris_Open,
 103      =1  
 104      =1  //  CAM_PTZ_RIGHT_UP,   //PTZ Right with Up
 105      =1  //  CAM_PTZ_RIGHT_DOWN, //PTZ Right with Down
 106      =1  //  CAM_PTZ_LEFT_UP,    //PTZ Left with Up
 107      =1  //  CAM_PTZ_LEFT_DOWN,  //PTZ Left with Down
 108      =1    CAM_PTZ_STOP      //PTZ Control Stop
 109      =1  };
 110      =1  
 111      =1  void Hs_DvrTxCmdPaser(BYTE Cmd_Id );
 112      =1  void Hs_Protocol_Init(void);
 113      =1  BYTE DvrReceivePaser(void);
 114      =1  void DVRCommandReSend(void);
 115      =1  
 116      =1  #if 0
           =1 BYTE TW2835ReceivePaser(void);
           =1 #endif
 119      =1  extern bit   DVR_Ready;
 120      =1  void CAM_TxCommand_toRS485(BYTE Com_ID);
 121      =1  void Send_PelcoP_Command(void);
 122      =1  void Send_PelcoD_Command(void);
 123      =1  void Send_GE_Command(void);
 124      =1  
 125      =1  #endif
 126      =1  
  29          #include "HS_IOdef.h"
   1      =1  #ifndef _HS_IOdef_
   2      =1  #define _HS_IOdef_
   3      =1  
   4      =1  
   5      =1  #include "Reg.h"
   1      =2  //
   2      =2  //Registers.h : Register declaration
   3      =2  //
   4      =2  
   5      =2  #ifndef __REGISTERS__
   6      =2  #define __REGISTERS__
   7      =2  
   8      =2  #ifdef INTERNAL_MCU
           =2 /*  BYTE Registers  */
           =2 sfr P0    = 0x80;
           =2 sfr P1    = 0x90;
           =2 sfr P2    = 0xA0;
           =2 sfr P3    = 0xB0;
           =2 sfr PSW   = 0xD0;
           =2 sfr ACC   = 0xE0;
           =2 sfr B     = 0xF0;
           =2 sfr SP    = 0x81;
           =2 sfr DPL   = 0x82;
           =2 sfr DPH   = 0x83;
           =2 sfr PCON  = 0x87;
           =2 sfr TCON  = 0x88;
           =2 sfr TMOD  = 0x89;
           =2 sfr TL0   = 0x8A;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 53  

           =2 sfr TL1   = 0x8B;
           =2 sfr TH0   = 0x8C;
           =2 sfr TH1   = 0x8D;
           =2 sfr IE    = 0xA8;
           =2 sfr IP    = 0xB8;
           =2 sfr SCON  = 0x98;
           =2 sfr SBUF  = 0x99;
           =2 
           =2 //sfr P4    = 0xd8;
           =2 
           =2 /*  8052 Extensions  */
           =2 sfr EXIF  = 0x91;   // external interrupt 2,3,4,5 flags should be cleared by software
           =2 sfr T2CON = 0xC8;
           =2 sfr RCAP2L = 0xCA;
           =2 sfr RCAP2H = 0xCB;
           =2 sfr TL2   = 0xCC;
           =2 sfr TH2   = 0xCD;
           =2 sfr EICON = 0xD8;
           =2 sfr EIE   = 0xE8;
           =2 sfr EIP   = 0xF8;
           =2 
           =2 /*  TW88 Core Extension */
           =2 sfr BANKREG   = 0x9A;
           =2 sfr SPICONTROL  = 0x9B;
           =2 sfr T0HIGH    = 0x9C;
           =2 sfr T0LOW     = 0x9D;
           =2 sfr T1HIGH    = 0x9E;
           =2 sfr T1LOW     = 0x9F;
           =2 sfr T2HIGH    = 0x93;
           =2 sfr T2LOW     = 0x94;
           =2 
           =2 /*  BIT Registers  */
           =2 /*  PSW  */
           =2 sbit CY    = 0xD7;
           =2 sbit AC    = 0xD6;
           =2 sbit F0    = 0xD5;
           =2 sbit RS1   = 0xD4;
           =2 sbit RS0   = 0xD3;
           =2 sbit OV    = 0xD2;
           =2 sbit P     = 0xD0;
           =2 
           =2 /*  TCON  */
           =2 sbit TF1   = 0x8F;
           =2 sbit TR1   = 0x8E;
           =2 sbit TF0   = 0x8D;
           =2 sbit TR0   = 0x8C;
           =2 sbit IE1   = 0x8B;
           =2 sbit IT1   = 0x8A;
           =2 sbit IE0   = 0x89;
           =2 sbit IT0   = 0x88;
           =2 
           =2 /*  IE  */
           =2 sbit EA    = 0xAF;
           =2 sbit ES    = 0xAC;
           =2 sbit ET1   = 0xAB;
           =2 sbit EX1   = 0xAA;
           =2 sbit ET0   = 0xA9;
           =2 sbit EX0   = 0xA8;
           =2 
           =2 /*  EIE  */
           =2 sbit EWDI  = 0xEC;    // Watch dog timer interrupt enable
           =2 sbit EX5   = 0xEB;    // external interrupt 5 enable
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 54  

           =2 sbit EX4   = 0xEA;    // external interrupt 4 enable
           =2 sbit EX3   = 0xE9;    // external interrupt 3 enable
           =2 sbit EX2   = 0xE8;    // external interrupt 2 enable
           =2 
           =2 /*  IP  */
           =2 sbit PS    = 0xBC;
           =2 sbit PT1   = 0xBB;
           =2 sbit PX1   = 0xBA;
           =2 sbit PT0   = 0xB9;
           =2 sbit PX0   = 0xB8;
           =2 
           =2 /*  EIP  */
           =2 sbit PWDI  = 0xFC;    // Watch dog timer interrupt priority
           =2 sbit PX5   = 0xFB;    // external interrupt5 priority
           =2 sbit PX4   = 0xFA;    // external interrupt4 priority
           =2 sbit PX3   = 0xF9;    // external interrupt3 priority
           =2 sbit PX2   = 0xF8;    // external interrupt2 priority
           =2 
           =2 /*  P3  */
           =2 sbit RD    = 0xB7;
           =2 sbit WR    = 0xB6;
           =2 sbit T1    = 0xB5;
           =2 sbit T0    = 0xB4;
           =2 sbit INT1  = 0xB3;
           =2 sbit INT0  = 0xB2;
           =2 sbit TXD   = 0xB1;
           =2 sbit RXD   = 0xB0;
           =2 
           =2 /*  SCON  */
           =2 sbit SM0   = 0x9F;
           =2 sbit SM1   = 0x9E;
           =2 sbit SM2   = 0x9D;
           =2 sbit REN   = 0x9C;
           =2 sbit TB8   = 0x9B;
           =2 sbit RB8   = 0x9A;
           =2 sbit TI    = 0x99;
           =2 sbit RI    = 0x98;
           =2 
           =2 /*  8052 Extensions  */
           =2 /*  IE  */
           =2 sbit ET2   = 0xAD;
           =2 
           =2 /*  IP  */
           =2 sbit PT2   = 0xBD;
           =2 
           =2 /*  P1  */
           =2 sbit T2EX  = 0x91;
           =2 sbit T2    = 0x90;
           =2              
           =2 /*  T2CON  */
           =2 sbit TF2   = 0xCF;
           =2 sbit EXF2  = 0xCE;
           =2 sbit RCLK  = 0xCD;
           =2 sbit TCLK  = 0xCC;
           =2 sbit EXEN2 = 0xCB;
           =2 sbit TR2   = 0xCA;
           =2 sbit C_T2  = 0xC9;
           =2 sbit CP_RL2= 0xC8;
           =2 
           =2 sfr CHPENR = 0xF6;
           =2 sfr CHPCON = 0xBF;
           =2 sfr SFRAL  = 0xC4;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 55  

           =2 sfr SFRAH  = 0xC5;
           =2 sfr SFRFD  = 0xC6;
           =2 sfr SFRCN  = 0xC7;
           =2 
           =2 sbit P0_0  = 0x80;
           =2 sbit P0_1  = 0x81;
           =2 sbit P0_2  = 0x82;
           =2 sbit P0_3  = 0x83;
           =2 sbit P0_4  = 0x84;
           =2 sbit P0_5  = 0x85;
           =2 sbit P0_6  = 0x86;
           =2 sbit P0_7  = 0x87;
           =2 
           =2 sbit P1_0  = 0x90;
           =2 sbit P1_1  = 0x91;
           =2 sbit P1_2  = 0x92;
           =2 sbit P1_3  = 0x93;
           =2 sbit P1_4  = 0x94;
           =2 sbit P1_5  = 0x95;
           =2 sbit P1_6  = 0x96;
           =2 sbit P1_7  = 0x97;
           =2 
           =2 sbit P2_0  = 0xa0;
           =2 sbit P2_1  = 0xa1;
           =2 sbit P2_2  = 0xa2;
           =2 sbit P2_3  = 0xa3;
           =2 sbit P2_4  = 0xa4;
           =2 sbit P2_5  = 0xa5;
           =2 sbit P2_6  = 0xa6;
           =2 sbit P2_7  = 0xa7;
           =2 
           =2 sbit P3_0  = 0xb0;
           =2 sbit P3_1  = 0xb1;
           =2 sbit P3_2  = 0xb2;
           =2 sbit P3_3  = 0xb3;
           =2 sbit P3_4  = 0xb4;
           =2 sbit P3_5  = 0xb5;
           =2 sbit P3_6  = 0xb6;
           =2 sbit P3_7  = 0xb7;
           =2 
           =2 #else // external MCU=WINBOND
 189      =2  /*  BYTE Registers  */
 190      =2  sfr P0    = 0x80;
 191      =2  sfr P1    = 0x90;
 192      =2  sfr P2    = 0xA0;
 193      =2  sfr P3    = 0xB0;
 194      =2  sfr PSW   = 0xD0;
 195      =2  sfr ACC   = 0xE0;
 196      =2  sfr B     = 0xF0;
 197      =2  sfr SP    = 0x81;
 198      =2  sfr DPL   = 0x82;
 199      =2  sfr DPH   = 0x83;
 200      =2  sfr PCON  = 0x87;
 201      =2  sfr TCON  = 0x88;
 202      =2  sfr TMOD  = 0x89;
 203      =2  sfr TL0   = 0x8A;
 204      =2  sfr TL1   = 0x8B;
 205      =2  sfr TH0   = 0x8C;
 206      =2  sfr TH1   = 0x8D;
 207      =2  sfr CKCON = 0x8E;   //clock control register, default =0x01
 208      =2  sfr IE    = 0xA8;
 209      =2  sfr IP    = 0xB8;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 56  

 210      =2  sfr SCON  = 0x98;
 211      =2  sfr SBUF  = 0x99;
 212      =2  sfr P4 = 0xE8; //Megawin Ryan@970716
 213      =2  //sfr P4    = 0xa5;      //SST MCU
 214      =2  //sfr P4    = 0xd8;   //winbond<960820>
 215      =2  
 216      =2  /*  8052 Extensions  */
 217      =2  sfr ADCTL = 0xC5;   //william-20111017
 218      =2  sfr ADCV = 0xC6;    //william-20111017
 219      =2  sfr ADCVL = 0xE8;   //william-20111017
 220      =2  sfr T2CON = 0xC8;
 221      =2  sfr RCAP2L = 0xCA;
 222      =2  sfr RCAP2H = 0xCB;
 223      =2  sfr TL2   = 0xCC;
 224      =2  sfr TH2   = 0xCD;
 225      =2  
 226      =2  // for UART2
 227      =2  sfr S2CON  = 0xAA;
 228      =2  sfr S2BRT  = 0xBA;
 229      =2  sfr S2BUF  = 0x9A;
 230      =2  sfr AUXR2  = 0xA6;
 231      =2  sfr AUXIE  = 0xAD;
 232      =2  
 233      =2  sfr P1M0  = 0x91;
 234      =2  sfr P1M1  = 0x92;
 235      =2  sfr P0M0  = 0x93;
 236      =2  sfr P0M1  = 0x94;
 237      =2  sfr P2M0  = 0x95;
 238      =2  sfr P2M1  = 0x96;
 239      =2  sfr P3M0  = 0xB1;
 240      =2  sfr P3M1  = 0xB2;
 241      =2  
 242      =2  // for PCA
 243      =2  sfr CCON   = 0xD8;
 244      =2  sfr CMOD   = 0xD9;
 245      =2  sfr CCAPM0 = 0xDA;
 246      =2  sfr CCAPM1 = 0xDB;
 247      =2  sfr CCAPM2 = 0xDC;
 248      =2  sfr CCAPM3 = 0xDD;
 249      =2  sfr CCAPM4 = 0xDE;
 250      =2  sfr CCAPM5 = 0xDF;
 251      =2  sfr CL     = 0xE9;
 252      =2  sfr CH     = 0xF9;
 253      =2  sfr CCAP0L = 0xEA;
 254      =2  sfr CCAP0H = 0xFA;
 255      =2  sfr CCAP1L = 0xEB;
 256      =2  sfr CCAP1H = 0xFB;
 257      =2  sfr CCAP2L = 0xEC;
 258      =2  sfr CCAP2H = 0xFC;
 259      =2  sfr CCAP3L = 0xED;
 260      =2  sfr CCAP3H = 0xFD;
 261      =2  sfr CCAP4L = 0xEE;
 262      =2  sfr CCAP4H = 0xFE;
 263      =2  sfr CCAP5L = 0xEF;
 264      =2  sfr CCAP5H = 0xFF;
 265      =2  sfr PCAPWM0= 0xF2;
 266      =2  sfr PCAPWM1= 0xF3;
 267      =2  sfr PCAPWM2= 0xF4;
 268      =2  sfr PCAPWM3= 0xF5;
 269      =2  sfr PCAPWM4= 0xF6;
 270      =2  sfr PCAPWM5= 0xF7;
 271      =2  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 57  

 272      =2  /*  BIT Registers  */
 273      =2  /*  PSW  */
 274      =2  sbit CY    = 0xD7;
 275      =2  sbit AC    = 0xD6;
 276      =2  sbit F0    = 0xD5;
 277      =2  sbit RS1   = 0xD4;
 278      =2  sbit RS0   = 0xD3;
 279      =2  sbit OV    = 0xD2;
 280      =2  sbit P     = 0xD0;
 281      =2  
 282      =2  /*  TCON  */
 283      =2  sbit TF1   = 0x8F;
 284      =2  sbit TR1   = 0x8E;
 285      =2  sbit TF0   = 0x8D;
 286      =2  sbit TR0   = 0x8C;
 287      =2  sbit IE1   = 0x8B;
 288      =2  sbit IT1   = 0x8A;
 289      =2  sbit IE0   = 0x89;
 290      =2  sbit IT0   = 0x88;
 291      =2  
 292      =2  /*  IE  */
 293      =2  sbit EA    = 0xAF;
 294      =2  sbit ES    = 0xAC;
 295      =2  sbit ET1   = 0xAB;
 296      =2  sbit EX1   = 0xAA;
 297      =2  sbit ET0   = 0xA9;
 298      =2  sbit EX0   = 0xA8;
 299      =2  
 300      =2  /*  IP  */
 301      =2  sbit PS    = 0xBC;
 302      =2  sbit PT1   = 0xBB;
 303      =2  sbit PX1   = 0xBA;
 304      =2  sbit PT0   = 0xB9;
 305      =2  sbit PX0   = 0xB8;
 306      =2  
 307      =2  /*  P3  */
 308      =2  sbit RD    = 0xB7;
 309      =2  sbit WR    = 0xB6;
 310      =2  sbit T1    = 0xB5;
 311      =2  sbit T0    = 0xB4;
 312      =2  sbit INT1  = 0xB3;
 313      =2  sbit INT0  = 0xB2;
 314      =2  sbit TXD   = 0xB1;
 315      =2  sbit RXD   = 0xB0;
 316      =2  
 317      =2  /*  SCON  */
 318      =2  sbit SM0   = 0x9F;
 319      =2  sbit SM1   = 0x9E;
 320      =2  sbit SM2   = 0x9D;
 321      =2  sbit REN   = 0x9C;
 322      =2  sbit TB8   = 0x9B;
 323      =2  sbit RB8   = 0x9A;
 324      =2  sbit TI    = 0x99;
 325      =2  sbit RI    = 0x98;
 326      =2  
 327      =2  /*  8052 Extensions  */
 328      =2  /*  IE  */
 329      =2  sbit ET2   = 0xAD;
 330      =2  
 331      =2  /*  IP  */
 332      =2  sbit PT2   = 0xBD;
 333      =2  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 58  

 334      =2  /*  P1  */
 335      =2  sbit T2EX  = 0x91;
 336      =2  sbit T2    = 0x90;
 337      =2               
 338      =2  /*  T2CON  */
 339      =2  sbit TF2   = 0xCF;
 340      =2  sbit EXF2  = 0xCE;
 341      =2  sbit RCLK  = 0xCD;
 342      =2  sbit TCLK  = 0xCC;
 343      =2  sbit EXEN2 = 0xCB;
 344      =2  sbit TR2   = 0xCA;
 345      =2  sbit C_T2  = 0xC9;
 346      =2  sbit CP_RL2= 0xC8;
 347      =2  
 348      =2  sfr CHPENR = 0xF6;
 349      =2  sfr CHPCON = 0xBF;
 350      =2  sfr SFRAL  = 0xC4;
 351      =2  sfr SFRAH  = 0xC5;
 352      =2  sfr SFRFD  = 0xC6;
 353      =2  sfr SFRCN  = 0xC7;
 354      =2  
 355      =2  sbit P0_0  = 0x80;
 356      =2  sbit P0_1  = 0x81;
 357      =2  sbit P0_2  = 0x82;
 358      =2  sbit P0_3  = 0x83;
 359      =2  sbit P0_4  = 0x84;
 360      =2  sbit P0_5  = 0x85;
 361      =2  sbit P0_6  = 0x86;
 362      =2  sbit P0_7  = 0x87;
 363      =2  
 364      =2  sbit P1_0  = 0x90;
 365      =2  sbit P1_1  = 0x91;
 366      =2  sbit P1_2  = 0x92;
 367      =2  sbit P1_3  = 0x93;
 368      =2  sbit P1_4  = 0x94;
 369      =2  sbit P1_5  = 0x95;
 370      =2  sbit P1_6  = 0x96;
 371      =2  sbit P1_7  = 0x97;
 372      =2  
 373      =2  sbit P2_0  = 0xa0;
 374      =2  sbit P2_1  = 0xa1;
 375      =2  sbit P2_2  = 0xa2;
 376      =2  sbit P2_3  = 0xa3;
 377      =2  sbit P2_4  = 0xa4;
 378      =2  sbit P2_5  = 0xa5;
 379      =2  sbit P2_6  = 0xa6;
 380      =2  sbit P2_7  = 0xa7;
 381      =2  
 382      =2  sbit P3_0  = 0xb0;
 383      =2  sbit P3_1  = 0xb1;
 384      =2  sbit P3_2  = 0xb2;
 385      =2  sbit P3_3  = 0xb3;
 386      =2  sbit P3_4  = 0xb4;
 387      =2  sbit P3_5  = 0xb5;
 388      =2  sbit P3_6  = 0xb6;
 389      =2  sbit P3_7  = 0xb7;
 390      =2  
 391      =2  sbit P4_0  = P4^0;
 392      =2  sbit P4_1  = P4^1;
 393      =2  sbit INT3  = P4^2;
 394      =2  sbit INT2  = P4^3;
 395      =2  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 59  

 396      =2  sfr P4M0  = 0xB3;
 397      =2  sfr P4M1  = 0xB4;
 398      =2  #endif  // INTERNAL_MCU
 399      =2  
 400      =2  #endif  //__REGISTERS__
 401      =2  
   6      =1  
   7      =1  #ifdef AWT_ML072S
   8      =1    #ifdef HS
   9      =1  #define LEFT_T      P0_0
  10      =1  #define Right_T     P0_1
  11      =1    #else 
           =1 #define LEFT_T      P0_1
           =1 #define Right_T     P0_0
           =1   #endif
  15      =1  #else
           =1 #define LEFT_T      P0_0
           =1 #define Right_T     P0_1
           =1 #endif
  19      =1  #define REVERSE_T     P0_2
  20      =1  //#define VGA_T     P0_4
  21      =1  
  22      =1  #ifdef  AWT_ML072Q  //Pinchi 20140902 add for AWT ML072Q
           =1   #ifdef AWT_NEW_SLIM_MODEL  //Pinchi 20150203 add for AWT new slim model
           =1   #define AV_T      P0_3
           =1   #define CAMC_T    P0_4
           =1   #else
           =1   #define CAMC_T    P0_3
           =1   #endif
           =1 #else  //AWT_ML072S & HTRV
  30      =1  #define PARK_T      P0_3
  31      =1  #endif
  32      =1  
  33      =1  #ifdef USE_CAMD  //Pinchi 20150826 add
           =1 #define CAMD_T      P0_5
           =1 #endif
  36      =1  
  37      =1  #ifdef SUPPORT_SDCARD  //Pinchi 20150826 add 
           =1 #define SB_ADC      P1_6
           =1 #define ACC_B     P0_6
           =1 #define PPWR      P3_6
           =1 #define Door_Det    P1_7
           =1 #endif
  43      =1  
  44      =1  #define Audio_Select1   P1_4
  45      =1  #define Audio_Select2   P1_5
  46      =1  #define Audio_Mute    P1_7
  47      =1  //#define AVOutPutSelect  P1_7
  48      =1  //#define RS232Select     P4_0
  49      =1  
  50      =1  //#define GPS_PWR   P3_2
  51      =1  //#define GM8126_WD1  P2_0
  52      =1  //#define GM8126_WD2  P3_5
  53      =1  
  54      =1  #endif
  55      =1  
  30          #include "HS_DisplayOSD.h"
   1      =1  #ifndef _HS_DisplayOSD_
   2      =1  #define _HS_DisplayOSD_
   3      =1  
   4      =1  
   5      =1  enum DisplayInformation
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 60  

   6      =1  {
   7      =1    InfoOSDMENULOCKED,
   8      =1    InfoOSDMENUATCIVE,
   9      =1  #ifdef SUPPORT_SDCARD  //Pinchi 20150319 add
           =1   InfoFORMATSDCARD,
           =1   InfoFORMATSUCCESS,
           =1   InfoFORMATFAIL,
           =1   InfoRECORDERROR,
           =1   InfoPASSWORDERROR,
           =1   InfoFWUpdate,
           =1   InfoFWUpdateSUCCESS,
           =1   InfoFWUpdateFAIL,
           =1   InfoSDCARDReset,
           =1   InfoSDCARDNotReady,
           =1   InfoUpdateConfigStart,
           =1   InfoUpdateConfigFail,
           =1   InfoUpdateConfigSuccess,
           =1 #endif
  24      =1    InfoAutoDayNight_Auto,
  25      =1    InfoAutoDayNight_Day,
  26      =1    InfoAutoDayNight_Night,
  27      =1    InfoPLZRESETSYSTEM,
  28      =1  #ifdef AWT_NO_SIGNAL_MSG  //Pinchi 20150319 add for to display "NO VIDEO SIGNAL" by AWT request of 2015030
             -2
  29      =1    InfoNoVideoSignal,
  30      =1  #endif
  31      =1  
  32      =1  };
  33      =1  
  34      =1  //#define   InfoUpdateConfigStart 0x01
  35      =1  //#define   InfoUpdateConfigFail    0x02
  36      =1  //#define   InfoUpdateConfigSuccess 0x03
  37      =1  
  38      =1  #define   NORMAL_Record   0x01
  39      =1  #define   Manual_Record 0x02
  40      =1  #define   ALARM_Record  0x04
  41      =1  #define   GPS       0x08
  42      =1  #define   G_Sensor    0x10
  43      =1  #define   WIFI      0x20 
  44      =1  #define   WIFI_Signal   0x40
  45      =1  #define   OverWrite_Record  0x80
  46      =1  
  47      =1  void DisplayGaugeOSD(void);
  48      =1  void ClearGAUGEINFO(void);
  49      =1  void DisplaylockOSD(void); 
  50      =1  void DisplayactvOSD(void); 
  51      =1  void DisplayNumber(BYTE addr,WORD val,BYTE type);
  52      =1  //#ifdef SUPPORT_SDCARD
  53      =1  void DisplayDVRStatus(void);
  54      =1  void DisplayFormatOSD(void);
  55      =1  void DisplayFormatOkOSD(void);
  56      =1  void DisplayFormatFailOSD(void);
  57      =1  void DisplayFWUpDate(void);
  58      =1  void DisplayFWUpDateOK(void);
  59      =1  void DisplayFWUpDateFail(void);
  60      =1  void DisplayFWVersion(void) ;
  61      =1  void DisplayDVRnotReady(void);
  62      =1  void DisplayInformation(BYTE info);
  63      =1  //#endif    //#ifdef SUPPORT_SDCARD
  64      =1  
  65      =1  #if 0 //def AWT_NO_SIGNAL_MSG  //Pinchi 20150319 add for to display "NO VIDEO SIGNAL" by AWT request of 20
             -150302
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 61  

           =1 void AWT_Display_NoVideoSignal(BYTE bOnOff);
           =1 #endif
  68      =1  
  69      =1  #endif
  70      =1  
  31          
  32          
  33          //********************************************************************
  34          //  LOCAL DEFINE
  35          //********************************************************************
  36          
  37          //#define DEBUG_HS_PROTOCOL
  38          #define ProtocolDebug
  39          #define LCDMode 4
  40          
  41          //********************************************************************
  42          //  GLOBAL VARIABLES
  43          //********************************************************************
  44          //#ifdef SUPPORT_SDCARD
  45          BYTE  year1,year2,month,day,hour,minute,second;
  46          BYTE  DVR_daylightsaving;
  47          BYTE  DVR_timebeginesmonth;
  48          BYTE  DVR_timebeginesweek;
  49          BYTE  DVR_timebeginesTime;
  50          BYTE  DVR_sandardtimebeginesMonth;
  51          BYTE  DVR_standardtimebeginesWeek;
  52          BYTE  DVR_standardtimebeginesTime;
  53          BYTE  DVR_Resolution      ;
  54          BYTE  DVR_FPS         ;
  55          BYTE  DVR_Quality       ;
  56          BYTE  DVR_RecordMode      ;
  57          BYTE  DVR_RecordLength    ;
  58          BYTE  DVR_PreAlarmLength    ;
  59          BYTE  DVR_PostAlarmLength   ;
  60          BYTE  DVR_TimeZone;
  61          BYTE  DVR_SDCardAvailable=255   ;
  62          BYTE  DVR_RecordStatus    ;
  63          BYTE  DVR_Busy        ;
  64          BYTE  DVR_OverWrite;
  65          BYTE  FormatStatus      ;
  66          bit FormatStart       ;
  67          BYTE  TriggerStatus     ;
  68          BYTE  DVR_System=0;
  69          
  70          bit   DVR_Ready       ;
  71          bit   GetDVRStatusflag    ;
  72          bit    DoorState;
  73          BYTE GPSState;
  74          //bit   GetDVRVersionOK=0   ;
  75          BYTE DVRVersion[17]=0;
  76          BYTE DVRVersionLen=17;
  77          //#endif    //#ifdef SUPPORT_SDCARD
  78          
  79          extern  bit PowerDownStart    ;
  80          extern  BYTE PowerDownWait    ;
  81          extern  bit AccPowerDown    ;
  82          extern  bit PowerDownStart    ;
  83          extern  BYTE PowerDownWait    ;
  84          extern  bit AccPowerDown    ;
  85          extern DATA BYTE RS2_in;
  86          extern DATA  BYTE DVR_buf[DVR_BUF_MAX];
  87          //extern DATA BYTE RS_in;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 62  

  88          //extern DATA BYTE RS_buf2[BUF_MAX];
  89          
  90          BYTE gb_P_Com[2]; //Pelco P Command Buffer
  91          //BYTE gb_P_Com[7]; //Pelco D Command Buffer
  92          //BYTE GE_Com[9]; //GE Command Buffer
  93          BYTE gb_PTZ_Speed;
  94          bit SpeedDomeMode=0;
  95          BYTE PresetMode=0;
  96          BYTE PresetNumber=1;
  97          extern BYTE  CAMNumber;
  98          extern BYTE  PelcoChoiceFLAG;
  99          extern BYTE  Baud_rate;
 100          BYTE  UpdateOK=0;
 101          BYTE Information[14];
 102          //BYTE WIFI_IP[4];
 103          //BYTE WIFI_MAC[6]; 
 104          //BYTE GET_WAY[4]; 
 105          BYTE InformationLen=14;
 106          WORD CommandBuffer;
 107          //********************************************************************
 108          //  LOCAL VARIABLES
 109          //********************************************************************
 110          BYTE  SerialNumber; 
 111          
 112          
 113          //********************************************************************
 114          //  LOCAL FUNCTIONS
 115          //********************************************************************
 116          
 117          void Hs_Send_DVR_Command(BYTE * DVR_Com, BYTE len );
 118          BYTE DvrReceivePaser();
 119          
 120          
 121          #ifdef SUPPORT_SDCARD  //Pinchi 20140902 enable for AWT ML072Q
              void Hs_Protocol_Init(void)
              {
                SerialNumber=0;
                year1=0;
                year2=0;
                month=0;
                day=0;
                hour=0;
                minute=0;
                second=0;
              
                DVR_Resolution=0x01;
                DVR_FPS=0x01;
                DVR_Quality=0x01;
                DVR_RecordMode=0x01;
                DVR_RecordLength=0x01;
                DVR_PreAlarmLength=0x01;
                DVR_PostAlarmLength=0x01;
                DVR_TimeZone=0x01;
                DVR_daylightsaving=0x01;
                DVR_timebeginesmonth=0x01;
                DVR_timebeginesweek=0x01;
                DVR_timebeginesTime=0x01;
                DVR_sandardtimebeginesMonth=0x01;
                DVR_standardtimebeginesWeek=0x01;
                DVR_standardtimebeginesTime=0x01;
                DVR_SDCardAvailable=0;
                DVR_RecordStatus=0x01;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 63  

                DVR_Busy=0;
                DVR_Ready=0;
                FormatStatus=0;
                FormatStart=0;
                DVR_OverWrite=1;
                GPSState=0;
              }
              
              void Hs_DvrTxCmdPaser(BYTE Cmd_Id )
              {
                //bit check;
                BYTE j;
                //BYTE  Check_GM8126;
                BYTE DVR_Com[25]; //DVR Protocol Command Buffer
                for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
              
                DVR_Com[0] ='H';  //
                DVR_Com[1] ='S';  //  
                DVR_Com[2] = 0x01;    
                DVR_Com[3] = SerialNumber;
              
                switch(Cmd_Id)
                {
                case SetDVRParam:
                  DVR_Com[4] = SetDVRParam;     //Command Data
                  DVR_Com[5] = 8;         //Data len    
                  DVR_Com[6] = DVR_Resolution;    //Data 1
                  DVR_Com[7] = DVR_FPS;       //Data 2
                  DVR_Com[8] = DVR_Quality;     //Data 3
                  DVR_Com[9] = DVR_RecordMode;    //Data 4
                  DVR_Com[10] = DVR_RecordLength;   //Data 5
                  DVR_Com[11] = DVR_PreAlarmLength; //Data 6
                  DVR_Com[12] = DVR_PostAlarmLength;  //Data 7
                  DVR_Com[13] = DVR_OverWrite;  //Data 7
              
                  CommandBuffer|=bSetDVRParam;
                  #ifdef ProtocolDebug
                  Printf("\r\n SetDVRParam",0);
                  #endif
                  break;
              
                case SetDVRDefault:
                  DVR_Com[4] = SetDVRDefault;     //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  CommandBuffer|=bSetDVRDefault;
                  #ifdef ProtocolDebug
                  Printf("\r\n SetDVRDefault",0);
                  #endif
                  break;  
                  
                case SetDATETIME:
                  DVR_Com[4] = SetDATETIME;     //Command Data
                  DVR_Com[5] = 15;          //Data len    
                  DVR_Com[6] = year1;   //Data 1
                  DVR_Com[7] = year2;       //Data 2
                  DVR_Com[8] = month;     //Data 3
                  DVR_Com[9] = day;   //Data 4
                  DVR_Com[10] = hour;   //Data 5
                  DVR_Com[11] = minute; //Data 6
                  DVR_Com[12] = second; //Data 7
                  DVR_Com[13] = DVR_TimeZone;   //Data 8
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 64  

                  DVR_Com[14] = DVR_daylightsaving;       //Data 9
                  DVR_Com[15] = DVR_timebeginesmonth;     //Data 10
                  DVR_Com[16] = DVR_timebeginesweek;    //Data 11
                  DVR_Com[17] = DVR_timebeginesTime;    //Data 12
                  DVR_Com[18] = DVR_sandardtimebeginesMonth;  //Data 13
                  DVR_Com[19] = DVR_standardtimebeginesWeek;  //Data 14
                  DVR_Com[20] = DVR_standardtimebeginesTime;    //Data 15
                  CommandBuffer|=bSetDATETIME;
                  #ifdef ProtocolDebug
                  Printf("\r\n SetDATETIME",0);
                  #endif
                  break;    
                
                case GetDVRParam:
                  DVR_Com[4] = GetDVRParam;     //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  CommandBuffer|=bGetDVRParam;
                  #ifdef ProtocolDebug
                  Printf("\r\n GetDVRParam",0);
                  #endif
                  break;  
              
                case GetDVRStatus:
                  DVR_Com[4] = GetDVRStatus;    //Command Data
                  DVR_Com[5] = 1;         //Data len  
                  DVR_Com[6] = 0;         //Param1
                  CommandBuffer|=bGetDVRStatus;
                  #ifdef ProtocolDebug
                  Printf("\r\n GetDVRStatus",0);
                  #endif
                  break;  
              
                case GetDATETIME:
                  DVR_Com[4] = GetDATETIME;   //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  CommandBuffer|=bGetDATETIME;
                  #ifdef ProtocolDebug
                  Printf("\r\n GetDATETIME",0);
                  #endif
                  break;  
              
                case MANUALRECSTART:
                  DVR_Com[4] = MANUALRECSTART;    //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  #ifdef ProtocolDebug
                  Printf("\r\n MANUALRECSTART",0);
                  #endif
                  break;  
              
                case MANUALRECSTOP:
                  DVR_Com[4] = MANUALRECSTOP;   //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  #ifdef ProtocolDebug
                  Printf("\r\n MANUALRECSTOP",0);
                  #endif
                  break;  
              
                case SNAPSHOT:
                  DVR_Com[4] = SNAPSHOT;    //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  #ifdef ProtocolDebug
                  Printf("\r\n SNAPSHOT",0);
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 65  

                  #endif
                  break;
              
                case BOOKMARK:
                  DVR_Com[4] = BOOKMARK;    //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  CommandBuffer|=bBOOKMARK;
                  #ifdef ProtocolDebug
                  Printf("\r\n BOOKMARK",0);
                  #endif
                  break;
              
                case SetSystem:
                  DVR_Com[4] = SetSystem;   //Command Data
                  DVR_Com[5] = 1;         //Data len  
                  DVR_Com[6] = DVR_System;    
                  CommandBuffer|=bSetSystem;
                  #ifdef ProtocolDebug
                  Printf("\r\n SetSystem",0);
                  #endif
                  break;
                  
                case Halt_Start:
                  DVR_Com[4] = Halt_Start;    //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  CommandBuffer|=bHalt_Start;
                  #ifdef ProtocolDebug
                  Printf("\r\n Halt_Start",0);
                  #endif
                  break;  
              
                case SetFormatSD :
                  DVR_Com[4] = SetFormatSD ;    //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  //FormatStart=1;
                  CommandBuffer|=bSetFormatSD;
                  #ifdef ProtocolDebug
                  Printf("\r\n SetFormatSD",0);
                  #endif
                  break;
              
                case SendAlarm :
                  DVR_Com[4] = SendAlarm;   //Command Data
                  DVR_Com[5] = 1;         //Data len  
                  DVR_Com[6] = 0;         //Param1
                  #ifdef ProtocolDebug
                  Printf("\r\n SendAlarm",0);
                  #endif
                  break;  
                  
                case GetDVRVersion :
                  DVR_Com[4] = GetDVRVersion;   //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  CommandBuffer|=bGetDVRVersion;
                  #ifdef ProtocolDebug
                  Printf("\r\n GetDVRVersionLCD",0);
                  #endif
              
                  break;  
                  
                case FW_Update_Start:
                  DVR_Com[4] = FW_Update_Start ;    //Command Data
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 66  

                  DVR_Com[5] = 0;         //Data len  
                  CommandBuffer|=bFW_Update_Start;
                  //FormatStart=1;
                  #ifdef ProtocolDebug
                  Printf("\r\n FW_Update_Start",0);
                  #endif
                  break;
              
                case Update_CONFIG:
                  DVR_Com[4] = Update_CONFIG ;    //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  CommandBuffer|=bUpdate_CONFIG;
                  //FormatStart=1;
                  #ifdef ProtocolDebug
                  Printf("\r\n Update_CONFIG",0);
                  #endif
                  break;  
              
                case DoorClose:
                  DVR_Com[4] = DoorClose;   //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  CommandBuffer&=(!bDoorOpen);
                  CommandBuffer|=bDoorClose;
                  
                  DoorState=0;
                  #ifdef ProtocolDebug
                  Printf("\r\n DoorClose",0);
                  #endif
                  break;    
              
                case DoorOpen:
                  DVR_Com[4] = DoorOpen;    //Command Data
                  DVR_Com[5] = 0;         //Data len  
                  CommandBuffer&=(!bDoorClose);
                  CommandBuffer|=bDoorOpen;
                  DoorState=1;
                  #ifdef ProtocolDebug
                  Printf("\r\n DoorOpen",0);
                  #endif
                  break;  
                  
              
                }
              #if 1
              //for(j=0;j<2;j++)
              //{
                RS2_in=0;
                Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                //Wait_ms(200);
              
              //  Check_GM8126=DvrReceivePaser();
              //  if(Check_GM8126==TRUE)
              //    break;
              //}
              #endif
              #if 0
                if(Check_GM8126==FALSE)
                  DisplayInformation(InfoSDCARDNotReady);
                else
                  {
                  ClearOSDInfo();
                    ClearDataCnt(0,30*5);    
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 67  

                  }
              #endif
              }
              
              void Hs_Send_DVR_Command(BYTE * DVR_Com, BYTE len )
              {
                BYTE ii,j;
              
                //Generate DVR Mode  Check Sum
                DVR_Com[len+6] = DVR_Com[0];
                
                for(j=1;j<(len+6);j++)
                  DVR_Com[len+6] = DVR_Com[len+6]^DVR_Com[j];
                //CheckSum = Byte1 XOR Byte2 XOR Byte3 XOR......
                
                //Change_RS485_TxRx(1,RS485_TX);
                //Start Send DVR Command
                for(ii=0;ii<(len+7);ii++)
                {
                  RS2_tx(DVR_Com[ii]);  
                }
              
              #ifdef DEBUG_HS_PROTOCOL
                for(ii=0;ii<len+7;ii++)
                {
                  Printf("\r\nSend DVR Command[%d] = 0x%02x",(WORD)ii,(WORD)DVR_Com[ii]); 
                }
              #endif
              
              }
              
              BYTE DvrReceivePaser(void)
              {
                BYTE i,j,CheckSum;
                BYTE DVR_Com[30]; //DVR Protocol Command Buffer
                //BYTE Information[14];
              
                //Wait_ms(200);   //william-v1410-20120524
              #if 0
                for(i=0;i<RS2_in;i++) 
                {  
                  Printf("\r\nDVR_buf[%d]=0x%02x",(WORD)i,(WORD)DVR_buf[i]);
                }
              #endif
                //DisplayNumber(DVRStatus_ADDR,year1,4);
                for(i=0;i<DVR_BUF_MAX;i++) 
                {  
                  if(DVR_buf[i]=='H' /*&& DVR_buf[(i+1)]=='S'*/)
                  {
                   if( DVR_buf[i+1]=='S'  ) 
                    break;
                  }
                }
              
              #if 0 
              if(DVR_buf[(i+2)]==0x02)
                {
                  if(!(DVR_buf[(i+3)]==SerialNumber))
                    return FALSE;
                }
              #endif
                
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 68  

                //Generate DVR Mode  Check Sum
              
                CheckSum=DVR_buf[i];
              
                for(j=1;j<(DVR_buf[i+5]+6);j++)
                  CheckSum = CheckSum^DVR_buf[i+j];
              
                if(!(CheckSum==(DVR_buf[i+DVR_buf[i+5]+6])))
                  return FALSE; 
              
                switch(DVR_buf[i+4])
                {
                case SetDVRParam:
                  CommandBuffer&=(!bSetDVRParam);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetDVRParam",0);
                  #endif
                  break;
              
                case SetDVRDefault:
                  CommandBuffer&=(!bSetDVRDefault);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetDVRDefault",0);
                  #endif
                  break;  
                  
                case SetDATETIME:
                  CommandBuffer&=(!bSetDATETIME);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetDATETIME",0);  
                  #endif
                  break;    
              
                case Halt_Start:
                  CommandBuffer&=(!bHalt_Start);
                  #ifdef ProtocolDebug
                  Printf("\r\nR Halt_Start",0); 
                  #endif
                  break;    
              
                case FW_Update_Start:
                  CommandBuffer&=(!bFW_Update_Start);
                  #ifdef ProtocolDebug
                  Printf("\r\nR FW_Update_Start",0);  
                  #endif
                  break;    
              
                case SetFormatSD:
                  CommandBuffer&=(!bSetFormatSD);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetDATETIME",0);  
                  #endif
                  break;  
              
                case SetSystem:
                  CommandBuffer&=(!bSetSystem);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetSystem",0);  
                  #endif
                  break;  
                
                case GetDVRParam:
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 69  

                  DVR_Resolution=DVR_buf[i+6];                //Data 1
                  DVR_FPS=DVR_buf[i+7];                   //Data 2
                  DVR_Quality=DVR_buf[i+8];                 //Data 3
                  DVR_RecordMode=DVR_buf[i+9];                //Data 4
                  DVR_RecordLength=DVR_buf[i+10];               //Data 5
                  DVR_PreAlarmLength=DVR_buf[i+11];             //Data 6
                  DVR_PostAlarmLength=DVR_buf[i+12];              //Data 7
                  DVR_OverWrite=DVR_buf[i+13];              //Data 7
                  
                  CommandBuffer&=(!bGetDVRParam);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetDVRParam",0);  
                  #endif
                  break;  
              
                case GetDVRStatus:
                  year1=DVR_buf[i+6];               //Data 1
                  year2=DVR_buf[i+7];               //Data 2
                  month=DVR_buf[i+8];               //Data 3
                  day=DVR_buf[i+9];               //Data 4
                  hour=DVR_buf[i+10];               //Data 5
                  minute=DVR_buf[i+11];             //Data 6
                  second=DVR_buf[i+12];             //Data 7
                  DVR_RecordStatus=DVR_buf[i+13];         //Data 8
                  DVR_SDCardAvailable=DVR_buf[i+14];        //Data 9
                  DVR_Busy=DVR_buf[i+15];             //Data 10
                  CommandBuffer&=(!bGetDVRStatus);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetDVRStatus",0); 
                  #endif
                  break;  
              
                case GetDATETIME:
                  year1=DVR_buf[i+6];               //Data 1
                  year2=DVR_buf[i+7];               //Data 2
                  month=DVR_buf[i+8];               //Data 3
                  day=DVR_buf[i+9];               //Data 4
                  hour=DVR_buf[i+10];               //Data 5
                  minute=DVR_buf[i+11];             //Data 6
                  second=DVR_buf[i+12];             //Data 7
                  DVR_TimeZone=DVR_buf[i+13];           //Data 8
                  DVR_daylightsaving=DVR_buf[i+14];       //Data 9
                  DVR_timebeginesmonth=DVR_buf[i+15];       //Data 10
                  DVR_timebeginesweek=DVR_buf[i+16];        //Data 11
                  DVR_timebeginesTime=DVR_buf[i+17];        //Data 12
                  DVR_sandardtimebeginesMonth=DVR_buf[i+18];    //Data 13
                  DVR_standardtimebeginesWeek=DVR_buf[i+19];    //Data 14
                  DVR_standardtimebeginesTime=DVR_buf[i+20];    //Data 15         //Data len  
                  CommandBuffer&=(!bGetDATETIME);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetDATETIME",0);  
                  #endif
                  break;  
                  
                case SendDVRStatus:
                  year1=DVR_buf[i+6];               //Data 1
                  year2=DVR_buf[i+7];               //Data 2
                  month=DVR_buf[i+8];               //Data 3
                  day=DVR_buf[i+9];               //Data 4
                  hour=DVR_buf[i+10];               //Data 5
                  minute=DVR_buf[i+11];             //Data 6
                  second=DVR_buf[i+12];             //Data 7
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 70  

                  DVR_RecordStatus=DVR_buf[i+13];           //Data 8
                  DVR_SDCardAvailable=DVR_buf[i+14];        //Data 9
                  DVR_Busy=DVR_buf[i+15];             //Data 10
              
                  for(j=0;j<30;j++)
                    DVR_Com[j] = 0 ;
                
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = SendDVRStatus;   //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SendDVRStatus",0);
                  Printf("\r\nR DVR_RecordStatus=%02x",(WORD)DVR_RecordStatus); 
                  #endif
                  break;  
              
                case SendDVRParam:
                  DVR_Resolution=DVR_buf[i+6];                //Data 1
                  DVR_FPS=DVR_buf[i+7];                   //Data 2
                  DVR_Quality=DVR_buf[i+8];                 //Data 3
                  DVR_RecordMode=DVR_buf[i+9];                //Data 4
                  DVR_RecordLength=DVR_buf[i+10];               //Data 5
                  DVR_PreAlarmLength=DVR_buf[i+11];             //Data 6
                  DVR_PostAlarmLength=DVR_buf[i+12];              //Data 7
                  DVR_OverWrite=DVR_buf[i+13];              //Data 7
              
                  for(j=0;j<30;j++)
                    DVR_Com[j] = 0 ;
                
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = SendDVRParam;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SendDVRParam",0); 
                  #endif
                  break;  
              
                case SendDVRParamDT:
              
                  year1=DVR_buf[i+6];               //Data 1
                  year2=DVR_buf[i+7];               //Data 2
                  month=DVR_buf[i+8];               //Data 3
                  day=DVR_buf[i+9];               //Data 4
                  hour=DVR_buf[i+10];               //Data 5
                  minute=DVR_buf[i+11];             //Data 6
                  second=DVR_buf[i+12];             //Data 7
                  DVR_TimeZone=DVR_buf[i+13];           //Data 8
                  DVR_daylightsaving=DVR_buf[i+14];       //Data 9
                  DVR_timebeginesmonth=DVR_buf[i+15];       //Data 10
                  DVR_timebeginesweek=DVR_buf[i+16];        //Data 11
                  DVR_timebeginesTime=DVR_buf[i+17];        //Data 12
                  DVR_sandardtimebeginesMonth=DVR_buf[i+18];    //Data 13
                  DVR_standardtimebeginesWeek=DVR_buf[i+19];    //Data 14
                  DVR_standardtimebeginesTime=DVR_buf[i+20];    //Data 15         //Data len    
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 71  

              
                  for(j=0;j<30;j++)
                    DVR_Com[j] = 0 ;
                
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = SendDVRParamDT;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SendDVRParamDT",0);   
                  #endif
                  break;  
                  
                case GetLCDMode:  
                  for(j=0;j<30;j++)
                    DVR_Com[j] = 0 ;
                
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = GetLCDMode;    //Command Data
                  DVR_Com[5] = 0x01;          //Data len    
                  DVR_Com[6] = LCDMode;         //Data 1
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetLCDMode",0);
                  #endif
                  break;  
              
                case MANUALRECSTART:      
                  break;  
              
                case MANUALRECSTOP:     
                  break;  
              
                case SNAPSHOT:        
                  break;
              
                case Halt_OK:
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
                  
                  if(ACC_B==1)
                  { 
                  #ifdef BJTSwitch  
                    PPWR=0;
                  #else
                    PPWR=1;
                  #endif
                  }
                  else
                  {
                    DVR_Com[0] ='H';  //
                    DVR_Com[1] ='S';  //  
                    DVR_Com[2] = 0x02;    
                    DVR_Com[3] = DVR_buf[i+3];
                    DVR_Com[4] = Halt_OK;   //Command Data
                    DVR_Com[5] = 1;         //Data len    
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 72  

                    DVR_Com[6] = 0;         //Data 1
                    Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                    PowerDownStart=0;
                    PowerDownWait=0;
                    AccPowerDown=1;
                  }
                  #ifdef ProtocolDebug
                  Printf("\r\nR Halt_OK",0);
                  #endif
                  
                  break;  
                  
                case SetFormatSDDone:
              
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
                  
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = SetFormatSDDone;   //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  FormatStatus=1;
                  UpdateOK=1;
                  CommandBuffer&=(!bSetFormatSD);
                  #ifdef ProtocolDebug
                  Printf("\r\nR SetFormatSDDone",0);
                  #endif
                  break;
              
                case FW_Update_OK:
              
                  //FormatStatus=DVR_buf[i+6];              //Data 1
              
                  UpdateOK=DVR_buf[i+6];
              
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
                  
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = FW_Update_OK;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  FormatStatus=1;
                  CommandBuffer&=(!bFW_Update_Start);
                  #ifdef ProtocolDebug
                  Printf("\r\nR FW_Update_OK",0); 
                  #endif
                  break;
              
                case GetDVRVersion:
                  
                  DVRVersionLen = DVR_buf[i+5];
                  for(j=0;j<=DVRVersionLen;j++)
                  {
                    DVRVersion[j]=DVR_buf[i+6+j];               //Data 1  
                  } 
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 73  

                  //GetDVRVersionOK=1;
                  DisplayFWVersion();
                  CommandBuffer&=(!bGetDVRVersion);
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetDVRVersionDVR",0); 
                  #endif
                  break;    
              
                case GetInformation:
                    
                  InformationLen= DVR_buf[i+5];
                  for(j=0;j<InformationLen;j++)
                  {
                    Information[j]=DVR_buf[i+6+j];                //Data 1  
                  } 
              
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = GetInformation;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
              
                  //for(i=0;i<InformationLen;i++) 
                  //{  
                  //Printf("\r\nInformation[%d]=0x%02x",(WORD)i,(WORD)Information[i]);
                  //}
                  #ifdef ProtocolDebug
                  Printf("\r\nR GetInformation",0);
                  #endif
                  break;
                 
                case Update_CONFIG_OK:
              
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
                  
                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = Update_CONFIG_OK;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
                  FormatStatus= 1;
                  UpdateOK=DVR_buf[i+6];
              
                  CommandBuffer&=(!bUpdate_CONFIG);
                  #ifdef ProtocolDebug
                  Printf("\r\nR Update_CONFIG_OK",0);
                  #endif
                  break;
              
              #if 0
                case GPSReset:
              
                  GPSState=DVR_buf[i+6];                //Data 1
              
                  for(j=0;j<30;j++)
                  DVR_Com[j] = 0 ;
                  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 74  

                  DVR_Com[0] ='H';  //
                  DVR_Com[1] ='S';  //  
                  DVR_Com[2] = 0x02;    
                  DVR_Com[3] = DVR_buf[i+3];
                  DVR_Com[4] = GPSReset;    //Command Data
                  DVR_Com[5] = 0;         //Data len    
                  Hs_Send_DVR_Command((BYTE *)DVR_Com,DVR_Com[5]);
              
                if(GPSState==1)
                  {
                  GPS_PWR=0;
                  Wait_ms(1000);
                  GPS_PWR=1;
                  }
                  #ifdef ProtocolDebug
                  Printf("\r\nR GPSReset",0);
                  #endif
                  break;
              #endif
              
                case BOOKMARK:
                  CommandBuffer&=(!bBOOKMARK);
                  #ifdef ProtocolDebug
                  Printf("\r\n RBOOKMARK",0);
                  #endif
                  break;
              
                case DoorClose:             
                  DoorState=0;
                  CommandBuffer&=(!bDoorClose);
                  #ifdef ProtocolDebug
                  Printf("\r\nR DoorClose",0);
                  #endif
                  break;    
              
                case DoorOpen:      
                  DoorState=1;
                  CommandBuffer&=(!bDoorOpen);
                  #ifdef ProtocolDebug
                  Printf("\r\nR DoorOpen",0);
                  #endif
                  break;  
                  
                }
              
                for(j=0;j<29;j++)
                    DVR_buf[j] = 0 ;
                
                SerialNumber++;
                RS2_in=0;
                
              #if 1
                if(DVR_Ready==0)
                {
                  DVR_Ready=1;
                  GetDVRStatusflag=1;
                }
              #endif
              
                return TRUE;
              }
              
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 75  

              void DVRCommandReSend(void)
              {
                if(CommandBuffer&bSetDVRParam)
                  Hs_DvrTxCmdPaser(SetDVRParam);
              
                if(CommandBuffer&bSetDVRDefault)
                  Hs_DvrTxCmdPaser(SetDVRDefault);
              
                if(CommandBuffer&bGetDVRParam)
                  Hs_DvrTxCmdPaser(GetDVRParam);
              
                if(CommandBuffer&bGetDATETIME)
                  Hs_DvrTxCmdPaser(GetDATETIME);
              
                if(CommandBuffer&bGetDATETIME)
                  Hs_DvrTxCmdPaser(GetDATETIME);
              
                if(CommandBuffer&bHalt_Start)
                  Hs_DvrTxCmdPaser(Halt_Start);
              
                if(CommandBuffer&bSetFormatSD)
                  Hs_DvrTxCmdPaser(SetFormatSD);
              
                if(CommandBuffer&bGetDVRVersion)
                  Hs_DvrTxCmdPaser(GetDVRVersion);
              
                if(CommandBuffer&bFW_Update_Start)
                  Hs_DvrTxCmdPaser(FW_Update_Start);
              
                if(CommandBuffer&bDoorClose)
                  Hs_DvrTxCmdPaser(DoorClose);
              
                if(CommandBuffer&bDoorOpen)
                  Hs_DvrTxCmdPaser(DoorOpen);
              
                if(CommandBuffer&bUpdate_CONFIG)
                  Hs_DvrTxCmdPaser(Update_CONFIG);
              }
              #endif
 933          
 934          #if 0
              BYTE TW2835ReceivePaser(void)
              {
              
              BYTE i,j;
              
                Wait_ms(100);
              #if 1
                for(i=0;i<RS_in;i++) 
                {  
                  Printf("\r\nRS_buf2[%d]=0x%02x",(WORD)i,(WORD)RS_buf2[i]);
                }
              #endif
              
                for(i=0;i<BUF_MAX;i++) 
                  {  
                    if(RS_buf2[i]=='N' /*&& DVR_buf[(i+1)]=='S'*/)
                    {
                     if( RS_buf2[i+1]=='T'  ) 
                      {
                       if( RS_buf2[i+2]=='S'  )
                        {
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 76  

                         if( RS_buf2[i+3]=='C'  ) 
                          {
                          return NTSC;
                          break;
                          }
                        }
                      }
                    }
              
                  if(RS_buf2[i]=='P' /*&& DVR_buf[(i+1)]=='S'*/)
                    {
                     if( RS_buf2[i+1]=='A'  ) 
                      {
                       if( RS_buf2[i+2]=='L'  )
                        {
                         return PAL;
                         break;
                        }
                      }
                    }
                  }
              
                return 0;
              
              
              }
              #endif
 983          //#endif  //#ifdef SUPPORT_SDCARD
 984          
 985          
 986          /////////////////////////////////////////////////////////////////////////
 987          //
 988          //  Camera Mode Send Command to RS485 Poart A 
 989          //  Note: Com_ID: Camera Command ID Number 
 990          //      Dev_ID: Camera Device ID Number 1~256 
 991          //      *Device ID Show with Input 1~256 Send Command then 0~255
 992          //      Protocol : 0:Pelco-P   1:Pelco-D
 993          /////////////////////////////////////////////////////////////////////////
 994          void CAM_TxCommand_toRS485(BYTE Com_ID)
 995          {
 996   1        BYTE j;
 997   1        //Printf("\r\nPelcoChoiceFLAG=%02x",(WORD)PelcoChoiceFLAG);
 998   1        //Printf("\r\nCAMNumber=%02x",(WORD)CAMNumber);
 999   1        //Printf("\r\nCom_ID=%02x",(WORD)Com_ID);
1000   1        //Select Speed Dome Protocol
1001   1        switch(PelcoChoiceFLAG)
1002   1        {
1003   2          case 0: //Pelco P
1004   2            //Clear Pelco P Command Buffer
1005   2            for(j=0;j<8;j++)
1006   2              gb_P_Com[j] = 0 ;
1007   2            gb_P_Com[0] = 0xA0;   //STX-Start Transmission
1008   2            //Check Input Source with Camera Address
1009   2              gb_P_Com[1] = CAMNumber-1;  // 0~255
1010   2            gb_P_Com[6] = 0xAF;   //ETX End Transmission
1011   2            //Select Command ID
1012   2            switch(Com_ID)
1013   2            {
1014   3            #if 0
                      case CAM_CLEAR:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x05; //Data 2
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 77  

                        gb_P_Com[4] = 0;  //Data 3
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID; //Data 4
                        else
                          gb_P_Com[5] = 0xFF;
                        Send_PelcoP_Command();
                        break;
                    #endif      
1026   3              case CAM_ZOOM_OUT_START:
1027   3                gb_P_Com[2] = 0;  //Data 1
1028   3                gb_P_Com[3] = 0x40; //Data 2
1029   3                gb_P_Com[4] = 0;  //Data 3
1030   3                gb_P_Com[5] = 0;  //Data 4
1031   3                Send_PelcoP_Command();
1032   3                break;
1033   3                
1034   3            //  case CAM_ZOOM_OUT_END:
1035   3            //  case CAM_ZOOM_IN_END:
1036   3            //  case CAM_IRIS_CLOSE_END:
1037   3            //  case CAM_IRIS_OPEN_END:
1038   3            //  case CAM_FOCUS_FAR_END:
1039   3            //  case CAM_FOCUS_NEAR_END:
1040   3              case CAM_PTZ_STOP:
1041   3                gb_P_Com[2] = 0;  //Data 1
1042   3                gb_P_Com[3] = 0;  //Data 2
1043   3                gb_P_Com[4] = 0;  //Data 3
1044   3                gb_P_Com[5] = 0;  //Data 4
1045   3                Send_PelcoP_Command();
1046   3                break;
1047   3              
1048   3              case CAM_ZOOM_IN_START:
1049   3                gb_P_Com[2] = 0;  //Data 1
1050   3                gb_P_Com[3] = 0x20; //Data 2
1051   3                gb_P_Com[4] = 0;  //Data 3
1052   3                gb_P_Com[5] = 0;  //Data 4
1053   3                Send_PelcoP_Command();
1054   3                break;
1055   3            #if 0     
                      case CAM_IRIS_CLOSE_START:
                        gb_P_Com[2] = 0x08; //Data 1
                        gb_P_Com[3] = 0;  //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_IRIS_OPEN_START:
                        gb_P_Com[2] = 0x04; //Data 1
                        gb_P_Com[3] = 0;  //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_FOCUS_FAR_START:
                        gb_P_Com[2] = 0x01; //Data 1
                        gb_P_Com[3] = 0;  //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_FOCUS_NEAR_START:
                        gb_P_Com[2] = 0x02; //Data 1
                        gb_P_Com[3] = 0;  //Data 2
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 78  

                        gb_P_Com[4] = 0;  //Data 3
                        gb_P_Com[5] = 0;  //Data 4
                        Send_PelcoP_Command();
                        break;
              
                      case CAM_FOCUS_SPEED:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x27; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID - 1; //Data 4
                        else
                          gb_P_Com[5] = 0xFF;
                        //Check Max Value
                        if(gb_P_Com[5] >= 0x03)
                          gb_P_Com[5] = 0x03;
                        Send_PelcoP_Command();
                        break;
                      case CAM_ZOOM_SPEED:
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x25; //Data 2
                        gb_P_Com[4] = 0;  //Data 3
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID - 1; //Data 4
                        else
                          gb_P_Com[5] = 0xFF;
                        //Check Max Value
                        if(gb_P_Com[5] >= 0x03)
                          gb_P_Com[5] = 0x03;
                        Send_PelcoP_Command();
                        break;
                      #endif  
1112   3              case CAM_SET:
1113   3                gb_P_Com[2] = 0;  //Data 1
1114   3                gb_P_Com[3] = 0x03; //Data 2
1115   3                gb_P_Com[4] = 0;  //Data 3
1116   3                //if(gb_Show_Number_Nor_HL_Status == 0)
1117   3                //  gb_P_Com[5] = UserPrefNumberID; //Data 4
1118   3                //else
1119   3                  gb_P_Com[5] = PresetNumber;
1120   3                Send_PelcoP_Command();
1121   3                break;
1122   3              case CAM_CALL:
1123   3                gb_P_Com[2] = 0;  //Data 1
1124   3                gb_P_Com[3] = 0x07; //Data 2
1125   3                gb_P_Com[4] = 0;  //Data 3
1126   3                //if(gb_Show_Number_Nor_HL_Status == 0)
1127   3                //  gb_P_Com[5] = UserPrefNumberID; //Data 4
1128   3                //else
1129   3                  gb_P_Com[5] = PresetNumber;
1130   3                Send_PelcoP_Command();
1131   3                break;
1132   3              case CAM_PTZ_RIGHT: 
1133   3                gb_P_Com[2] = 0;  //Data 1
1134   3                gb_P_Com[3] = 0x02; //Data 2
1135   3                if(SpeedDomeMode==1)
1136   3                  gb_P_Com[4] = 0xff; //Data 3  
1137   3                else
1138   3                  gb_P_Com[4] = gb_PTZ_Speed; //Data 3
1139   3                gb_P_Com[5] = 0;  //Data 4
1140   3                Send_PelcoP_Command();
1141   3                break;
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 79  

1142   3              case CAM_PTZ_LEFT:  
1143   3                gb_P_Com[2] = 0;  //Data 1
1144   3                gb_P_Com[3] = 0x04; //Data 2
1145   3                if(SpeedDomeMode==1)
1146   3                  gb_P_Com[4] = 0xff; //Data 3  
1147   3                else
1148   3                  gb_P_Com[4] = gb_PTZ_Speed; //Data 3
1149   3                gb_P_Com[5] = 0;  //Data 4
1150   3                Send_PelcoP_Command();
1151   3                break;
1152   3              case CAM_PTZ_UP:  
1153   3                gb_P_Com[2] = 0;  //Data 1
1154   3                gb_P_Com[3] = 0x08; //Data 2    
1155   3                gb_P_Com[4] = 0;  //Data 3
1156   3                if(SpeedDomeMode==1)
1157   3                  gb_P_Com[5] = 0xff; //Data 3  
1158   3                else  
1159   3                  gb_P_Com[5] = gb_PTZ_Speed; //Data 4
1160   3                Send_PelcoP_Command();
1161   3                break;
1162   3              case CAM_PTZ_DOWN:  
1163   3                gb_P_Com[2] = 0;  //Data 1
1164   3                gb_P_Com[3] = 0x10; //Data 2          
1165   3                gb_P_Com[4] = 0;  //Data 3
1166   3                if(SpeedDomeMode==1)
1167   3                  gb_P_Com[5] = 0xff; //Data 3  
1168   3                else  
1169   3                  gb_P_Com[5] = gb_PTZ_Speed; //Data 4
1170   3                Send_PelcoP_Command();
1171   3                break;
1172   3              case CAM_MENU_ENTER:  
1173   3                gb_P_Com[2] = 0;  //Data 1
1174   3                gb_P_Com[3] = 0x03; //Data 2
1175   3                gb_P_Com[4] = 0;  //Data 3
1176   3                gb_P_Com[5] = 0x5F; //Data 4
1177   3                Send_PelcoP_Command();
1178   3                break;  
1179   3              case CAM_Iris_Open: 
1180   3                gb_P_Com[2] = 0x04; //Data 1
1181   3                gb_P_Com[3] = 0; //Data 2
1182   3                gb_P_Com[4] = 0;  //Data 3
1183   3                gb_P_Com[5] = 0;  //Data 4
1184   3                Send_PelcoP_Command();
1185   3                break;  
1186   3              #if 0 
                      case CAM_PTZ_RIGHT_UP:  
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x0A; //Data 2
                        gb_P_Com[4] = gb_PTZ_Right_Speed; //Data 3
                        gb_P_Com[5] = gb_PTZ_Up_Speed;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_RIGHT_DOWN:  
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x12; //Data 2
                        gb_P_Com[4] = gb_PTZ_Right_Speed; //Data 3
                        gb_P_Com[5] = gb_PTZ_Down_Speed;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_LEFT_UP: 
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x0C; //Data 2
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 80  

                        gb_P_Com[4] = gb_PTZ_Left_Speed;  //Data 3
                        gb_P_Com[5] = gb_PTZ_Up_Speed;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      case CAM_PTZ_LEFT_DOWN: 
                        gb_P_Com[2] = 0;  //Data 1
                        gb_P_Com[3] = 0x14; //Data 2
                        gb_P_Com[4] = gb_PTZ_Left_Speed;  //Data 3
                        gb_P_Com[5] = gb_PTZ_Down_Speed;  //Data 4
                        Send_PelcoP_Command();
                        break;
                      #endif  
1216   3            }
1217   2            break;
1218   2          case 1: //Pelco D
1219   2            //Clear Pelco D Command Buffer
1220   2            for(j=0;j<7;j++)
1221   2              gb_P_Com[j] = 0 ;
1222   2            gb_P_Com[0] = 0xFF;   //Synchronization Byte
1223   2            //Check Input Source with Camera Address
1224   2              gb_P_Com[1] = CAMNumber; // 1~256
1225   2            //Select Command ID
1226   2            switch(Com_ID)
1227   2            {
1228   3            #if 0
                      case CAM_CLEAR:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x05; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID; //Data 2
                        else
                          gb_P_Com[5] = 0xFF;
                        Send_PelcoD_Command();
                        break;
                    #endif      
1240   3              case CAM_ZOOM_OUT_START:
1241   3                gb_P_Com[2] = 0;  //Command 1
1242   3                gb_P_Com[3] = 0x40; //Command 2
1243   3                gb_P_Com[4] = 0;  //Data 1
1244   3                gb_P_Com[5] = 0;  //Data 2
1245   3                Send_PelcoD_Command();
1246   3                break;
1247   3              
1248   3            //  case CAM_ZOOM_OUT_END:
1249   3            //  case CAM_ZOOM_IN_END:
1250   3            //  case CAM_IRIS_CLOSE_END:
1251   3            //  case CAM_IRIS_OPEN_END:
1252   3            //  case CAM_FOCUS_FAR_END:
1253   3            //  case CAM_FOCUS_NEAR_END:
1254   3              case CAM_PTZ_STOP:
1255   3                gb_P_Com[2] = 0;  //Command 1
1256   3                gb_P_Com[3] = 0;  //Command 2
1257   3                gb_P_Com[4] = 0;  //Data 1
1258   3                gb_P_Com[5] = 0;  //Data 2
1259   3                Send_PelcoD_Command();
1260   3                break;
1261   3              
1262   3              case CAM_ZOOM_IN_START:
1263   3                gb_P_Com[2] = 0;  //Command 1
1264   3                gb_P_Com[3] = 0x20; //Command 2
1265   3                gb_P_Com[4] = 0;  //Data 1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 81  

1266   3                gb_P_Com[5] = 0;  //Data 2
1267   3                Send_PelcoD_Command();
1268   3                break;
1269   3            #if 0   
                      case CAM_IRIS_CLOSE_START:
                        gb_P_Com[2] = 0x04; //Command 1
                        gb_P_Com[3] = 0;  //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
              
                      case CAM_FOCUS_FAR_START:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x80; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_FOCUS_NEAR_START:
                        gb_P_Com[2] = 0x01; //Command 1
                        gb_P_Com[3] = 0;  //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        gb_P_Com[5] = 0;  //Data 2
                        Send_PelcoD_Command();
                        break;
              
                      case CAM_FOCUS_SPEED:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x27; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID - 1; //Data 2
                        else
                          gb_P_Com[5] = 0xFF;
                        //Check Max Value
                        if(gb_P_Com[5] >= 0x03)
                          gb_P_Com[5] = 0x03;
                        Send_PelcoD_Command();
                        break;
                      case CAM_ZOOM_SPEED:
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x25; //Command 2
                        gb_P_Com[4] = 0;  //Data 1
                        if(gb_Show_Number_Nor_HL_Status == 0)
                          gb_P_Com[5] = UserPrefNumberID - 1; //Data 2
                        else
                          gb_P_Com[5] = 0xFF;
                        //Check Max Value
                        if(gb_P_Com[5] >= 0x03)
                          gb_P_Com[5] = 0x03;
                        Send_PelcoD_Command();
                        break;
                    #endif    
1320   3              case CAM_PTZ_RIGHT: 
1321   3                gb_P_Com[2] = 0;  //Command 1
1322   3                gb_P_Com[3] = 0x02; //Command 2
1323   3                if(SpeedDomeMode==1)
1324   3                  gb_P_Com[4] = 0xff; //Data 3  
1325   3                else
1326   3                  gb_P_Com[4] = gb_PTZ_Speed; //Data 1
1327   3                gb_P_Com[5] = 0;  //Data 2
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 82  

1328   3                Send_PelcoD_Command();
1329   3                break;
1330   3              case CAM_PTZ_LEFT:  
1331   3                gb_P_Com[2] = 0;  //Command 1
1332   3                gb_P_Com[3] = 0x04; //Command 2
1333   3                if(SpeedDomeMode==1)
1334   3                  gb_P_Com[4] = 0xff; //Data 3  
1335   3                else
1336   3                  gb_P_Com[4] = gb_PTZ_Speed; //Data 1
1337   3                gb_P_Com[5] = 0;  //Data 2
1338   3                Send_PelcoD_Command();
1339   3                break;
1340   3              case CAM_PTZ_UP:  
1341   3                gb_P_Com[2] = 0;  //Command 1
1342   3                gb_P_Com[3] = 0x08; //Command 2
1343   3                gb_P_Com[4] = 0;  //Data 1
1344   3                if(SpeedDomeMode==1)
1345   3                  gb_P_Com[5] = 0xff; //Data 3  
1346   3                else
1347   3                  gb_P_Com[5] = gb_PTZ_Speed; //Data 2
1348   3                Send_PelcoD_Command();
1349   3                break;
1350   3              case CAM_PTZ_DOWN:  
1351   3                gb_P_Com[2] = 0;  //Command 1
1352   3                gb_P_Com[3] = 0x10; //Command 2
1353   3                gb_P_Com[4] = 0;  //Data 1
1354   3                if(SpeedDomeMode==1)
1355   3                  gb_P_Com[5] = 0xff; //Data 3  
1356   3                else
1357   3                  gb_P_Com[5] = gb_PTZ_Speed; //Data 2
1358   3                Send_PelcoD_Command();
1359   3                break;
1360   3              case CAM_SET:
1361   3                gb_P_Com[2] = 0;  //Command 1
1362   3                gb_P_Com[3] = 0x03; //Command 2
1363   3                gb_P_Com[4] = 0;  //Data 1
1364   3                //if(gb_Show_Number_Nor_HL_Status == 0)
1365   3                //  gb_P_Com[5] = UserPrefNumberID; //Data 2
1366   3                //else
1367   3                  gb_P_Com[5] = PresetNumber;
1368   3                Send_PelcoD_Command();
1369   3                break;
1370   3              case CAM_CALL:
1371   3                gb_P_Com[2] = 0;  //Command 1
1372   3                gb_P_Com[3] = 0x07; //Command 2
1373   3                gb_P_Com[4] = 0;  //Data 1
1374   3                //if(gb_Show_Number_Nor_HL_Status == 0)
1375   3                //  gb_P_Com[5] = UserPrefNumberID; //Data 2
1376   3                //else
1377   3                  gb_P_Com[5] = PresetNumber;
1378   3                Send_PelcoD_Command();
1379   3                break;
1380   3              case CAM_MENU_ENTER:  
1381   3                gb_P_Com[2] = 0;  //Command 1
1382   3                gb_P_Com[3] = 0x03; //Command 2
1383   3                gb_P_Com[4] = 0;  //Data 1
1384   3                gb_P_Com[5] = 0x5F; //Data 2
1385   3                Send_PelcoD_Command();
1386   3                break;
1387   3              case CAM_Iris_Open: 
1388   3                gb_P_Com[2] = 0x02; //Command 1
1389   3                gb_P_Com[3] = 0;  //Command 2
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 83  

1390   3                gb_P_Com[4] = 0;  //Data 1
1391   3                gb_P_Com[5] = 0;  //Data 2
1392   3                Send_PelcoD_Command();
1393   3                break;  
1394   3            #if 0   
                      case CAM_PTZ_RIGHT_UP:  
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x0A; //Command 2
                        gb_P_Com[4] = gb_PTZ_Right_Speed; //Data 1
                        gb_P_Com[5] = gb_PTZ_Up_Speed;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_PTZ_RIGHT_DOWN:  
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x12; //Command 2
                        gb_P_Com[4] = gb_PTZ_Right_Speed; //Data 1
                        gb_P_Com[5] = gb_PTZ_Down_Speed;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_PTZ_LEFT_UP: 
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x0C; //Command 2
                        gb_P_Com[4] = gb_PTZ_Left_Speed;  //Data 1
                        gb_P_Com[5] = gb_PTZ_Up_Speed;  //Data 2
                        Send_PelcoD_Command();
                        break;
                      case CAM_PTZ_LEFT_DOWN: 
                        gb_P_Com[2] = 0;  //Command 1
                        gb_P_Com[3] = 0x14; //Command 2
                        gb_P_Com[4] = gb_PTZ_Left_Speed;  //Data 1
                        gb_P_Com[5] = gb_PTZ_Down_Speed;  //Data 2
                        Send_PelcoD_Command();
                        break;
                    #endif    
1424   3            }
1425   2            break;
1426   2      #ifdef GE_PROTOCOL
                  case 2:
                    //Clear GE Command Buffer
                    for(j=0;j<9;j++)
                      GE_Com[j] = 0 ;
                    
                    GE_Com[0] = 0xFF;   //STX-Start Transmission
                    //Check Input Source with Camera Address
                      GE_Com[6] = CAMNumber;  // 0~255
                    //Select Command ID
                    switch(Com_ID)
                    {
                      case CAM_PTZ_RIGHT: 
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0xc0; //Motor command 
                        Send_GE_Command();
                        break;
                      case CAM_PTZ_LEFT:  
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 84  

                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0x80; //Motor command 
                        Send_GE_Command();
                        break;
                      case CAM_PTZ_UP:  
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0x81; //Motor command 
                        Send_GE_Command();
                        break;
                      case CAM_PTZ_DOWN:  
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0xc1; //Motor command 
                        Send_GE_Command();
                        break;
                      case CAM_ZOOM_IN_START: 
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0xc1; //Motor command 
                        Send_GE_Command();  
                        break;
                      case CAM_ZOOM_OUT_START:  
                        GE_Com[1] = 0x07; //Length 
                        GE_Com[2] = 0x09; //Message type 1 
                        GE_Com[3] = 0x05; //Message type 2
                        GE_Com[4] = 0;  //Destination
                        GE_Com[5] = 0;  //Source
                        GE_Com[7] = 0xc1; //Motor command 
                        Send_GE_Command();
                        break;
              
              
                    }
                    
                  break;
              #endif    
1498   2        }
1499   1        
1500   1      }
1501          
1502          
1503          ////////////////////////////////////////////////////////////////
1504          //
1505          //  Send Pelco P Command Using RS485 Port A Function
1506          //
1507          ////////////////////////////////////////////////////////////////
1508          void Send_PelcoP_Command(void)
1509          {
1510   1        BYTE ii,j;
1511   1      
1512   1        //Generate Camera Mode Pelco P Check Sum
1513   1        gb_P_Com[7] = gb_P_Com[0];  
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 85  

1514   1        for(j=1;j<7;j++)
1515   1          gb_P_Com[7] = gb_P_Com[7]^gb_P_Com[j];
1516   1      
1517   1        //Change_RS485_TxRx(0,RS485_TX);
1518   1        //Start Send Pelco P Command
1519   1        //Printf("\r\nTH1=%02x",(WORD)TH1);
1520   1        //Printf("\r\nBaud_rate=%d",(WORD)Baud_rate);
1521   1        switch(Baud_rate)
1522   1        {
1523   2        case Baud_rate2400:
1524   2          S2BRT=0xd0;//0xd0;
1525   2          break;
1526   2        case Baud_rate4800:
1527   2          S2BRT=0xe8;//0xe8;
1528   2          break;
1529   2        case Baud_rate9600:
1530   2          S2BRT=0xf4;//0xf4;
1531   2          break;
1532   2        }
1533   1        
1534   1        Printf("\r\nTH111111111111111=%02x",(WORD)TH1);
1535   1        Wait_ms(100);
1536   1        for(ii=0;ii<8;ii++)
1537   1        {
1538   2          RS2_tx(gb_P_Com[ii]); 
1539   2        }
1540   1        Wait_ms(100);
1541   1        S2BRT=0xf4; //Baud_rate960
1542   1        //TH1=0xf4; //Baud_rate9600
1543   1        //while(!(READ_PCB_REG(SP0STS) & TEMT));
1544   1        //Change_RS485_TxRx(0,RS485_RX);
1545   1      
1546   1      }
1547          
1548          
1549          ////////////////////////////////////////////////////////////////
1550          //
1551          //  Send Pelco D Command Using RS485 Port A Function
1552          //
1553          ////////////////////////////////////////////////////////////////
1554          void Send_PelcoD_Command(void)
1555          {
1556   1        BYTE ii,j;
1557   1      
1558   1        //Generate Camera Mode Pelco D Check Sum
1559   1        gb_P_Com[6] = gb_P_Com[1];  
1560   1        for(j=2;j<6;j++)
1561   1          gb_P_Com[6] = gb_P_Com[6]+gb_P_Com[j];
1562   1      
1563   1        switch(Baud_rate)
1564   1        {
1565   2        case Baud_rate2400:
1566   2          S2BRT=0xd0;//0xd0;
1567   2          break;
1568   2        case Baud_rate4800:
1569   2          S2BRT=0xe8;//0xe8;
1570   2          break;
1571   2        case Baud_rate9600:
1572   2          S2BRT=0xf4;//0xf4;
1573   2          break;
1574   2        }
1575   1      
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 86  

1576   1        Printf("\r\ngb_p_Com[0]=%02x",(WORD)gb_P_Com[0]);
1577   1        Wait_ms(100);
1578   1        //Change_RS485_TxRx(0,RS485_TX);
1579   1        //Start Send Pelco D Command
1580   1        for(ii=0;ii<7;ii++)
1581   1        {
1582   2          RS2_tx(gb_P_Com[ii]); 
1583   2        }
1584   1      
1585   1        Wait_ms(100);
1586   1        S2BRT=0xf4; //Baud_rate960
1587   1        //while(!(READ_PCB_REG(SP0STS) & TEMT));
1588   1        //Change_RS485_TxRx(0,RS485_RX);
1589   1      }
1590          
1591          #ifdef GE_PROTOCOL
              ////////////////////////////////////////////////////////////////
              //
              //  Send GE Command Using RS485 Port A Function
              //
              ////////////////////////////////////////////////////////////////
              void Send_GE_Command(void)
              {
                BYTE ii,j;
              
                //Generate Camera Mode Pelco D Check Sum
                GE_Com[8] = 0;  
                for(j=1;j<=GE_Com[1];j++)
                  {GE_Com[8] = GE_Com[8]+GE_Com[j];}
              
                GE_Com[8]=~GE_Com[8]+1;
              
                switch(Baud_rate)
                {
                case Baud_rate2400:
                  S2BRT=0xd0;//0xd0;
                  break;
                case Baud_rate4800:
                  S2BRT=0xe8;//0xe8;
                  break;
                case Baud_rate9600:
                  S2BRT=0xf4;//0xf4;
                  break;
                }
              
                Printf("\r\n",0);
                
                Wait_ms(1000);
                //Change_RS485_TxRx(0,RS485_TX);
                //Start Send Pelco D Command
                for(ii=0;ii<=GE_Com[1];ii++)
                {
                  RS2_tx(GE_Com[ii]); 
                }
              
                Wait_ms(400);
                S2BRT=0xf4; //Baud_rate960
                //while(!(READ_PCB_REG(SP0STS) & TEMT));
                //Change_RS485_TxRx(0,RS485_RX);
              }
              #endif
1637          
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 87  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com005D (BEGIN)
0000         L?0094:
0000         L?0095:
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#gb_P_Com+02H
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 22                RET     
0007         L?0096:
0007         L?0097:
0007 7400        R     MOV     A,#LOW gb_P_Com
0009 2F                ADD     A,R7
000A         L?0098:
000A F582              MOV     DPL,A
000C E4                CLR     A
000D 3400        R     ADDC    A,#HIGH gb_P_Com
000F F583              MOV     DPH,A
0011 22                RET     
0012         L?0099:
0012         L?0100:
0012 900000      R     MOV     DPTR,#gb_PTZ_Speed
0015 E0                MOVX    A,@DPTR
0016 900000      R     MOV     DPTR,#gb_P_Com+05H
0019 F0                MOVX    @DPTR,A
001A 22                RET     
001B         L?0101:
001B         L?0102:
001B F0                MOVX    @DPTR,A
001C E4                CLR     A
001D A3                INC     DPTR
001E F0                MOVX    @DPTR,A
001F 900000      R     MOV     DPTR,#PresetNumber
0022 E0                MOVX    A,@DPTR
0023 22                RET     
0024         L?0103:
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026         L?0104:
0026 C3                CLR     C
0027 9407              SUBB    A,#07H
0029 7480              MOV     A,#080H
002B 9480              SUBB    A,#080H
002D 22                RET     
002E         L?0105:
002E         L?0106:
002E 900000      R     MOV     DPTR,#gb_PTZ_Speed
0031 E0                MOVX    A,@DPTR
0032 A3                INC     DPTR
0033 F0                MOVX    @DPTR,A
0034 22                RET     
0035         L?0107:
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 C3                CLR     C
0038 9408              SUBB    A,#08H
003A 7480              MOV     A,#080H
003C 9480              SUBB    A,#080H
003E 22                RET     
003F         L?0108:
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 88  

003F 7403              MOV     A,#03H
0041 F0                MOVX    @DPTR,A
0042 E4                CLR     A
0043 A3                INC     DPTR
0044 F0                MOVX    @DPTR,A
0045 A3                INC     DPTR
0046 745F              MOV     A,#05FH
0048 22                RET     
             ; FUNCTION Com005D (END)

             ; FUNCTION _CAM_TxCommand_toRS485 (BEGIN)
                                           ; SOURCE LINE # 994
0000 900000      R     MOV     DPTR,#Com_ID
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 995
                                           ; SOURCE LINE # 1001
0005 900000      E     MOV     DPTR,#PelcoChoiceFLAG
0008 E0                MOVX    A,@DPTR
0009 14                DEC     A
000A 7003              JNZ     $ + 5H
000C 020000      R     LJMP    ?C0026
000F 04                INC     A
0010 6003              JZ      $ + 5H
0012 020000      R     LJMP    ?C0050
                                           ; SOURCE LINE # 1002
                                           ; SOURCE LINE # 1003
0015         ?C0002:
                                           ; SOURCE LINE # 1005
0015 E4                CLR     A
0016 900000      R     MOV     DPTR,#j
0019 F0                MOVX    @DPTR,A
001A         ?C0003:
001A 900000      R     MOV     DPTR,#j
001D 120000      R     LCALL   L?0107
0020 500D              JNC     ?C0004
                                           ; SOURCE LINE # 1006
0022 120000      R     LCALL   L?0096
0025 E4                CLR     A
0026 F0                MOVX    @DPTR,A
0027 900000      R     MOV     DPTR,#j
002A E0                MOVX    A,@DPTR
002B 04                INC     A
002C F0                MOVX    @DPTR,A
002D 80EB              SJMP    ?C0003
002F         ?C0004:
                                           ; SOURCE LINE # 1007
002F 900000      R     MOV     DPTR,#gb_P_Com
0032 74A0              MOV     A,#0A0H
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1009
0035 900000      E     MOV     DPTR,#CAMNumber
0038 E0                MOVX    A,@DPTR
0039 14                DEC     A
003A 900000      R     MOV     DPTR,#gb_P_Com+01H
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1010
003E 900000      R     MOV     DPTR,#gb_P_Com+06H
0041 74AF              MOV     A,#0AFH
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1012
0044 900000      R     MOV     DPTR,#Com_ID
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 89  

0047 E0                MOVX    A,@DPTR
0048 120000      E     LCALL   ?C?CCASE
004B 0000        R     DW      ?C0007
004D 00                DB      00H
004E 0000        R     DW      ?C0009
0050 01                DB      01H
0051 0000        R     DW      ?C0010
0053 02                DB      02H
0054 0000        R     DW      ?C0011
0056 03                DB      03H
0057 0000        R     DW      ?C0012
0059 04                DB      04H
005A 0000        R     DW      ?C0015
005C 05                DB      05H
005D 0000        R     DW      ?C0018
005F 06                DB      06H
0060 0000        R     DW      ?C0021
0062 07                DB      07H
0063 0000        R     DW      ?C0024
0065 08                DB      08H
0066 0000        R     DW      ?C0025
0068 09                DB      09H
0069 0000        R     DW      ?C0008
006B 0A                DB      0AH
006C 0000              DW      00H
006E 0000        R     DW      ?C0050
                                           ; SOURCE LINE # 1013
                                           ; SOURCE LINE # 1026
0070         ?C0007:
                                           ; SOURCE LINE # 1027
                                           ; SOURCE LINE # 1028
0070 120000      R     LCALL   L?0094
0073 7440              MOV     A,#040H
                                           ; SOURCE LINE # 1029
                                           ; SOURCE LINE # 1030
                                           ; SOURCE LINE # 1031
                                           ; SOURCE LINE # 1032
0075 800D              SJMP    ?C0073
                                           ; SOURCE LINE # 1040
0077         ?C0008:
                                           ; SOURCE LINE # 1041
0077 E4                CLR     A
0078 900000      R     MOV     DPTR,#gb_P_Com+02H
007B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1042
                                           ; SOURCE LINE # 1043
                                           ; SOURCE LINE # 1044
                                           ; SOURCE LINE # 1045
                                           ; SOURCE LINE # 1046
007C 020000      R     LJMP    ?C0074
                                           ; SOURCE LINE # 1048
007F         ?C0009:
                                           ; SOURCE LINE # 1049
                                           ; SOURCE LINE # 1050
007F 120000      R     LCALL   L?0094
0082 7420              MOV     A,#020H
0084         ?C0073:
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1051
0085 E4                CLR     A
                                           ; SOURCE LINE # 1052
                                           ; SOURCE LINE # 1053
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 90  

                                           ; SOURCE LINE # 1054
0086 020000      R     LJMP    ?C0075
                                           ; SOURCE LINE # 1112
0089         ?C0010:
                                           ; SOURCE LINE # 1113
                                           ; SOURCE LINE # 1114
0089 120000      R     LCALL   L?0095
008C 7403              MOV     A,#03H
                                           ; SOURCE LINE # 1115
                                           ; SOURCE LINE # 1119
                                           ; SOURCE LINE # 1120
                                           ; SOURCE LINE # 1121
008E 8005              SJMP    ?C0076
                                           ; SOURCE LINE # 1122
0090         ?C0011:
                                           ; SOURCE LINE # 1123
                                           ; SOURCE LINE # 1124
0090 120000      R     LCALL   L?0095
0093 7407              MOV     A,#07H
0095         ?C0076:
                                           ; SOURCE LINE # 1125
                                           ; SOURCE LINE # 1129
0095 120000      R     LCALL   L?0101
                                           ; SOURCE LINE # 1130
                                           ; SOURCE LINE # 1131
0098 8028              SJMP    ?C0078
                                           ; SOURCE LINE # 1132
009A         ?C0012:
                                           ; SOURCE LINE # 1133
                                           ; SOURCE LINE # 1134
009A 120000      R     LCALL   L?0095
009D 7402              MOV     A,#02H
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1135
00A0 300006      R     JNB     SpeedDomeMode,?C0013
                                           ; SOURCE LINE # 1136
00A3 A3                INC     DPTR
00A4 74FF              MOV     A,#0FFH
00A6 F0                MOVX    @DPTR,A
00A7 8003              SJMP    ?C0014
00A9         ?C0013:
                                           ; SOURCE LINE # 1138
00A9 120000      R     LCALL   L?0105
00AC         ?C0014:
                                           ; SOURCE LINE # 1139
00AC E4                CLR     A
00AD         ?C0077:
                                           ; SOURCE LINE # 1140
                                           ; SOURCE LINE # 1141
00AD 8013              SJMP    ?C0078
                                           ; SOURCE LINE # 1142
00AF         ?C0015:
                                           ; SOURCE LINE # 1143
                                           ; SOURCE LINE # 1144
00AF 120000      R     LCALL   L?0095
00B2 7404              MOV     A,#04H
00B4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1145
00B5 300006      R     JNB     SpeedDomeMode,?C0016
                                           ; SOURCE LINE # 1146
00B8 A3                INC     DPTR
00B9 74FF              MOV     A,#0FFH
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 91  

00BB F0                MOVX    @DPTR,A
00BC 8003              SJMP    ?C0017
00BE         ?C0016:
                                           ; SOURCE LINE # 1148
00BE 120000      R     LCALL   L?0105
00C1         ?C0017:
                                           ; SOURCE LINE # 1149
00C1 E4                CLR     A
00C2         ?C0078:
00C2 900000      R     MOV     DPTR,#gb_P_Com+05H
                                           ; SOURCE LINE # 1150
                                           ; SOURCE LINE # 1151
00C5 8034              SJMP    ?C0079
                                           ; SOURCE LINE # 1152
00C7         ?C0018:
                                           ; SOURCE LINE # 1153
                                           ; SOURCE LINE # 1154
00C7 120000      R     LCALL   L?0095
00CA 7408              MOV     A,#08H
00CC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1155
00CD E4                CLR     A
00CE A3                INC     DPTR
00CF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1156
00D0 300006      R     JNB     SpeedDomeMode,?C0019
                                           ; SOURCE LINE # 1157
00D3 A3                INC     DPTR
00D4 74FF              MOV     A,#0FFH
00D6 F0                MOVX    @DPTR,A
00D7 8032              SJMP    ?C0082
00D9         ?C0019:
                                           ; SOURCE LINE # 1159
00D9 120000      R     LCALL   L?0099
00DC         ?C0020:
                                           ; SOURCE LINE # 1160
                                           ; SOURCE LINE # 1161
00DC 802D              SJMP    ?C0082
                                           ; SOURCE LINE # 1162
00DE         ?C0021:
                                           ; SOURCE LINE # 1163
                                           ; SOURCE LINE # 1164
00DE 120000      R     LCALL   L?0095
00E1 7410              MOV     A,#010H
00E3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1165
00E4 E4                CLR     A
00E5 A3                INC     DPTR
00E6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1166
00E7 300006      R     JNB     SpeedDomeMode,?C0022
                                           ; SOURCE LINE # 1167
00EA A3                INC     DPTR
00EB 74FF              MOV     A,#0FFH
00ED F0                MOVX    @DPTR,A
00EE 8003              SJMP    ?C0023
00F0         ?C0022:
                                           ; SOURCE LINE # 1169
00F0 120000      R     LCALL   L?0099
00F3         ?C0023:
                                           ; SOURCE LINE # 1170
00F3         ?C0080:
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 92  

                                           ; SOURCE LINE # 1171
00F3 8016              SJMP    ?C0082
                                           ; SOURCE LINE # 1172
00F5         ?C0024:
                                           ; SOURCE LINE # 1173
                                           ; SOURCE LINE # 1174
00F5 120000      R     LCALL   L?0095
                                           ; SOURCE LINE # 1175
                                           ; SOURCE LINE # 1176
00F8 120000      R     LCALL   L?0108
00FB         ?C0079:
00FB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1177
00FC         ?C0081:
                                           ; SOURCE LINE # 1178
00FC 800D              SJMP    ?C0082
                                           ; SOURCE LINE # 1179
00FE         ?C0025:
                                           ; SOURCE LINE # 1180
00FE 900000      R     MOV     DPTR,#gb_P_Com+02H
0101 7404              MOV     A,#04H
0103 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1181
0104 E4                CLR     A
0105         ?C0074:
0105 A3                INC     DPTR
0106 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1182
0107         ?C0075:
0107 A3                INC     DPTR
0108 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1183
0109 A3                INC     DPTR
010A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1184
010B         ?C0082:
010B 020000      R     LJMP    Send_PelcoP_Command
                                           ; SOURCE LINE # 1185
                                           ; SOURCE LINE # 1216
                                           ; SOURCE LINE # 1217
                                           ; SOURCE LINE # 1218
010E         ?C0026:
                                           ; SOURCE LINE # 1220
010E E4                CLR     A
010F 900000      R     MOV     DPTR,#j
0112 F0                MOVX    @DPTR,A
0113         ?C0027:
0113 900000      R     MOV     DPTR,#j
0116 120000      R     LCALL   L?0103
0119 500D              JNC     ?C0028
                                           ; SOURCE LINE # 1221
011B 120000      R     LCALL   L?0096
011E E4                CLR     A
011F F0                MOVX    @DPTR,A
0120 900000      R     MOV     DPTR,#j
0123 E0                MOVX    A,@DPTR
0124 04                INC     A
0125 F0                MOVX    @DPTR,A
0126 80EB              SJMP    ?C0027
0128         ?C0028:
                                           ; SOURCE LINE # 1222
0128 900000      R     MOV     DPTR,#gb_P_Com
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 93  

012B 74FF              MOV     A,#0FFH
012D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1224
012E 900000      E     MOV     DPTR,#CAMNumber
0131 E0                MOVX    A,@DPTR
0132 900000      R     MOV     DPTR,#gb_P_Com+01H
0135 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1226
0136 900000      R     MOV     DPTR,#Com_ID
0139 E0                MOVX    A,@DPTR
013A 120000      E     LCALL   ?C?CCASE
013D 0000        R     DW      ?C0031
013F 00                DB      00H
0140 0000        R     DW      ?C0033
0142 01                DB      01H
0143 0000        R     DW      ?C0046
0145 02                DB      02H
0146 0000        R     DW      ?C0047
0148 03                DB      03H
0149 0000        R     DW      ?C0034
014B 04                DB      04H
014C 0000        R     DW      ?C0037
014E 05                DB      05H
014F 0000        R     DW      ?C0040
0151 06                DB      06H
0152 0000        R     DW      ?C0043
0154 07                DB      07H
0155 0000        R     DW      ?C0048
0157 08                DB      08H
0158 0000        R     DW      ?C0049
015A 09                DB      09H
015B 0000        R     DW      ?C0032
015D 0A                DB      0AH
015E 0000              DW      00H
0160 0000        R     DW      ?C0050
                                           ; SOURCE LINE # 1227
                                           ; SOURCE LINE # 1240
0162         ?C0031:
                                           ; SOURCE LINE # 1241
                                           ; SOURCE LINE # 1242
0162 120000      R     LCALL   L?0095
0165 7440              MOV     A,#040H
                                           ; SOURCE LINE # 1243
                                           ; SOURCE LINE # 1244
                                           ; SOURCE LINE # 1245
                                           ; SOURCE LINE # 1246
0167 800D              SJMP    ?C0083
                                           ; SOURCE LINE # 1254
0169         ?C0032:
                                           ; SOURCE LINE # 1255
0169 E4                CLR     A
016A 900000      R     MOV     DPTR,#gb_P_Com+02H
016D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1256
                                           ; SOURCE LINE # 1257
                                           ; SOURCE LINE # 1258
                                           ; SOURCE LINE # 1259
                                           ; SOURCE LINE # 1260
016E 020000      R     LJMP    ?C0084
                                           ; SOURCE LINE # 1262
0171         ?C0033:
                                           ; SOURCE LINE # 1263
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 94  

                                           ; SOURCE LINE # 1264
0171 120000      R     LCALL   L?0095
0174 7420              MOV     A,#020H
0176         ?C0083:
0176 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1265
0177 E4                CLR     A
                                           ; SOURCE LINE # 1266
                                           ; SOURCE LINE # 1267
                                           ; SOURCE LINE # 1268
0178 020000      R     LJMP    ?C0085
                                           ; SOURCE LINE # 1320
017B         ?C0034:
                                           ; SOURCE LINE # 1321
                                           ; SOURCE LINE # 1322
017B 120000      R     LCALL   L?0095
017E 7402              MOV     A,#02H
0180 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1323
0181 300006      R     JNB     SpeedDomeMode,?C0035
                                           ; SOURCE LINE # 1324
0184 A3                INC     DPTR
0185 74FF              MOV     A,#0FFH
0187 F0                MOVX    @DPTR,A
0188 8017              SJMP    ?C0086
018A         ?C0035:
                                           ; SOURCE LINE # 1326
018A 120000      R     LCALL   L?0106
018D         ?C0036:
                                           ; SOURCE LINE # 1327
                                           ; SOURCE LINE # 1328
                                           ; SOURCE LINE # 1329
018D 8012              SJMP    ?C0086
                                           ; SOURCE LINE # 1330
018F         ?C0037:
                                           ; SOURCE LINE # 1331
                                           ; SOURCE LINE # 1332
018F 120000      R     LCALL   L?0095
0192 7404              MOV     A,#04H
0194 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1333
0195 300006      R     JNB     SpeedDomeMode,?C0038
                                           ; SOURCE LINE # 1334
0198 A3                INC     DPTR
0199 74FF              MOV     A,#0FFH
019B F0                MOVX    @DPTR,A
019C 8003              SJMP    ?C0039
019E         ?C0038:
                                           ; SOURCE LINE # 1336
019E 120000      R     LCALL   L?0106
01A1         ?C0039:
                                           ; SOURCE LINE # 1337
01A1         ?C0086:
01A1 E4                CLR     A
                                           ; SOURCE LINE # 1338
                                           ; SOURCE LINE # 1339
01A2 8036              SJMP    ?C0087
                                           ; SOURCE LINE # 1340
01A4         ?C0040:
                                           ; SOURCE LINE # 1341
                                           ; SOURCE LINE # 1342
01A4 120000      R     LCALL   L?0095
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 95  

01A7 7408              MOV     A,#08H
01A9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1343
01AA E4                CLR     A
01AB A3                INC     DPTR
01AC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1344
01AD 300006      R     JNB     SpeedDomeMode,?C0041
                                           ; SOURCE LINE # 1345
01B0 A3                INC     DPTR
01B1 74FF              MOV     A,#0FFH
01B3 F0                MOVX    @DPTR,A
01B4 804E              SJMP    ?C0092
01B6         ?C0041:
                                           ; SOURCE LINE # 1347
01B6 120000      R     LCALL   L?0100
01B9         ?C0042:
                                           ; SOURCE LINE # 1348
                                           ; SOURCE LINE # 1349
01B9 8049              SJMP    ?C0092
                                           ; SOURCE LINE # 1350
01BB         ?C0043:
                                           ; SOURCE LINE # 1351
                                           ; SOURCE LINE # 1352
01BB 120000      R     LCALL   L?0095
01BE 7410              MOV     A,#010H
01C0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1353
01C1 E4                CLR     A
01C2 A3                INC     DPTR
01C3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1354
01C4 300006      R     JNB     SpeedDomeMode,?C0044
                                           ; SOURCE LINE # 1355
01C7 A3                INC     DPTR
01C8 74FF              MOV     A,#0FFH
01CA F0                MOVX    @DPTR,A
01CB 8003              SJMP    ?C0045
01CD         ?C0044:
                                           ; SOURCE LINE # 1357
01CD 120000      R     LCALL   L?0100
01D0         ?C0045:
                                           ; SOURCE LINE # 1358
01D0         ?C0088:
                                           ; SOURCE LINE # 1359
01D0 8032              SJMP    ?C0092
                                           ; SOURCE LINE # 1360
01D2         ?C0046:
                                           ; SOURCE LINE # 1361
                                           ; SOURCE LINE # 1362
01D2 120000      R     LCALL   L?0095
01D5 7403              MOV     A,#03H
                                           ; SOURCE LINE # 1363
                                           ; SOURCE LINE # 1367
01D7 120000      R     LCALL   L?0101
01DA         ?C0087:
01DA 900000      R     MOV     DPTR,#gb_P_Com+05H
01DD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1368
01DE         ?C0089:
                                           ; SOURCE LINE # 1369
01DE 8024              SJMP    ?C0092
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 96  

                                           ; SOURCE LINE # 1370
01E0         ?C0047:
                                           ; SOURCE LINE # 1371
                                           ; SOURCE LINE # 1372
01E0 120000      R     LCALL   L?0095
01E3 7407              MOV     A,#07H
                                           ; SOURCE LINE # 1373
                                           ; SOURCE LINE # 1377
01E5 120000      R     LCALL   L?0102
01E8 900000      R     MOV     DPTR,#gb_P_Com+05H
01EB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1378
01EC         ?C0090:
                                           ; SOURCE LINE # 1379
01EC 8016              SJMP    ?C0092
                                           ; SOURCE LINE # 1380
01EE         ?C0048:
                                           ; SOURCE LINE # 1381
                                           ; SOURCE LINE # 1382
01EE 120000      R     LCALL   L?0095
                                           ; SOURCE LINE # 1383
                                           ; SOURCE LINE # 1384
01F1 120000      R     LCALL   L?0108
01F4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1385
01F5         ?C0091:
                                           ; SOURCE LINE # 1386
01F5 800D              SJMP    ?C0092
                                           ; SOURCE LINE # 1387
01F7         ?C0049:
                                           ; SOURCE LINE # 1388
01F7 900000      R     MOV     DPTR,#gb_P_Com+02H
01FA 7402              MOV     A,#02H
01FC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1389
01FD E4                CLR     A
01FE         ?C0084:
01FE A3                INC     DPTR
01FF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1390
0200         ?C0085:
0200 A3                INC     DPTR
0201 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1391
0202 A3                INC     DPTR
0203 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1392
0204         ?C0092:
0204 120000      R     LCALL   Send_PelcoD_Command
                                           ; SOURCE LINE # 1393
                                           ; SOURCE LINE # 1424
                                           ; SOURCE LINE # 1425
                                           ; SOURCE LINE # 1498
                                           ; SOURCE LINE # 1500
0207         ?C0050:
0207 22                RET     
             ; FUNCTION _CAM_TxCommand_toRS485 (END)

             ; FUNCTION Send_PelcoP_Command (BEGIN)
                                           ; SOURCE LINE # 1508
                                           ; SOURCE LINE # 1509
                                           ; SOURCE LINE # 1513
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 97  

0000 900000      R     MOV     DPTR,#gb_P_Com
0003 E0                MOVX    A,@DPTR
0004 900000      R     MOV     DPTR,#gb_P_Com+07H
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1514
;---- Variable 'j' assigned to Register 'R3' ----
0008 7B01              MOV     R3,#01H
000A         ?C0051:
000A EB                MOV     A,R3
000B 120000      R     LCALL   L?0104
000E 5016              JNC     ?C0052
                                           ; SOURCE LINE # 1515
0010 900000      R     MOV     DPTR,#gb_P_Com+07H
0013 E0                MOVX    A,@DPTR
0014 FE                MOV     R6,A
0015 7400        R     MOV     A,#LOW gb_P_Com
0017 2B                ADD     A,R3
0018 120000      R     LCALL   L?0098
001B E0                MOVX    A,@DPTR
001C FD                MOV     R5,A
001D EE                MOV     A,R6
001E 6D                XRL     A,R5
001F 900000      R     MOV     DPTR,#gb_P_Com+07H
0022 F0                MOVX    @DPTR,A
0023 0B                INC     R3
0024 80E4              SJMP    ?C0051
0026         ?C0052:
                                           ; SOURCE LINE # 1521
0026 900000      E     MOV     DPTR,#Baud_rate
0029 E0                MOVX    A,@DPTR
002A 14                DEC     A
002B 600C              JZ      ?C0056
002D 14                DEC     A
002E 600E              JZ      ?C0057
0030 2402              ADD     A,#02H
0032 700D              JNZ     ?C0054
                                           ; SOURCE LINE # 1522
                                           ; SOURCE LINE # 1523
0034         ?C0055:
                                           ; SOURCE LINE # 1524
0034 75BAD0            MOV     S2BRT,#0D0H
                                           ; SOURCE LINE # 1525
0037 8008              SJMP    ?C0054
                                           ; SOURCE LINE # 1526
0039         ?C0056:
                                           ; SOURCE LINE # 1527
0039 75BAE8            MOV     S2BRT,#0E8H
                                           ; SOURCE LINE # 1528
003C 8003              SJMP    ?C0054
                                           ; SOURCE LINE # 1529
003E         ?C0057:
                                           ; SOURCE LINE # 1530
003E 75BAF4            MOV     S2BRT,#0F4H
                                           ; SOURCE LINE # 1531
                                           ; SOURCE LINE # 1532
0041         ?C0054:
                                           ; SOURCE LINE # 1534
0041 7BFF              MOV     R3,#0FFH
0043 7A00        R     MOV     R2,#HIGH ?SC_0
0045 7900        R     MOV     R1,#LOW ?SC_0
0047 AF8D              MOV     R7,TH1
0049 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 98  

004C E4                CLR     A
004D F0                MOVX    @DPTR,A
004E A3                INC     DPTR
004F EF                MOV     A,R7
0050 F0                MOVX    @DPTR,A
0051 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1535
0054 7F64              MOV     R7,#064H
0056 7E00              MOV     R6,#00H
0058 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 1536
005B E4                CLR     A
005C 900000      R     MOV     DPTR,#ii
005F F0                MOVX    @DPTR,A
0060         ?C0058:
0060 900000      R     MOV     DPTR,#ii
0063 120000      R     LCALL   L?0107
0066 5010              JNC     ?C0059
                                           ; SOURCE LINE # 1537
                                           ; SOURCE LINE # 1538
0068 120000      R     LCALL   L?0097
006B E0                MOVX    A,@DPTR
006C FF                MOV     R7,A
006D 120000      E     LCALL   _RS2_tx
                                           ; SOURCE LINE # 1539
0070 900000      R     MOV     DPTR,#ii
0073 E0                MOVX    A,@DPTR
0074 04                INC     A
0075 F0                MOVX    @DPTR,A
0076 80E8              SJMP    ?C0058
0078         ?C0059:
                                           ; SOURCE LINE # 1540
0078 7F64              MOV     R7,#064H
007A 7E00              MOV     R6,#00H
007C 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 1541
007F 75BAF4            MOV     S2BRT,#0F4H
                                           ; SOURCE LINE # 1546
0082 22                RET     
             ; FUNCTION Send_PelcoP_Command (END)

             ; FUNCTION Send_PelcoD_Command (BEGIN)
                                           ; SOURCE LINE # 1554
                                           ; SOURCE LINE # 1555
                                           ; SOURCE LINE # 1559
0000 900000      R     MOV     DPTR,#gb_P_Com+01H
0003 E0                MOVX    A,@DPTR
0004 900000      R     MOV     DPTR,#gb_P_Com+06H
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1560
;---- Variable 'j' assigned to Register 'R7' ----
0008 7F02              MOV     R7,#02H
000A         ?C0062:
000A EF                MOV     A,R7
000B C3                CLR     C
000C 9406              SUBB    A,#06H
000E 7480              MOV     A,#080H
0010 9480              SUBB    A,#080H
0012 500E              JNC     ?C0063
                                           ; SOURCE LINE # 1561
0014 120000      R     LCALL   L?0097
0017 E0                MOVX    A,@DPTR
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 99  

0018 FE                MOV     R6,A
0019 900000      R     MOV     DPTR,#gb_P_Com+06H
001C E0                MOVX    A,@DPTR
001D 2E                ADD     A,R6
001E F0                MOVX    @DPTR,A
001F 0F                INC     R7
0020 80E8              SJMP    ?C0062
0022         ?C0063:
                                           ; SOURCE LINE # 1563
0022 900000      E     MOV     DPTR,#Baud_rate
0025 E0                MOVX    A,@DPTR
0026 14                DEC     A
0027 600C              JZ      ?C0067
0029 14                DEC     A
002A 600E              JZ      ?C0068
002C 2402              ADD     A,#02H
002E 700D              JNZ     ?C0065
                                           ; SOURCE LINE # 1564
                                           ; SOURCE LINE # 1565
0030         ?C0066:
                                           ; SOURCE LINE # 1566
0030 75BAD0            MOV     S2BRT,#0D0H
                                           ; SOURCE LINE # 1567
0033 8008              SJMP    ?C0065
                                           ; SOURCE LINE # 1568
0035         ?C0067:
                                           ; SOURCE LINE # 1569
0035 75BAE8            MOV     S2BRT,#0E8H
                                           ; SOURCE LINE # 1570
0038 8003              SJMP    ?C0065
                                           ; SOURCE LINE # 1571
003A         ?C0068:
                                           ; SOURCE LINE # 1572
003A 75BAF4            MOV     S2BRT,#0F4H
                                           ; SOURCE LINE # 1573
                                           ; SOURCE LINE # 1574
003D         ?C0065:
                                           ; SOURCE LINE # 1576
003D 7BFF              MOV     R3,#0FFH
003F 7A00        R     MOV     R2,#HIGH ?SC_25
0041 7900        R     MOV     R1,#LOW ?SC_25
0043 900000      R     MOV     DPTR,#gb_P_Com
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048 900000      E     MOV     DPTR,#?_Printf?BYTE+03H
004B E4                CLR     A
004C F0                MOVX    @DPTR,A
004D A3                INC     DPTR
004E EF                MOV     A,R7
004F F0                MOVX    @DPTR,A
0050 120000      E     LCALL   _Printf
                                           ; SOURCE LINE # 1577
0053 7F64              MOV     R7,#064H
0055 7E00              MOV     R6,#00H
0057 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 1580
005A E4                CLR     A
005B 900000      R     MOV     DPTR,#ii
005E F0                MOVX    @DPTR,A
005F         ?C0069:
005F 900000      R     MOV     DPTR,#ii
0062 120000      R     LCALL   L?0103
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 100 

0065 5010              JNC     ?C0070
                                           ; SOURCE LINE # 1581
                                           ; SOURCE LINE # 1582
0067 120000      R     LCALL   L?0097
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C 120000      E     LCALL   _RS2_tx
                                           ; SOURCE LINE # 1583
006F 900000      R     MOV     DPTR,#ii
0072 E0                MOVX    A,@DPTR
0073 04                INC     A
0074 F0                MOVX    @DPTR,A
0075 80E8              SJMP    ?C0069
0077         ?C0070:
                                           ; SOURCE LINE # 1585
0077 7F64              MOV     R7,#064H
0079 7E00              MOV     R6,#00H
007B 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 1586
007E 75BAF4            MOV     S2BRT,#0F4H
                                           ; SOURCE LINE # 1589
0081 22                RET     
             ; FUNCTION Send_PelcoD_Command (END)

C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 101 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


PresetMode . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0000H  1
FormatStart. . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
SetDATETIME. . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
second . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0001H  1
Update_CONFIG. . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
UpdateOK . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0002H  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
SendDVRStatus. . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
SpeedDomeMode. . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
GetDVRParam. . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
CAM_R. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Halt_OK. . . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
TriggerModeType. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
SendDVRParamDT . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
CAM_BAR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ABR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_Resolution . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0003H  1
CAM_CAR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ACR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_CBR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_BCR. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_timebeginesmonth . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0004H  1
Baud_rate. . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
Information. . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0005H  14
NumberStringType . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  11
  x. . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  y. . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  width. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  BackColor. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  Radix. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  NumColor . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  MaxLen . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  PrePostCharLen . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  PrePostChar. . . . . . . . . . . . .  MEMBER   -----  ARRAY    0008H  3
DoorClose. . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
SetDVRParam. . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
DVR_timebeginesweek. . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0013H  1
CAM_PTZ_RIGHT. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
minute . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0014H  1
FontData . . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  27
  font . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  27
DVR_RecordLength . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0015H  1
GetDVRStatus . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
RIGHT_TRIG . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LAST_TRIG_NON. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DoorState. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
CAM_SET. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
NORMALL_MODE . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
AVMode . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CommandBuffer. . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0016H  2
SourceModeType . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CAM_NUM. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_RS2_tx. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
InfoAutoDayNight_Night . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CMD_NUM. . . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
month. . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0018H  1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 102 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


InfoNoVideoSignal. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DoorOpen . . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
MANUALRECSTART . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
CAMC_TRIG. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LAST_TRIG_RIGHT. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
InformationLen . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0019H  1
GetInformation . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
CAM_RAB_H. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
OSDStrInfo . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  8
  cnt. . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
  attr . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  str. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
SetFormatSD. . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
GetDVRStatusflag . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1
CAM_BA . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_AB . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DVR_daylightsaving . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001AH  1
TimeType . . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  7
  x. . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  y. . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  width. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  BackColor. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  Format . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  TimeColor. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  CursorColor. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
CAM_CA . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_AC . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_FPS. . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001BH  1
CAM_PTZ_UP . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SetSystem. . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
REVERSE_TRIG . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_BC . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_CB . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_RecordMode . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001CH  1
DVR_RecordStatus . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001DH  1
SourceModeTypeEnum . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
DVR_Quality. . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001EH  1
struct_IdName. . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  17
  Id . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Name . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0001H  16
SetFormatSDDone. . . . . . . . . . . .  E_CONST  -----  INT      -----  2
EnumType . . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  17
  Sz . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  ByLang . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Str. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0002H  15
MenuType . . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  4
  width. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  height . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  TitleColor . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  CursorColor. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
CAM_RAB_T. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_RAC_T. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
CAM_PTZ_LEFT . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_RBC_T. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 103 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CAMNumber. . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
day. . . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001FH  1
hour . . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0020H  1
CAM_Iris_Open. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ZOOM_OUT_START . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LAST_TRIG_CAMC . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
InfoAutoDayNight_Auto. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LEFT_TRIG. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_Ready. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0004H  1
CAM_AR . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_BR . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_RB . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
PARK_TRIG. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_CR . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_standardtimebeginesWeek. . . . . .  PUBLIC   XDATA  U_CHAR   0021H  1
InfoAutoDayNight_Day . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_MENU_ENTER . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Register . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DVR_standardtimebeginesTime. . . . . .  PUBLIC   XDATA  U_CHAR   0022H  1
Send_PelcoD_Command. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ii . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
CAM_PTZ_DOWN . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_PostAlarmLength. . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0023H  1
DVR_PreAlarmLength . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0024H  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
LAST_TRIG_REVERSE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_sandardtimebeginesMonth. . . . . .  PUBLIC   XDATA  U_CHAR   0025H  1
CAM_CALL . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_CAM_TxCommand_toRS485 . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Com_ID . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  j. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
SerialNumber . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0026H  1
RS485_RX . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Baud_rate2400. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RS485_TX . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
No_TRIG. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_System . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0027H  1
FW_Update_Start. . . . . . . . . . . .  E_CONST  -----  INT      -----  2
NumType. . . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  5
  PrePostCharLen . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  PrePostChar. . . . . . . . . . . . .  MEMBER   -----  ARRAY    0001H  4
Send_PelcoP_Command. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ii . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0003H  1
DVRVersion . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0028H  17
_Wait_ms . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
CAM_PTZ_STOP . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
BOOKMARK . . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
RegisterInfo . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  INT      0004H  2
Baud_rate4800. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LAST_TRIG_LEFT . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_PCMDATA . . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  22
  Support. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 104 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  HAN. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0001H  2
  VAN. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  IVF. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0005H  2
  CLOCK. . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
  low. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0009H  2
  high . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000BH  2
  Hstart . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000DH  2
  Vstart . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000FH  2
  IPF. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0011H  2
  PPF. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0013H  2
  VBack. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0015H  1
Baud_rate9600. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_QUAD . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
FW_Update_OK . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
PelcoChoiceFLAG. . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
TriggerStatus. . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0039H  1
CAM_ZOOM_IN_START. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
InfoOSDMENULOCKED. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
PresetNumber . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   003AH  1
year1. . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   003BH  1
MANUALRECSTOP. . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
year2. . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   003CH  1
SetDVRDefault. . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
DefineMenu . . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  16
  Icon . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0000H  2
  Desc . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0002H  3
  PreFnId. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  PostFnId . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  IconColor. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  DescColor. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  Child. . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0009H  2
  Type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000BH  1
  ActiveWithCursor . . . . . . . . . .  MEMBER   -----  U_CHAR   000CH  1
  Id . . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000DH  1
  TypeData . . . . . . . . . . . . . .  MEMBER   -----  PTR      000EH  2
CMD_UNKNOWN. . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
TRIGGER_NUM. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_SDCardAvailable. . . . . . . . . .  PUBLIC   XDATA  U_CHAR   003DH  1
DisplayInformation . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
SEQ. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
InfoOSDMENUATCIVE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LongRegisterInfo . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  Min. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  Max. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  Default. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
HS_DvrCommand. . . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
S2BRT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
SendDVRParam . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
GPSState . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   003EH  1
PictureInfo. . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  4
  Register_Addr. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  EEPROM_Addr. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Control_Range. . . . . . . . . . . .  MEMBER   -----  PTR      0002H  2
CAM_RAC_T2 . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ABR_T3 . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_RBC_T2 . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ABR_T4 . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   HS_DVRPROTOCOL                                                    06/22/2022 16:23:04 PAGE 105 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


GPSReset . . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
CMD_NULL . . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
DVR_Busy . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   003FH  1
GetDATETIME. . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
CAM_A. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVR_timebeginesTime. . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0040H  1
SNAPSHOT . . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
CAM_B. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
InfoPLZRESETSYSTEM . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_C. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
FormatStatus . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0041H  1
_Printf. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
VGA_TRIG . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_CAB. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_BAC. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CAM_ABC. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DVRVersionLen. . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0042H  1
gb_P_Com . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0043H  2
DVR_OverWrite. . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0045H  1
Update_CONFIG_OK . . . . . . . . . . .  E_CONST  -----  INT      -----  2
GetDVRVersion. . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
AWT_LAST_TRIGGER . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
Halt_Start . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
SendAlarm. . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2
gb_PTZ_Speed . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0046H  1
DVR_TimeZone . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0047H  1
GetLCDMode . . . . . . . . . . . . . .  E_CONST  -----  INT      -----  2


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    854    ----
   CONSTANT SIZE    =     44    ----
   XDATA SIZE       =     72       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
